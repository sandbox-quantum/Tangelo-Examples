<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Fault Tolerant Building blocks</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg border-bottom" data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../hands_on/T1_circuits.html">Hands On</a></li><li class="breadcrumb-item"><a href="../hands_on/T5_fault_tolerant_build_blocks.html">Fault Tolerant Building blocks</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Examples</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false">
 <span class="menu-text">Chemistry</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/chemistry/excited_states.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Excited States in Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/chemistry/qchem_modelling_basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Quantum Chemistry: Modelling Basics</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false">
 <span class="menu-text">Fault Tolerant</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/fault_tolerant/qsp_state_prep.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">State preparation using quantum signal processing</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">
 <span class="menu-text">Hardware Experiments</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/hardware_experiments/berylium_ibm_quantum.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Combining Tangelo, QEMIST Cloud and IBM Quantum for quantum experiments</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/hardware_experiments/overview_endtoend.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/hardware_experiments/qemist_cloud_hardware_experiments_braket.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Submitting quantum hardware experiments with Tangelo and QEMIST Cloud</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/hardware_experiments/umbrella_inversion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exploring the umbrella inversion with quantum computers</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false">
 <span class="menu-text">Measurement Reduction</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/measurement_reduction/classical_shadows.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Classical Shadows</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="false">
 <span class="menu-text">Problem Decomposition</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/problem_decomposition/dmet.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Density Matrix Embedding Theory (DMET)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/problem_decomposition/dmet_uhf.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Applying Unrestricted Density-Matrix Embedding Theory to battery chemistry</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/problem_decomposition/ifci_mifno.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exploring the Method of Increments with QEMIST Cloud and Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/problem_decomposition/oniom.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ONIOM Problem Decomposition - A use case for an acetic acid molecule in water</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/problem_decomposition/qmmm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">The QM/MM method: Solvation of the Glycine Amino Acid</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="false">
 <span class="menu-text">Variational Methods</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/variational_methods/adapt.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ADAPT-VQE</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/variational_methods/iqcc_using_clifford.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Iterative Qubit Coupled Cluster using only Clifford circuits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/variational_methods/vqe.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">VQE with Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/variational_methods/vqe_custom_ansatz_hamiltonian.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo VQE: Custom Ansatz and qubit Hamiltonian Tutorial</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="false">
 <span class="menu-text">Workflow Basics</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/workflow_basics/1.the_basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Linq: the basics</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/workflow_basics/2.qpu_connection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Connecting to quantum services with Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/workflow_basics/3.noisy_simulation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Linq: noisy simulation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/workflow_basics/symbolic_simulator.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Performing symbolic simulation in Tangelo</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" aria-expanded="true">
 <span class="menu-text">Hands On</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T1_circuits.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: gates and circuits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T1_circuits_solved.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: gates and circuits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T2_simulators.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: simulating quantum circuits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T2_simulators_solved.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: simulating quantum circuits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T3_VQE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: VQE framework</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T3_VQE_solved.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: VQE framework</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T4_hardware_experiments.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: hardware experiments</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T4_hardware_experiments_solved.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: hardware experiments</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T5_fault_tolerant_build_blocks.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Fault Tolerant Building blocks</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T5_fault_tolerant_build_blocks_solved.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Fault Tolerant Building blocks</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../hands_on/T1_circuits.html">Hands On</a></li><li class="breadcrumb-item"><a href="../hands_on/T5_fault_tolerant_build_blocks.html">Fault Tolerant Building blocks</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Fault Tolerant Building blocks</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="fault-tolerant-building-blocks" class="level1">
<h1>Fault Tolerant Building blocks</h1>
<section id="before-you-jump-in" class="level2">
<h2 class="anchored" data-anchor-id="before-you-jump-in">Before you jump in</h2>
<p>This hands-on notebook complements existing tutorials, documentation and the developer notes available in the Tangelo GitHub repositories, which present content in much more depth.</p>
<p>You will come across code cells that require you to change code or fill in the blanks in order to achieve a desired outcome. There may be many ways to solve these small exercises, and you are encouraged to explore.</p>
<p>In order to complete this hands-on tutorial, we recommend you install the latest version of Tangelo. If you encounter errors related to missing Python packages (classical chemistry backend, quantum circuit simulator…), you can install them on-the-fly by typing <code>!pip install &lt;package-name&gt;</code> in a new code cell, and then restart the Jupyter notebook kernel.</p>
<div id="cell-3" class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># If Tangelo is not found in your current environment, this cell installs all dependencies required for this hands-on</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> tangelo</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ModuleNotFoundError</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>pip install git<span class="op">+</span>https:<span class="op">//</span>github.com<span class="op">/</span>goodchemistryco<span class="op">/</span>Tangelo.git<span class="op">@</span>develop  <span class="op">--</span>quiet</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>pip install pyscf <span class="op">--</span>quiet</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<p>For this hands-on, we recommend the following resources: - the first part of this <a href="https://github.com/goodchemistryco/Tangelo-Examples/blob/main/examples/workflow_basics/1.the_basics.ipynb">tutorial notebook</a> on <code>linq</code>, about gates and circuits. - the documentation for the <code>Gate</code> (<a href="http://tangelo-docs.goodchemistry.com/tangelo.linq.html#module-tangelo.linq.gate">here</a>) and <code>Circuit</code> (<a href="http://tangelo-docs.goodchemistry.com/tangelo.linq.html#module-tangelo.linq.circuit">here</a>) classes.</p>
<hr>
</section>
<section id="hands-on" class="level2">
<h2 class="anchored" data-anchor-id="hands-on">Hands-On</h2>
<p>Unlike NISQ algorithms which utilize shallow circuits and require many measurements, fault-tolerant algorithms rely on deeper circuits and fewer measurements. The quantum computer can efficiently store large (exponential) systems efficiently but preparing these states is time-consuming and we generally don’t need all the information about the state.</p>
<section id="controlled-operations" class="level3">
<h3 class="anchored" data-anchor-id="controlled-operations">1. Controlled Operations</h3>
<p>A main component of fault-tolerant algorithms is controlled operations. These are defined such that operations given a state of a certain (set of) qubit(s), one can apply an operation to a different set of qubits. For example, the usual CNOT (CX) Gate applies X to the target qubit only if the control qubit is in the <span class="math inline">\(\big|1\big&gt;\)</span> state, and does nothing otherwise. This can be written as</p>
<p><span class="math inline">\(CX\big|0\big&gt;\big|s\big&gt;=\big|0\big&gt;\big|s\big&gt;, \quad CX\big|1\big&gt;\big|s\big&gt;=\big|1\big&gt;X\big|s\big&gt;\)</span> where <span class="math inline">\(s\)</span> is any single-qubit state <span class="math inline">\(a\big|0\big&gt; + b\big|1\big&gt;\)</span>.</p>
<p>Likewise, this can be generalized to multiple controlled operations. For example, if we want to apply an operation <span class="math inline">\(U\)</span> only when the first 2-qubits are in state <span class="math inline">\(|1\rangle\)</span>. We can define</p>
<p><span class="math inline">\(C_{11}U\big|11\big&gt;\big|s\big&gt;=\big|11\big&gt;U\big|s\big&gt;, \quad C_{11}U\big|10\big&gt;\big|s\big&gt;=\big|10\big&gt;\big|s\big&gt;, \quad C_{11}U\big|01\big&gt;\big|s\big&gt;=\big|01\big&gt;\big|s\big&gt;, \quad C_{00}U\big|00\big&gt;\big|s\big&gt;=\big|00\big&gt;\big|s\big&gt;\)</span></p>
<p>Where the subscript <span class="math inline">\((11)\)</span> on the <span class="math inline">\(C\)</span> indicates that the first two qubits should be in state <span class="math inline">\(|1\rangle\)</span>. In general the operation can be controlled on many qubits and <span class="math inline">\(s\)</span> can be a many-qubit state.</p>
<div id="cell-9" class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> product</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.linq <span class="im">import</span> Circuit, Gate, get_backend</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># We use a cirq backend as the ordering of the statevector is the same as qubit operators, currently from Openfermion</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>sim <span class="op">=</span> get_backend(<span class="st">"cirq"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<blockquote class="blockquote">
<p><strong>Q:</strong> Can you fill in the blanks in the cell below, to run the algorithm for a controlled-X gate? In Tangelo, adding “C” in front of the gate’s name indicates that a controlled operation is requested.</p>
</blockquote>
<div id="cell-11" class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># INSERT YOUR CODE HERE</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>cx <span class="op">=</span> Gate(<span class="st">""</span>, , control<span class="op">=</span>[])</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Run through all possible combinations of inputs and print the result</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>c0 <span class="op">=</span> Circuit([cx])</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>c1 <span class="op">=</span> Circuit([Gate(<span class="st">"X"</span>, <span class="dv">0</span>), cx])</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"If qubit 0 is in state '0' then the frequencies are </span><span class="sc">{</span>sim<span class="sc">.</span>simulate(c0)[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"If qubit 0 is in state '1' then the frequencies are </span><span class="sc">{</span>sim<span class="sc">.</span>simulate(c1)[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<blockquote class="blockquote">
<p><strong>Q:</strong> Can you apply the operation controlled on qubits 1 and 2, such that the first qubit flips to state “1” only if qubits 1 and and 2 are in state “1” ? The <span class="math inline">\(C_{11}X\)</span> operation is also known as the Toffoli gate.</p>
</blockquote>
<div id="cell-13" class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># INSERT YOUR CODE HERE</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>ccx <span class="op">=</span> Gate(<span class="st">""</span>, , control<span class="op">=</span>[, ])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Run through all possible combinations of inputs and print the result</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>c00 <span class="op">=</span> Circuit([ccx])</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>c10 <span class="op">=</span> Circuit([Gate(<span class="st">"X"</span>, <span class="dv">0</span>), ccx])</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>c01 <span class="op">=</span> Circuit([Gate(<span class="st">"X"</span>, <span class="dv">1</span>), ccx])</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>c11 <span class="op">=</span> Circuit([Gate(<span class="st">"X"</span>, <span class="dv">0</span>), Gate(<span class="st">"X"</span>, <span class="dv">1</span>), ccx])</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"If qubits [0,1] are in state '00' then the frequencies are </span><span class="sc">{</span>sim<span class="sc">.</span>simulate(c00)[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"If qubits [0,1] are in state '10' then the frequencies are </span><span class="sc">{</span>sim<span class="sc">.</span>simulate(c01)[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"If qubits [0,1] are in state '01' then the frequencies are </span><span class="sc">{</span>sim<span class="sc">.</span>simulate(c10)[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"If qubits [0,1] are in state '11' then the frequencies are </span><span class="sc">{</span>sim<span class="sc">.</span>simulate(c11)[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If one wants to apply the operation <span class="math inline">\(C_{10}X\)</span>. The same operations can be used but sandwiched with <span class="math inline">\(X\)</span> gates. We flip second qubit using an <span class="math inline">\(X\big|0\big&gt;=\big|1\big&gt;\)</span> operation, apply the <span class="math inline">\(ccx\)</span> operation and apply <span class="math inline">\(X\big|1\big&gt;=\big|0\big&gt;\)</span> on the second qubit again. You can run the code below to obtain the same result.</p>
<div id="cell-15" class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>flip_2nd_qubit <span class="op">=</span> Gate(<span class="st">"X"</span>, <span class="dv">1</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Run through all possible combinations of inputs and print the result</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>c00 <span class="op">=</span> Circuit([flip_2nd_qubit, ccx, flip_2nd_qubit])</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>c10 <span class="op">=</span> Circuit([Gate(<span class="st">"X"</span>, <span class="dv">0</span>), flip_2nd_qubit, ccx, flip_2nd_qubit])</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>c01 <span class="op">=</span> Circuit([Gate(<span class="st">"X"</span>, <span class="dv">1</span>), flip_2nd_qubit, ccx, flip_2nd_qubit])</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>c11 <span class="op">=</span> Circuit([Gate(<span class="st">"X"</span>, <span class="dv">0</span>), Gate(<span class="st">"X"</span>, <span class="dv">1</span>), flip_2nd_qubit, ccx, flip_2nd_qubit])</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"If qubits [0,1] are in state '00' then the frequencies are </span><span class="sc">{</span>sim<span class="sc">.</span>simulate(c00)[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"If qubits [0,1] are in state '10' then the frequencies are </span><span class="sc">{</span>sim<span class="sc">.</span>simulate(c01)[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"If qubits [0,1] are in state '01' then the frequencies are </span><span class="sc">{</span>sim<span class="sc">.</span>simulate(c10)[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"If qubits [0,1] are in state '11' then the frequencies are </span><span class="sc">{</span>sim<span class="sc">.</span>simulate(c11)[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We successfully applied the operation <span class="math inline">\(C_{01}X\)</span> using the same <span class="math inline">\(CCX\)</span> gate you defined above.</p>
<p>In general, we can make more complicated controlled unitaries. For instance, we could implement quantum phase estimation, one of the key fault-tolerant algorithms. Using a series of controlled operations followed by a Quantum Fourier Transform (QFT), this algorithm can approximate the eigenvalues of a state.</p>
</section>
<section id="quantum-phase-estimation" class="level3">
<h3 class="anchored" data-anchor-id="quantum-phase-estimation">2. Quantum Phase Estimation</h3>
<p>The first fault-tolerant algorithm we look at in is quantum phase-estimation (QPE). It is a technique to obtain the energy (E) of an eigenstate <span class="math inline">\(\big|\psi_e\big&gt;\)</span> of a Hamiltonian defined <span class="math inline">\(H\big|\psi_e\big&gt;=E\big|\psi_e\big&gt;\)</span>. The energy is a very important quantity to know in chemistry as it determines how chemistry happens from chemical reactions to light-matter interactions.</p>
<p>The input is an approximate eigenstate <span class="math inline">\(\big|\psi_e\big&gt;\)</span>. QPE then utilizes a series of controlled time-evolutions of a Hamiltonian on different qubits followed by the quantum version of the Fourier Transform (i.e.&nbsp;<a href="https://en.wikipedia.org/wiki/Quantum_Fourier_transform">Quantum Fourier Transform</a> (QFT)). The circuit is shown below:</p>
<p><img src="PE_Circuit.png" alt="H2O" width="700"></p>
<blockquote class="blockquote">
<p>Tangelo provides a <code>QPESolver</code> class allowing you to simulate QPE with built-in and user-defined unitaries, for time-evolution. If you are already familiar with <code>VQESolver</code> then its interface should feel straightforward. We illustrate this ready-made QPE framework briefly at the end of the section. The first part of this section of the hands-on however offers to retrace the steps taken to implement such fault-tolerant algorithms, and manipulating advanced building-blocks (controlled unitaries, trotterization, QFT, circuit inverses, simulation with desired measurements …).</p>
</blockquote>
</section>
<section id="a-building-qpe-from-scratch-with-fault-tolerant-building-blocks" class="level3">
<h3 class="anchored" data-anchor-id="a-building-qpe-from-scratch-with-fault-tolerant-building-blocks">a) Building QPE from “scratch” with fault-tolerant building blocks</h3>
<p>For our use case, we first generate the qubit Hamiltonian for molecular Hydrogen (<span class="math inline">\(H_2\)</span>) in a STO-3G basis. To show the algorithm is working as expected, we calculate all the eigenstates and select the two singlet states with 2 electrons. This is not possible for much larger systems but we can extrapolate the success demonstrated here to show that we can obtain good results.</p>
<div id="cell-21" class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> openfermion <span class="im">import</span> get_sparse_operator</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.molecule_library <span class="im">import</span> mol_H2_sto3g</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.qubit_mappings.mapping_transform <span class="im">import</span> fermion_to_qubit_mapping</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.qubit_mappings.statevector_mapping <span class="im">import</span> get_reference_circuit</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Qubit operator representing H2 in a minimal basis</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> mol_H2_sto3g</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>qu_op <span class="op">=</span> fermion_to_qubit_mapping(mol.fermionic_hamiltonian, mapping<span class="op">=</span><span class="st">"JW"</span>, </span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>                                 n_spinorbitals<span class="op">=</span>mol.n_active_sos, n_electrons<span class="op">=</span>mol.n_active_electrons, </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>                                 spin<span class="op">=</span>mol.spin, up_then_down<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Shift ground state eigenvalue to be 0.25, such that a short-time QPE can return the exact energy</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="co"># (the exact ground state energy is known to be 1.137270174660903)</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>qu_op <span class="op">+=</span> (<span class="fl">0.25</span> <span class="op">+</span> <span class="fl">1.137270174660903</span>)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>eigs, eigenstates <span class="op">=</span> np.linalg.eigh(get_sparse_operator(qu_op).toarray())</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co"># When converting from a Fermion Hamiltonian to an Qubit Hamiltonian, a bunch of physical but not desired eigenstates are obtained</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="co"># We are looking for the ground and first excited Singlet S^2 states.</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>ground_sv <span class="op">=</span> eigenstates[:, <span class="dv">0</span>]</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>first_sv <span class="op">=</span> eigenstates[:, <span class="dv">13</span>]  </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In order to compare how close the initial approximate state is to the exact eigenstate, we are going to use the overlap (dot product) between the states. If the overlap is 1 then the states are equivalent.</p>
<div id="cell-23" class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Hartree-Fock reference state circuit</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>hf_circuit <span class="op">=</span> get_reference_circuit(n_spinorbitals<span class="op">=</span>mol.n_active_sos, n_electrons<span class="op">=</span>mol.n_active_electrons, mapping<span class="op">=</span><span class="st">"JW"</span>,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                                   up_then_down<span class="op">=</span><span class="va">False</span>, spin<span class="op">=</span>mol.spin)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>f, hf_sv <span class="op">=</span> sim.simulate(hf_circuit, return_statevector<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Dot product to compare how close the initial Hartree-Fock reference is to the ground and first excited singlet state.</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>g_ovlp <span class="op">=</span> np.dot(hf_sv, ground_sv)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>f_ovlp <span class="op">=</span> np.dot(hf_sv, first_sv)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The overlap of the initial (Hartree-Fock) state with the exact ground state is        </span><span class="sc">{</span>g_ovlp<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The overlap of the initial (Hartree-Fock) state with the exact first excited state is </span><span class="sc">{</span>f_ovlp<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<blockquote class="blockquote">
<p><strong>Q:</strong> Can you fill in the blanks in the cell below, to run the algorithm originally illustrated in the circuit diagram ? It should return <code>"010"</code> with very-high probability (~98%), corresponding to an energy of 0.25. You may need to change the parameters used in the Trotter-Suzuki (<code>trotterize</code>) operation to obtain accurate enough time-evolution to get a good result.</p>
</blockquote>
<div id="cell-25" class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.ansatz_generator.ansatz_utils <span class="im">import</span> trotterize, get_qft_circuit</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.post_processing.histogram <span class="im">import</span> Histogram</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Reverse order as cirq uses lsq_first</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>qubit_list <span class="op">=</span> [<span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">4</span>]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># State preparation</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>pe_circuit <span class="op">=</span> hf_circuit <span class="op">+</span> Circuit([Gate(<span class="st">"H"</span>, q) <span class="cf">for</span> q <span class="kw">in</span> qubit_list])</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, qubit <span class="kw">in</span> <span class="bu">enumerate</span>(qubit_list):</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># INSERT CODE HERE</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># You can play around with how accurate the time-evolution needs to be</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use negative time as trotterize uses exp(-iHt) to follow the Schrodinger equation</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    pe_circuit <span class="op">+=</span> trotterize(qu_op, trotter_order<span class="op">=</span>, n_trotter_steps<span class="op">=</span>, time<span class="op">=</span>, control<span class="op">=</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co"># INSERT CODE HERE</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Set inverse to true or false</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>pe_circuit <span class="op">+=</span> get_qft_circuit(qubit_list, inverse<span class="op">=</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>freqs, _ <span class="op">=</span> sim.simulate(pe_circuit)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove qubit indices from histogram corresponding to the state qubits i.e. (0, 1, 2, 3)</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>hist <span class="op">=</span> Histogram(freqs)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>hist.remove_qubit_indices(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, probability <span class="kw">in</span> hist.frequencies.items():</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>      energy <span class="op">=</span> <span class="bu">sum</span>(<span class="bu">int</span>(k)<span class="op">/</span><span class="dv">2</span><span class="op">**</span>(i<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> i, k <span class="kw">in</span> <span class="bu">enumerate</span>(key))</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(<span class="ss">f"The measurement </span><span class="sc">{</span>key<span class="sc">}</span><span class="ss"> with probability </span><span class="sc">{</span>probability<span class="sc">:3.5f}</span><span class="ss"> converts to an energy=</span><span class="sc">{</span>energy<span class="sc">}</span><span class="ss"> "</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In Tangelo, simulators can take the option <code>desired_measurement</code> to return the quantum state corresponding to the state preparation done under specific values of measurement gates. Assuming you are interested in a specific outcome - <code>"010"</code> for our use case - we can retrieve both the probability that such measurements are observed, and the corresponding quantum state and compute its overlap with the ground state:</p>
<div id="cell-27" class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>desired_measurement <span class="op">=</span> <span class="st">"010"</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>pe_plus_measure <span class="op">=</span> pe_circuit <span class="op">+</span> Circuit([Gate(<span class="st">"MEASURE"</span>, i) <span class="cf">for</span> i <span class="kw">in</span> qubit_list])</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>_, sv_new <span class="op">=</span> sim.simulate(pe_plus_measure, desired_meas_result<span class="op">=</span>desired_measurement, return_statevector<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The probability of this measurement is </span><span class="sc">{</span>pe_plus_measure<span class="sc">.</span>success_probabilities[desired_measurement]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Shrink vector down to 2**4 size to compare with exact ground state.</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>sv_new_post <span class="op">=</span> np.reshape(sv_new, (<span class="dv">2</span><span class="op">**</span><span class="dv">4</span>, <span class="dv">2</span><span class="op">**</span><span class="dv">3</span>))[:, <span class="bu">int</span>(desired_measurement, base<span class="op">=</span><span class="dv">2</span>)]</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The final state overlap with the ground state is </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">abs</span>(np.dot(sv_new_post, ground_sv))<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can see that we measured the desired energy with probability 0.987 and the resulting state has overlap with the exact state of 0.99997, while we originally started with an overlap of 0.9936. We not only measured the energy of an eigenstate, we also created the eigenstate on the simulator. This eigenstate can then be used to perform other tasks!</p>
<blockquote class="blockquote">
<p><strong>Q:</strong> By using the previous cell as an example, can you look into what happens for “111”, which is close to the energy of the first excited singlet state?</p>
</blockquote>
<div id="cell-30" class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># INSERT CODE HERE</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>desired_measurement <span class="op">=</span> <span class="st">"111"</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>pe_plus_measure <span class="op">=</span> pe_circuit <span class="op">+</span> Circuit([Gate(<span class="st">"MEASURE"</span>, i) <span class="cf">for</span> i <span class="kw">in</span> qubit_list])</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>_, sv_new <span class="op">=</span> sim.simulate(pe_plus_measure, desired_meas_result<span class="op">=</span>desired_measurement, return_statevector<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The probability of this measurement is </span><span class="sc">{</span>pe_plus_measure<span class="sc">.</span>success_probabilities[desired_measurement]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Shrink vector down to 2**4 size to compare with exact ground state.</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>sv_new_post <span class="op">=</span> np.reshape(sv_new, (<span class="dv">2</span><span class="op">**</span><span class="dv">4</span>, <span class="dv">2</span><span class="op">**</span><span class="dv">3</span>))[:, <span class="bu">int</span>(desired_measurement, base<span class="op">=</span><span class="dv">2</span>)]</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The final state overlap with the first excited singlet state is </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">abs</span>(np.dot(sv_new_post, first_sv))<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can see that starting with the same Hartree-Fock reference state, we obtained a good approximation (<span class="math inline">\(&gt;0.999\)</span>) overlap to the first excited singlet state when measuring a result close to the exact energy with very low probability (around 1%). Also, the energy we obtained <span class="math inline">\(0.875\)</span> is not chemically accurate (<span class="math inline">\(&lt;0.001\)</span> Hartree error). We can only obtain energies mod 1 and the exact energy is <span class="math inline">\(1.867\)</span> so the error is <span class="math inline">\(0.008\)</span>.</p>
<p>However, even this is fortunate. To ensure we obtain chemical accuracy, we would need to run the algorithm with 7 ancilla qubits <span class="math inline">\(1/2^7\approx 0.008\)</span>. This would require time-evolution that is about 16 times longer that what we ran above.</p>
</section>
<section id="b-ready-made-qpesolver-framework" class="level3">
<h3 class="anchored" data-anchor-id="b-ready-made-qpesolver-framework">b) Ready-made QPESolver framework</h3>
<p>Tangelo provides a <code>QPESolver</code> class allowing you to simulate QPE with built-in and user-defined unitaries, for time-evolution. If you are already familiar with <code>VQESolver</code> then its interface should feel straightforward (instantiate with options, <code>build</code>, <code>simulate</code>, <code>get_resources</code>). You can check out the <a href="https://github.com/goodchemistryco/Tangelo/blob/develop/tangelo/algorithms/projective/tests/test_qpe.py">source code</a> in the tests in Tangelo to see how one could provide a molecule, or built-in unitaries. Below, we reproduce the work done in the previous section by directly passing the qubit Hamiltonian we obtained for <span class="math inline">\(H_2\)</span> earlier.</p>
<div id="cell-33" class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.algorithms.projective.qpe <span class="im">import</span> QPESolver</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co"># INSERT YOUR PARAMETERS FROM ABOVE HERE</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Leave time as it is the base time evolution, the extra 2^n is added by QPESolver</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>qpe_solver <span class="op">=</span> QPESolver({<span class="st">"qubit_hamiltonian"</span>: qu_op, <span class="st">"size_qpe_register"</span>: <span class="dv">3</span>, <span class="st">"ref_state"</span>: hf_circuit, <span class="st">"backend_options"</span>: {<span class="st">"target"</span>: <span class="st">"cirq"</span>},</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>                 <span class="st">"unitary_options"</span>: {<span class="st">"time"</span>: <span class="op">-</span><span class="dv">2</span><span class="op">*</span>np.pi, <span class="st">"n_trotter_steps"</span>: , <span class="st">"n_steps_method"</span>: <span class="st">"time"</span>, <span class="st">"trotter_order"</span>: }})</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>qpe_solver.build()</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>energy <span class="op">=</span> qpe_solver.simulate()</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"QPESolver returned an energy of </span><span class="sc">{</span>energy<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, probability <span class="kw">in</span> qpe_solver.qpe_freqs.items():</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    energy <span class="op">=</span> <span class="bu">sum</span>(<span class="bu">int</span>(k)<span class="op">/</span><span class="dv">2</span><span class="op">**</span>(i<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> i, k <span class="kw">in</span> <span class="bu">enumerate</span>(key))</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"The measurement </span><span class="sc">{</span>key<span class="sc">}</span><span class="ss"> with probability </span><span class="sc">{</span>probability<span class="sc">:3.5f}</span><span class="ss"> converts to an energy=</span><span class="sc">{</span>energy<span class="sc">}</span><span class="ss"> "</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Much simpler, isn’t it ? If you would like to see more fault-tolerant algorithms available “out of the box” in Tangelo, please consider contributing to the project or put a feature request on GitHub.</p>
</section>
<section id="block-encodings." class="level3">
<h3 class="anchored" data-anchor-id="block-encodings.">3 .Block encodings.</h3>
<p>Another building block of many fault-tolerant algorithms is block encodings. This is a technique to implement any operation as long as it can be decomposed into a linear combination of Unitaries. We can implement the operation using <span class="math inline">\(U_{prep}\)</span> and <span class="math inline">\(U_{select}\)</span> defined for a general operator <span class="math inline">\(A=\sum_i c_i U_i\)</span> where <span class="math inline">\(U_i\)</span> are unitaries.</p>
<p><span class="math inline">\(U_{prep}\big|\psi\big&gt;\big|0\big&gt; = \sum_{i}\sqrt{\frac{|c_i|}{\alpha}}\big|\psi\big&gt;\big|i\big&gt;\)</span></p>
<p><span class="math inline">\(U_{select}\big|\psi\big&gt;\big|i\big&gt; = U_i\big|\psi\big&gt;\big|i\big&gt;\)</span></p>
<p>where <span class="math inline">\(\alpha\)</span> is the 1-norm of the coefficients <span class="math inline">\(|c_i|\)</span></p>
<p>Applying the circuit <span class="math inline">\(U_{prep}U_{select}U_{prep}^{\dagger}\)</span> results in <span class="math inline">\(A\big|\psi\big&gt;\big|0\big&gt; + \sum_i \big|\psi^{\perp}\big&gt;\big|i\big&gt;\)</span> where <span class="math inline">\(\psi^{\perp}\)</span> are states orthogonal to <span class="math inline">\(A\psi\)</span>. This means that if we measure the ancilla qubits and the result is zero, we have successfully applied the desired operation <span class="math inline">\(A\)</span>.</p>
<p>For example, let’s try to apply <span class="math inline">\(A=\frac{1}{\sqrt{2}}X+\frac{1}{\sqrt{2}}Y\)</span> which is equivalent to <span class="math inline">\(\left[\begin{array}{cc}0&amp;\frac{1-i}{\sqrt{2}}\\ \frac{1+i}{\sqrt{2}}&amp;0\end{array}\right]\)</span></p>
<div id="cell-37" class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.operators <span class="im">import</span> QubitOperator</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.linq.helpers.circuits.statevector <span class="im">import</span> StateVector</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>coefs <span class="op">=</span> [<span class="dv">1</span><span class="op">/</span>np.sqrt(<span class="dv">2</span>), <span class="dv">1</span><span class="op">/</span>np.sqrt(<span class="dv">2</span>)]</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> QubitOperator(<span class="st">"X0"</span>, coefs[<span class="dv">0</span>]) <span class="op">+</span> QubitOperator(<span class="st">"Y0"</span>, coefs[<span class="dv">1</span>])</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>vec <span class="op">=</span> np.array(np.<span class="bu">abs</span>(coefs))</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>vec <span class="op">=</span> np.sqrt(vec<span class="op">/</span>np.<span class="bu">sum</span>(vec))</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co"># In this case prep can be be applied by simply applying the Hadamard gate to the first qubit</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>uprep <span class="op">=</span> Circuit([Gate(<span class="st">"H"</span>, <span class="dv">1</span>)])</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>sv <span class="op">=</span> StateVector(vec)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>uprep <span class="op">=</span> sv.initializing_circuit()</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>uprep.reindex_qubits([<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<blockquote class="blockquote">
<p><strong>Q:</strong> Can you fill in the blanks in the cell below, to apply the <span class="math inline">\(U_{select}\)</span> operation <span class="math inline">\(A\)</span> defined as a linear combination of unitaries <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> ?</p>
</blockquote>
<div id="cell-39" class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># INSERT YOUR CODE HERE</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Qubit 1 is the "prep" register with coefficients [1/sqrt(2), 1/sqrt(2)]</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>cy1 <span class="op">=</span> [Gate(<span class="st">""</span>, target<span class="op">=</span>, control<span class="op">=</span>)]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Sandwiching with "X" gates flips the control bit such that operation is controled on state "0"</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>cx0 <span class="op">=</span> [Gate(<span class="st">""</span>, ), Gate(<span class="st">""</span>, target<span class="op">=</span>, control<span class="op">=</span>), Gate(<span class="st">""</span>, )]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now run the block-encoded circuit. If your code is correct, it will return the correct state with probability 0.5 and the overlap will be 1.</p>
<div id="cell-41" class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Uselect</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>uselect <span class="op">=</span> Circuit(cx0 <span class="op">+</span> cy1)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co"># We will use this as a state prep circuit. You can change this to any set of operations on qubit 0</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>state_prep <span class="op">=</span> Circuit([Gate(<span class="st">"RY"</span>, <span class="dv">0</span>, parameter<span class="op">=</span>np.pi<span class="op">/</span><span class="dv">4</span>)])</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>_, init_state <span class="op">=</span> sim.simulate(state_prep, return_statevector<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>block_circuit <span class="op">=</span> uprep <span class="op">+</span> uselect <span class="op">+</span> uprep.inverse() </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>circuit <span class="op">=</span> state_prep <span class="op">+</span> block_circuit <span class="op">+</span> Circuit([Gate(<span class="st">"MEASURE"</span>, <span class="dv">1</span>)])</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>desired_measurement <span class="op">=</span> <span class="st">"0"</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>f, sv <span class="op">=</span> sim.simulate(circuit, desired_meas_result<span class="op">=</span>desired_measurement, return_statevector<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>final_state <span class="op">=</span> sv.reshape(<span class="dv">2</span>,<span class="dv">2</span>)[:,<span class="bu">int</span>(desired_measurement, base<span class="op">=</span><span class="dv">2</span>)]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The success probability of the operation was </span><span class="sc">{</span>circuit<span class="sc">.</span>success_probabilities[<span class="st">'0'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>final_exact <span class="op">=</span> get_sparse_operator(a).toarray() <span class="op">@</span> init_state</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>final_exact <span class="op">/=</span> np.linalg.norm(final_exact)</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The overlap of the exact with the block encoded application of A is </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">abs</span>(np.vdot(final_state, final_exact))<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="amplitude-amplification" class="level3">
<h3 class="anchored" data-anchor-id="amplitude-amplification">4. Amplitude Amplification</h3>
<p>We would like to have a higher probability of success than 0.5. This is the main point of <a href="https://en.wikipedia.org/wiki/Grover%27s_algorithm">Grover’s search</a> where <span class="math inline">\(\sqrt{N}\)</span> amplifications of the desired “good” state is required to increase the probability by <span class="math inline">\(N\)</span>. Hence, the quadratic speed up. To implement this we need to apply signed operations. However, we are going to implement the generalized <a href="https://en.wikipedia.org/wiki/Amplitude_amplification">Amplitude Amplification</a> which is defined by the following circuit,</p>
<p><span class="math inline">\(F_{good} F_{full}\)</span>,</p>
<p>where <span class="math inline">\(F_{good} = (1-\big|0\big&gt;^{ancilla}\big&lt;0\big|^{ancilla})\)</span> and <span class="math inline">\(F_{full} = (1-A\big|\psi\big&gt;\big&lt;\psi\big|A)\)</span> are in general (non-unitary operations).</p>
<p>For the purposes of applying <span class="math inline">\(A=\frac{1}{\sqrt{2}}X+\frac{1}{\sqrt{2}}Y\)</span>, the “good” subspace is all zeros on the ancilla qubits and the “full” state is the application of the state preparation and the <span class="math inline">\(A\)</span> block encoding.</p>
<p>In order to facilitate amplitude amplification, we are going to make the 1-norm of the operator 2 such that the success probability is 25%. In order to facilitate this, the operator being applied is <span class="math inline">\((I - I + X + Y)\)</span> which as <span class="math inline">\(\big|\big| A \big|\big|_1=2\)</span> and the probability of success is <span class="math inline">\(1/\left(\big|\big| A \big|\big|_1\right)^4\)</span>. After one application of amplitude amplification, the operator will be applied with 100% probability.</p>
<blockquote class="blockquote">
<p><strong>Note:</strong> The “trick” of adding and subtracting terms proportional to the identity operator is common in fault-tolerant algorithms to obtain a circuit that has a success probability close to 100%.</p>
</blockquote>
<div id="cell-44" class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.circuits.lcu <span class="im">import</span> sign_flip, get_uprep_uselect</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate operator and make 1-norm equal to 2 to ensure that the operation applies with 100% success</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>uprep, uselect, state_qubits, ancilla_qubits, alpha <span class="op">=</span> get_uprep_uselect(a, make_alpha_eq_2<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> flip_on_state(qubits: <span class="bu">list</span>, circuit: Circuit):</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> circuit.inverse() <span class="op">+</span> sign_flip(qubits) <span class="op">+</span> circuit</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>block_circuit <span class="op">=</span> uprep <span class="op">+</span> uselect <span class="op">+</span> uprep.inverse()</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>full_circuit <span class="op">=</span> state_prep <span class="op">+</span> block_circuit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<blockquote class="blockquote">
<p><strong>Q:</strong> Can you fill in the blanks in the cell below to define the appropriate qubits and operation that the sign flip operations are applied to ? Remember that the amplifying circuit is <span class="math inline">\(F_{good}F_{full}\)</span>. Which qubits and what circuit generates the “good” <span class="math inline">\(|0\big&gt;^{ancilla}\)</span> state? Which qubits and what circuit generates the “full” <span class="math inline">\(A|\psi\big&gt;\)</span>?</p>
</blockquote>
<div id="cell-46" class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># INSERT YOUR CODE HERE</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>amplifying_circuit <span class="op">=</span> flip_on_state(qubits<span class="op">=</span>, circuit<span class="op">=</span>) <span class="op">+</span> flip_on_state(qubits<span class="op">=</span>, circuit<span class="op">=</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now check when comparing the unamplified circuit and the amplified circuit that the resulting statevector is the same (i.e.&nbsp;overlap is still 1) but the probability of success is 100%.</p>
<div id="cell-48" class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>unamplified_circuit <span class="op">=</span> state_prep <span class="op">+</span> block_circuit <span class="op">+</span> Circuit([Gate(<span class="st">"MEASURE"</span>, q) <span class="cf">for</span> q <span class="kw">in</span> ancilla_qubits])</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>amplified_circuit <span class="op">=</span> state_prep <span class="op">+</span> block_circuit <span class="op">+</span> amplifying_circuit <span class="op">+</span> Circuit([Gate(<span class="st">"MEASURE"</span>, q) <span class="cf">for</span> q <span class="kw">in</span> ancilla_qubits])</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>f, sv <span class="op">=</span> sim.simulate(amplified_circuit, return_statevector<span class="op">=</span><span class="va">True</span>, desired_meas_result<span class="op">=</span><span class="st">"0"</span><span class="op">*</span><span class="bu">len</span>(ancilla_qubits))</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>amplified_final_state <span class="op">=</span> sv.reshape(<span class="dv">2</span>,<span class="dv">4</span>)[:,<span class="dv">0</span>]</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>f, sv <span class="op">=</span> sim.simulate(unamplified_circuit, return_statevector<span class="op">=</span><span class="va">True</span>, desired_meas_result<span class="op">=</span><span class="st">"0"</span><span class="op">*</span><span class="bu">len</span>(ancilla_qubits))</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>unamplified_final_state <span class="op">=</span> sv.reshape(<span class="dv">2</span>,<span class="dv">4</span>)[:,<span class="dv">0</span>]</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The overlap of the two states are </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">abs</span>(np.vdot(amplified_final_state, unamplified_final_state))<span class="sc">: 3.2f}</span><span class="ss">"</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The success probability has been increased from </span><span class="sc">{</span>unamplified_circuit<span class="sc">.</span>success_probabilities[<span class="st">'00'</span>]<span class="sc">: 3.2f}</span><span class="ss"> to "</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"</span><span class="sc">{</span>amplified_circuit<span class="sc">.</span>success_probabilities[<span class="st">'00'</span>]<span class="sc">: 3.2f}</span><span class="ss"> after amplitude amplification"</span>)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The overlap of the amplified state with the exact state is </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">abs</span>(np.vdot(final_state, amplified_final_state))<span class="sc">: 3.2f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="final-words" class="level2">
<h2 class="anchored" data-anchor-id="final-words">Final Words</h2>
<p>After this hands-on, you learned some of the building blocks of fault tolerant algorithms. You now understand how one utilizes controlled operations to obtain interesting information about a system (namely energy using QPE). You also learned about block-encodings which allow you to apply any operation probabilistically. Finally you learned about how to increase the probability of success using amplitude amplification.</p>
<p>If you are interested in contributing ready-made versions of fault-tolerant algorithms to the project, please do not hesitate !</p>
<p>Here are some additional material implementing some other fault-tolerant approaches which may be relevant to you: * Block encoding used for <a href="https://github.com/goodchemistryco/Tangelo-Examples/blob/main/examples/fault_tolerant/qsp_state_prep.ipynb">state preparation through Quantum Signal Processing</a>. * More <a href="https://github.com/goodchemistryco/Tangelo/blob/develop/tangelo/algorithms/projective/tests/test_qpe.py">QPESolver examples</a> * <a href="https://aws.amazon.com/blogs/quantum-computing/exploring-quantum-chemistry-applications-with-tangelo-and-qemist-cloud-using-amazon-braket/">AWS Blog post</a> that features a fault-tolerant simulation of a wavepacket</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>