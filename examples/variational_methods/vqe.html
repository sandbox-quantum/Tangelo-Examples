<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>VQE with Tangelo</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar docked nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark border-bottom">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Examples</li><li class="breadcrumb-item"><a href="../../examples/variational_methods/adapt.html">Variational Methods</a></li><li class="breadcrumb-item"><a href="../../examples/variational_methods/vqe.html">VQE with Tangelo</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Examples</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false">
 <span class="menu-text">Chemistry</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/chemistry/excited_states.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Excited States in Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/chemistry/qchem_modelling_basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Quantum Chemistry: Modelling Basics</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false">
 <span class="menu-text">Fault Tolerant</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/fault_tolerant/qsp_state_prep.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">State preparation using quantum signal processing</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">
 <span class="menu-text">Hardware Experiments</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/hardware_experiments/berylium_ibm_quantum.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Combining Tangelo, QEMIST Cloud and IBM Quantum for quantum experiments</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/hardware_experiments/overview_endtoend.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/hardware_experiments/qemist_cloud_hardware_experiments_braket.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Submitting quantum hardware experiments with Tangelo and QEMIST Cloud</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/hardware_experiments/umbrella_inversion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exploring the umbrella inversion with quantum computers</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false">
 <span class="menu-text">Measurement Reduction</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/measurement_reduction/classical_shadows.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Classical Shadows</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="false">
 <span class="menu-text">Problem Decomposition</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/problem_decomposition/dmet.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Density Matrix Embedding Theory (DMET)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/problem_decomposition/dmet_uhf.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Applying Unrestricted Density-Matrix Embedding Theory to battery chemistry</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/problem_decomposition/mifno.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exploring the Method of Increments with QEMIST Cloud and Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/problem_decomposition/oniom.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ONIOM Problem Decomposition - A use case for an acetic acid molecule in water</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="true">
 <span class="menu-text">Variational Methods</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth2 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/variational_methods/adapt.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ADAPT-VQE</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/variational_methods/iqcc_using_clifford.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Iterative Qubit Coupled Cluster using only Clifford circuits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/variational_methods/vqe.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">VQE with Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/variational_methods/vqe_custom_ansatz_hamiltonian.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo VQE: Custom Ansatz and qubit Hamiltonian Tutorial</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="false">
 <span class="menu-text">Workflow Basics</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/workflow_basics/1.the_basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Linq: the basics</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/workflow_basics/2.qpu_connection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Connecting to quantum services with Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/workflow_basics/3.noisy_simulation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Linq: noisy simulation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/workflow_basics/symbolic_simulator.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Performing symbolic simulation in Tangelo</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">VQE with Tangelo</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://colab.research.google.com/github/goodchemistryco/Tangelo-Examples/blob/main/examples/variational_methods/vqe.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" class="img-fluid figure-img"></a></p>
<figcaption class="figure-caption">Open In Colab</figcaption>
</figure>
</div>
<p>Tangelo provides various toolboxes, which can be leveraged to build quantum chemistry workflows relying on quantum computing. One example of such a workflow is the Variational Quantum Eigensolver (VQE). We provide an implementation of VQE that supports several options, and may provide valuable help in your research and applications.</p>
<p>This notebook assumes that you already have installed Tangelo in your Python environment, or have updated your Python path so that the imports can be resolved. If not, executing the cell below installs the minimal requirements for this notebook.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Installation of tangelo if not already installed.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> tangelo</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ModuleNotFoundError</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>pip install git<span class="op">+</span>https:<span class="op">//</span>github.com<span class="op">/</span>goodchemistryco<span class="op">/</span>Tangelo.git<span class="op">@</span>develop <span class="op">--</span>quiet</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Additional dependencies: pyscf (classical chemistry) and qulacs (quantum circuit simulation)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> qulacs</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ModuleNotFoundError</span>:</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>pip install pyscf qulacs <span class="op">--</span>quiet</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="table-of-contents" class="level2">
<h2 class="anchored" data-anchor-id="table-of-contents">Table of contents:</h2>
<ul>
<li><a href="#1">1. Overview of VQE</a></li>
<li><a href="#2">2. VQESolver class</a>
<ul>
<li><a href="#21">2.1 VQESolver instantiation</a></li>
<li><a href="#22">2.2 VQESolver.build</a></li>
<li><a href="#23">2.3 VQESolver.simulate</a></li>
<li><a href="#24">2.4 VQESolver.energy_estimation</a></li>
<li><a href="#25">2.5 VQESolver.get_resources</a></li>
<li><a href="#26">2.6 VQESolver.get_rdm</a></li>
</ul></li>
<li><a href="#3">3. Option: frozen orbitals</a></li>
<li><a href="#4">4. Option: ansatz and qubit mapping</a></li>
<li><a href="#5">5. Option: classical optimizers and initial parameters</a></li>
<li><a href="#6">6. Option: compute backend</a></li>
</ul>
</section>
<section id="overview-of-vqe" class="level2">
<h2 class="anchored" data-anchor-id="overview-of-vqe">1. Overview of VQE <a class="anchor" id="1"></a></h2>
<p>The Variational Quantum Eigensolver (VQE) [<a href="https://arxiv.org/abs/1304.3061">Peruzzo_et_al.,_2014</a>, <a href="https://arxiv.org/abs/1509.04279">McClean_et_al.,_2015</a>] has been introduced as a hybrid quantum–classical algorithm for simulating quantum systems. Some examples of quantum simulation using VQE include solving the molecular electronic Schrödinger equation and model systems in condensed matter physics (e.g., Fermi– and Bose–Hubbard models). In this notebook, we focus on VQE within the context of solving the molecular electronic structure problem for the ground-state energy of a molecular system. The second-quantized Hamiltonian of such a system, within the Born-Oppenheimer approximation, assumes the following form:</p>
<p><span class="math display">\[
\hat{H} = h_{\text{nuc}} + \sum\limits_{p,q} h^{p}_{q} a^{\dagger}_p a_q + \sum\limits_{p,q,r,s} h^{pq}_{rs} a^{\dagger}_p a^{\dagger}_q a_s a_r\nonumber
\]</span></p>
<p>Here, <span class="math inline">\(h_{\text{nuc}}\)</span> denotes the nuclear repulsion energy. In what follows below, we use the mean-field solution from Hartee-Fock (HF) self-consistent theory as our computational starting point. As such, the basis-orbitals and coefficients <span class="math inline">\(h_p^q\)</span>, <span class="math inline">\(h_{rs}^{pq}\)</span>, are evaluated in the basis of molecular orbitals from HF. The Hamiltonian is then transformed into the qubit basis (e.g., Jordan–Wigner, Bravyi–Kitaev). This means that it is expressed entirely in terms of operators acting on qubits:</p>
<p><span class="math display">\[
\hat{H} = h_{\text{nuc}} + \sum\limits_{\substack{p \\ \alpha}} h_{p}^{\alpha} \sigma_p^{\alpha} + \sum\limits_{\substack{p,q \\ \alpha,\beta}} h_{pq}^{\alpha\beta}\sigma_p^{\alpha}\otimes\sigma_{q}^{\beta} + \sum\limits_{\substack{p,q,r \\ \alpha,\beta,\gamma}}h_{pqr}^{\alpha\beta\gamma}\sigma_p^{\alpha}\otimes\sigma_{q}^{\beta}\otimes\sigma_r^{\gamma} + \ldots \nonumber
\]</span></p>
<p>In this expression, the <span class="math inline">\(\sigma_p^\alpha\)</span> are Pauli matrices (<span class="math inline">\(\alpha \in \{x,y,z\}\)</span>), acting on the <span class="math inline">\(p\)</span>-th qubit. We now consider a trial wavefunction ansatz <span class="math inline">\(\vert \Psi(\vec{\theta}) \rangle = U(\vec{\theta}) \vert 0 \rangle\)</span> that depends on <span class="math inline">\(m\)</span> parameters defining <span class="math inline">\(\vec{\theta}=(\theta_1, \theta_2, \ldots, \theta_m)\)</span>, which enter a unitary operator that acts on the reference (i.e., mean-field) state <span class="math inline">\(\vert 0 \rangle\)</span>. The variational principle dictates that we can minimize the expectation value of the Hamiltonian,</p>
<p><span class="math display">\[
E = \min\limits_{\vec{\theta}} \frac{\langle \Psi(\vec{\theta}) \vert \hat{H} \vert \Psi(\vec{\theta}) \rangle}{\langle \Psi(\vec{\theta}) \vert \Psi(\vec{\theta}) \rangle} \geq E_{\text{gs}}\nonumber
\]</span></p>
<p>to determine the optimal set of variational parameters. The energy thus computed will be an upper bound to the true ground-state energy <span class="math inline">\(E_{\text{gs}}\)</span>. Once a suitable variational trial ansatz has been chosen (e.g., a unitary coupled-cluster ansatz, a heuristic ansatz), we must provide a suitable set of initial guess parameters. If our ansatz is defined in the formalism of second-quantization, we must also transform it into the qubit basis before proceeding. We must also apply other approximations (e.g., Trotter–Suzuki) to render it amenable for translation into a quantum circuit. The resulting qubit form of the ansatz can then be translated into a quantum circuit and, thus, able to be implemented on quantum hardware. Once the initial state has been prepared using a quantum circuit, energy measurements are performed using quantum hardware or an appropriate simulation tool. The energy value obtained is the sum of the measurements of the expectation values of each of the terms that contribute to the Hamiltonian (assuming the wavefunction has been normalized to unity):</p>
<p><span class="math display">\[
E = \langle \Psi(\vec{\theta}) \vert \hat{H} \vert \Psi(\vec{\theta}) \rangle =\langle\hat{H}\rangle = h_{\text{nuc}} + \sum_{\substack{p \\ \alpha}} h_{p}^{\alpha} \langle\sigma_p^{\alpha}\rangle + \sum_{\substack{p,q \\ \alpha,\beta}} h_{pq}^{\alpha\beta}\langle\sigma_p^{\alpha}\otimes\sigma_{q}^{\beta}\rangle + \sum_{\substack{p,q,r \\ \alpha,\beta,\gamma}}h_{pqr}^{\alpha\beta\gamma}\langle\sigma_p^{\alpha}\otimes\sigma_{q}^{\beta}\otimes\sigma_r^{\gamma}\rangle + \ldots \nonumber
\]</span></p>
<p>The computed energy is then input to a classical optimizer in order to find a new set of variational parameters, which are then used to prepare a new state (i.e., a quantum circuit) on the quantum hardware. The process is repeated until convergence. The algorithm is illustrated below.</p>
<p><img src="../img/VQE_overview.png" alt="VQE_overview" width="750"></p>
</section>
<section id="vqesolver-class" class="level2">
<h2 class="anchored" data-anchor-id="vqesolver-class">2. VQESolver class<a class="anchor" id="2"></a></h2>
<p>In the following, we will demonstrate various features of the <code>VQESolver</code> class using a simple H2 molecule, defined with the <code>SecondQuantizedMolecule</code> class. This molecule is built below:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo <span class="im">import</span> SecondQuantizedMolecule</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>H2 <span class="op">=</span> [(<span class="st">'H'</span>, (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)),(<span class="st">'H'</span>, (<span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">0.74137727</span>))]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>mol_H2 <span class="op">=</span> SecondQuantizedMolecule(H2, q<span class="op">=</span><span class="dv">0</span>, spin<span class="op">=</span><span class="dv">0</span>, basis<span class="op">=</span><span class="st">"sto-3g"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The <code>VQESolver</code> class implements the VQE electronic structure solver and can be found under the <code>electronic_structure_solver</code> module, along with <code>FCISolver</code> and <code>CCSDSolver</code>, which are classical electronic structure solvers that we will only use here to compare reference results.</p>
<p>In essence, VQE can simply be run using these 3 steps - Instantiate the <code>VQESolver</code> object with the desired options and molecule - Call the <code>build</code> method to construct the objects (e.g.&nbsp;ansatz circuit) required to perform VQE - Call the <code>simulate</code> method to execute the VQE algorithm</p>
<p>In this section, we will go through these 3 steps, and introduce you to other useful functionalities.</p>
<section id="vqesolver-object-instantiation" class="level3">
<h3 class="anchored" data-anchor-id="vqesolver-object-instantiation">VQESolver object instantiation<a class="anchor" id="21"></a></h3>
<p>The <code>VQESolver</code> class can be instantiated by passing a dictionary. Currently, the <strong>molecule</strong> field <strong>must</strong> be provided, and everything else is optional. In the future, this constraint may be relaxed to support different workflows, relying directly on a precomputed qubit operator for example.</p>
<p>In the cell below, we initiate a <code>VQESolver</code> object with this molecule, and display the various attributes of the objects. Notice that some of them have been filled with default values.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.algorithms <span class="im">import</span> VQESolver</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>vqe_options <span class="op">=</span> {<span class="st">"molecule"</span>: mol_H2}</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>vqe_solver <span class="op">=</span> VQESolver(vqe_options)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="bu">vars</span>(vqe_solver)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>{'molecule': SecondQuantizedMolecule(xyz=[('H', (0.0, 0.0, 0.0)), ('H', (0.0, 0.0, 0.74137727))], q=0, spin=0, n_atoms=2, n_electrons=2, n_min_orbitals=8, basis='sto-3g', ecp={}, symmetry=False, mf_energy=-1.1166856303994788, mo_energies=array([-0.5779842,  0.6697221]), mo_occ=array([2., 0.]), mean_field=&lt;pyscf.scf.hf.RHF object at 0x7fa46c643040&gt;, n_mos=2, n_sos=4, active_occupied=[0], frozen_occupied=[], active_virtual=[1], frozen_virtual=[]),
 'qubit_mapping': 'jw',
 'ansatz': &lt;BuiltInAnsatze.UCCSD: 0&gt;,
 'optimizer': &lt;bound method VQESolver._default_optimizer of &lt;tangelo.algorithms.variational.vqe_solver.VQESolver object at 0x7fa46e659910&gt;&gt;,
 'initial_var_params': None,
 'backend_options': {'target': None, 'n_shots': None, 'noise_model': None},
 'penalty_terms': None,
 'deflation_circuits': [],
 'deflation_coeff': 1,
 'ansatz_options': {},
 'up_then_down': False,
 'qubit_hamiltonian': None,
 'verbose': False,
 'ref_state': None,
 'reference_circuit': &lt;tangelo.linq.circuit.Circuit at 0x7fa429202220&gt;,
 'default_backend_options': {'target': None,
  'n_shots': None,
  'noise_model': None},
 'optimal_energy': None,
 'optimal_var_params': None,
 'builtin_ansatze': {&lt;BuiltInAnsatze.HEA: 3&gt;,
  &lt;BuiltInAnsatze.ILC: 9&gt;,
  &lt;BuiltInAnsatze.QCC: 6&gt;,
  &lt;BuiltInAnsatze.QMF: 5&gt;,
  &lt;BuiltInAnsatze.UCC1: 1&gt;,
  &lt;BuiltInAnsatze.UCC3: 2&gt;,
  &lt;BuiltInAnsatze.UCCGD: 8&gt;,
  &lt;BuiltInAnsatze.UCCSD: 0&gt;,
  &lt;BuiltInAnsatze.UpCCGSD: 4&gt;,
  &lt;BuiltInAnsatze.VSQS: 7&gt;}}</code></pre>
</div>
</div>
<p>Our object’s attributes have been populated using the dictionary provided by the user, and default values for the fields that had not been specified in there. Among these attributes, you will see a number of them related to classical optimization, ansatz circuits, qubit mappings or complementary information regarding the molecular system.</p>
<p>The <code>VQESolver</code> class has several methods that are relevant to us, we’ll go through them one by one.</p>
</section>
<section id="vqesolver.build" class="level3">
<h3 class="anchored" data-anchor-id="vqesolver.build">VQESolver.build<a class="anchor" id="22"></a></h3>
<p>This method builds all the internal objects required by VQE, based on the options provided during object instantiation. It will build the mean-field if necessary, the fermionic and qubit hamiltonians corresponding to your molecular system, as well as the ansatz circuit (for default values of variational parameters if none have been provided so far), and the backend performing quantum circuit simulation or execution (a classical simulator or quantum processor).</p>
<p>After we run <code>build</code>, we can see that a number of objects have been built and are now populating the attributes of our <code>VQESolver</code> object.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>vqe_solver.build()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">vars</span>(vqe_solver)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>{'molecule': SecondQuantizedMolecule(xyz=[('H', (0.0, 0.0, 0.0)), ('H', (0.0, 0.0, 0.74137727))], q=0, spin=0, n_atoms=2, n_electrons=2, n_min_orbitals=8, basis='sto-3g', ecp={}, symmetry=False, mf_energy=-1.1166856303994788, mo_energies=array([-0.5779842,  0.6697221]), mo_occ=array([2., 0.]), mean_field=&lt;pyscf.scf.hf.RHF object at 0x7fa46c643040&gt;, n_mos=2, n_sos=4, active_occupied=[0], frozen_occupied=[], active_virtual=[1], frozen_virtual=[]),
 'qubit_mapping': 'jw',
 'ansatz': &lt;tangelo.toolboxes.ansatz_generator.uccsd.UCCSD at 0x7fa42916e760&gt;,
 'optimizer': &lt;bound method VQESolver._default_optimizer of &lt;tangelo.algorithms.variational.vqe_solver.VQESolver object at 0x7fa46e659910&gt;&gt;,
 'initial_var_params': [2e-05, 0.03632416060255425],
 'backend_options': {'target': None, 'n_shots': None, 'noise_model': None},
 'penalty_terms': None,
 'deflation_circuits': [],
 'deflation_coeff': 1,
 'ansatz_options': {},
 'up_then_down': False,
 'qubit_hamiltonian': (-0.09883484730799569+0j) [] +
 (-0.045321883918106265+0j) [X0 X1 Y2 Y3] +
 (0.045321883918106265+0j) [X0 Y1 Y2 X3] +
 (0.045321883918106265+0j) [Y0 X1 X2 Y3] +
 (-0.045321883918106265+0j) [Y0 Y1 X2 X3] +
 (0.17120123806595938+0j) [Z0] +
 (0.16862327595071586+0j) [Z0 Z1] +
 (0.12054612740556847+0j) [Z0 Z2] +
 (0.16586801132367474+0j) [Z0 Z3] +
 (0.1712012380659594+0j) [Z1] +
 (0.16586801132367474+0j) [Z1 Z2] +
 (0.12054612740556847+0j) [Z1 Z3] +
 (-0.22279639651093203+0j) [Z2] +
 (0.17434948757007068+0j) [Z2 Z3] +
 (-0.22279639651093203+0j) [Z3],
 'verbose': False,
 'ref_state': None,
 'reference_circuit': &lt;tangelo.linq.circuit.Circuit at 0x7fa429202220&gt;,
 'default_backend_options': {'target': None,
  'n_shots': None,
  'noise_model': None},
 'optimal_energy': None,
 'optimal_var_params': None,
 'builtin_ansatze': {&lt;BuiltInAnsatze.HEA: 3&gt;,
  &lt;BuiltInAnsatze.ILC: 9&gt;,
  &lt;BuiltInAnsatze.QCC: 6&gt;,
  &lt;BuiltInAnsatze.QMF: 5&gt;,
  &lt;BuiltInAnsatze.UCC1: 1&gt;,
  &lt;BuiltInAnsatze.UCC3: 2&gt;,
  &lt;BuiltInAnsatze.UCCGD: 8&gt;,
  &lt;BuiltInAnsatze.UCCSD: 0&gt;,
  &lt;BuiltInAnsatze.UpCCGSD: 4&gt;,
  &lt;BuiltInAnsatze.VSQS: 7&gt;},
 'backend': &lt;tangelo.linq.simulator.Simulator at 0x7fa42916e7c0&gt;}</code></pre>
</div>
</div>
<p>In particular we notice:</p>
<ul>
<li><strong>qubit Hamiltonian</strong>: the qubit operator used for computing the expectation value in the energy estimation step of VQE</li>
<li><strong>backend</strong> is a <code>Simulator</code> object that was defined in a submodule called <code>linq</code>, allowing us to define how a quantum circuit should be run. Currently, the default option is to run using an exact simulation (no noise) using the <code>qulacs</code> classical simulator.</li>
<li><strong>ansatz</strong>: is now an object that implements the UCCSD ansatz. We go into more details about builtin and custom ansatze in a separate notebook. For now, it is useful to notice that one can peek at the UCCSD quantum circuit that was built, or the value of the variational parameters for this ansatz. This quantum circuit is in the format implemented in <code>linq</code>.</li>
</ul>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Variational parameters: </span><span class="sc">{</span>vqe_solver<span class="sc">.</span>ansatz<span class="sc">.</span>var_params<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(vqe_solver.ansatz.circuit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Variational parameters: [2e-05, 0.03632416060255425]

Circuit object. Size 158 

X         target : [0]   
X         target : [1]   
RX        target : [0]   parameter : 1.5707963267948966
H         target : [2]   
CNOT      target : [1]   control : [0]   
CNOT      target : [2]   control : [1]   
RZ        target : [2]   parameter : 2e-05   (variational)
CNOT      target : [2]   control : [1]   
CNOT      target : [1]   control : [0]   
H         target : [2]   
RX        target : [0]   parameter : -1.5707963267948966
H         target : [0]   
RX        target : [2]   parameter : 1.5707963267948966
CNOT      target : [1]   control : [0]   
CNOT      target : [2]   control : [1]   
RZ        target : [2]   parameter : 12.566350614359173  (variational)
CNOT      target : [2]   control : [1]   
CNOT      target : [1]   control : [0]   
RX        target : [2]   parameter : -1.5707963267948966
H         target : [0]   
RX        target : [1]   parameter : 1.5707963267948966
H         target : [3]   
CNOT      target : [2]   control : [1]   
CNOT      target : [3]   control : [2]   
RZ        target : [3]   parameter : 2e-05   (variational)
CNOT      target : [3]   control : [2]   
CNOT      target : [2]   control : [1]   
H         target : [3]   
RX        target : [1]   parameter : -1.5707963267948966
H         target : [1]   
RX        target : [3]   parameter : 1.5707963267948966
CNOT      target : [2]   control : [1]   
CNOT      target : [3]   control : [2]   
RZ        target : [3]   parameter : 12.566350614359173  (variational)
CNOT      target : [3]   control : [2]   
CNOT      target : [2]   control : [1]   
RX        target : [3]   parameter : -1.5707963267948966
H         target : [1]   
RX        target : [0]   parameter : 1.5707963267948966
RX        target : [1]   parameter : 1.5707963267948966
RX        target : [2]   parameter : 1.5707963267948966
H         target : [3]   
CNOT      target : [1]   control : [0]   
CNOT      target : [2]   control : [1]   
CNOT      target : [3]   control : [2]   
RZ        target : [3]   parameter : 0.018162080301277125    (variational)
CNOT      target : [3]   control : [2]   
CNOT      target : [2]   control : [1]   
CNOT      target : [1]   control : [0]   
H         target : [3]   
RX        target : [2]   parameter : -1.5707963267948966
RX        target : [1]   parameter : -1.5707963267948966
RX        target : [0]   parameter : -1.5707963267948966
RX        target : [0]   parameter : 1.5707963267948966
H         target : [1]   
RX        target : [2]   parameter : 1.5707963267948966
RX        target : [3]   parameter : 1.5707963267948966
CNOT      target : [1]   control : [0]   
CNOT      target : [2]   control : [1]   
CNOT      target : [3]   control : [2]   
RZ        target : [3]   parameter : 12.548208534057895  (variational)
CNOT      target : [3]   control : [2]   
CNOT      target : [2]   control : [1]   
CNOT      target : [1]   control : [0]   
RX        target : [3]   parameter : -1.5707963267948966
RX        target : [2]   parameter : -1.5707963267948966
H         target : [1]   
RX        target : [0]   parameter : -1.5707963267948966
H         target : [0]   
H         target : [1]   
RX        target : [2]   parameter : 1.5707963267948966
H         target : [3]   
CNOT      target : [1]   control : [0]   
CNOT      target : [2]   control : [1]   
CNOT      target : [3]   control : [2]   
RZ        target : [3]   parameter : 12.548208534057895  (variational)
CNOT      target : [3]   control : [2]   
CNOT      target : [2]   control : [1]   
CNOT      target : [1]   control : [0]   
H         target : [3]   
RX        target : [2]   parameter : -1.5707963267948966
H         target : [1]   
H         target : [0]   
H         target : [0]   
RX        target : [1]   parameter : 1.5707963267948966
RX        target : [2]   parameter : 1.5707963267948966
RX        target : [3]   parameter : 1.5707963267948966
CNOT      target : [1]   control : [0]   
CNOT      target : [2]   control : [1]   
CNOT      target : [3]   control : [2]   
RZ        target : [3]   parameter : 12.548208534057895  (variational)
CNOT      target : [3]   control : [2]   
CNOT      target : [2]   control : [1]   
CNOT      target : [1]   control : [0]   
RX        target : [3]   parameter : -1.5707963267948966
RX        target : [2]   parameter : -1.5707963267948966
RX        target : [1]   parameter : -1.5707963267948966
H         target : [0]   
RX        target : [0]   parameter : 1.5707963267948966
H         target : [1]   
H         target : [2]   
H         target : [3]   
CNOT      target : [1]   control : [0]   
CNOT      target : [2]   control : [1]   
CNOT      target : [3]   control : [2]   
RZ        target : [3]   parameter : 0.018162080301277125    (variational)
CNOT      target : [3]   control : [2]   
CNOT      target : [2]   control : [1]   
CNOT      target : [1]   control : [0]   
H         target : [3]   
H         target : [2]   
H         target : [1]   
RX        target : [0]   parameter : -1.5707963267948966
RX        target : [0]   parameter : 1.5707963267948966
RX        target : [1]   parameter : 1.5707963267948966
H         target : [2]   
RX        target : [3]   parameter : 1.5707963267948966
CNOT      target : [1]   control : [0]   
CNOT      target : [2]   control : [1]   
CNOT      target : [3]   control : [2]   
RZ        target : [3]   parameter : 0.018162080301277125    (variational)
CNOT      target : [3]   control : [2]   
CNOT      target : [2]   control : [1]   
CNOT      target : [1]   control : [0]   
RX        target : [3]   parameter : -1.5707963267948966
H         target : [2]   
RX        target : [1]   parameter : -1.5707963267948966
RX        target : [0]   parameter : -1.5707963267948966
H         target : [0]   
RX        target : [1]   parameter : 1.5707963267948966
H         target : [2]   
H         target : [3]   
CNOT      target : [1]   control : [0]   
CNOT      target : [2]   control : [1]   
CNOT      target : [3]   control : [2]   
RZ        target : [3]   parameter : 0.018162080301277125    (variational)
CNOT      target : [3]   control : [2]   
CNOT      target : [2]   control : [1]   
CNOT      target : [1]   control : [0]   
H         target : [3]   
H         target : [2]   
RX        target : [1]   parameter : -1.5707963267948966
H         target : [0]   
H         target : [0]   
H         target : [1]   
H         target : [2]   
RX        target : [3]   parameter : 1.5707963267948966
CNOT      target : [1]   control : [0]   
CNOT      target : [2]   control : [1]   
CNOT      target : [3]   control : [2]   
RZ        target : [3]   parameter : 12.548208534057895  (variational)
CNOT      target : [3]   control : [2]   
CNOT      target : [2]   control : [1]   
CNOT      target : [1]   control : [0]   
RX        target : [3]   parameter : -1.5707963267948966
H         target : [2]   
H         target : [1]   
H         target : [0]   
</code></pre>
</div>
</div>
<blockquote class="blockquote">
<p>:warning: If you are not familiar with the <code>linq</code> submodule, we recommend you check at some point the tutorial covering the basics. You can however keep going through this notebook without issues.</p>
</blockquote>
</section>
<section id="vqe.simulate" class="level3">
<h3 class="anchored" data-anchor-id="vqe.simulate">VQE.simulate<a class="anchor" id="23"></a></h3>
<p>After <code>VQE.build</code> has been run, we now have all the objects needed to run the VQE algorithm, which consists in a classical optimization loop over an energy estimation function. This energy estimation is obtained by computing the expectation value of our qubit Hamiltonian, with regards to the variational ansatz circuit.</p>
<p>The classical loop is driven by the selected optimizer (we’ll see a bit later how you can choose that), as well as the initial variational parameters.</p>
<p>This method returns the optimal energy computed during the optimization process. As a byproduct, the attributes <code>optimal_energy</code> and <code>optimal_var_params</code> of our <code>VQESolver</code> object have been updated. If you have turned on the <code>verbose</code> option, your output will print more information about energy during the optimization process.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>energy_vqe <span class="op">=</span> vqe_solver.simulate()</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Optimal energy: </span><span class="ch">\t</span><span class="ss"> </span><span class="sc">{</span>energy_vqe<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Optimal parameters: </span><span class="ch">\t</span><span class="ss"> </span><span class="sc">{</span>vqe_solver<span class="sc">.</span>optimal_var_params<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Optimal energy:      -1.1372704157729143
Optimal parameters:      [-5.4412497e-05  5.6522190e-02]</code></pre>
</div>
</div>
<p>That’s it, we ran VQE ! We can quickly check whether or not it did well on this system, with the options we picked: let’s compare that to what classical approaches like CCSD or FCI can do. UCCSD captures single and double excitations, and should be exact for a system like H2, assuming the classical optimization of the variational parameters was succesful.</p>
<p>The <code>CCSDSolver</code> and <code>FCISolver</code> objects have a slightly different interface than <code>VQESolver</code> but are very straightforward. As we can see, the energies are in agreement, indicating that VQE did a good job.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.algorithms <span class="im">import</span> FCISolver, CCSDSolver</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>fci_solver <span class="op">=</span> FCISolver(mol_H2)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>energy_fci <span class="op">=</span> fci_solver.simulate()</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>ccsd_solver <span class="op">=</span> CCSDSolver(mol_H2)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>energy_ccsd <span class="op">=</span> ccsd_solver.simulate()</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"FCI energy: </span><span class="ch">\t</span><span class="ss"> </span><span class="sc">{</span>energy_fci<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"CCSD energy: </span><span class="ch">\t</span><span class="ss"> </span><span class="sc">{</span>energy_ccsd<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"VQE energy: </span><span class="ch">\t</span><span class="ss"> </span><span class="sc">{</span>energy_vqe<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>FCI energy:      -1.1372704220924397
CCSD energy:     -1.1372704220914702
VQE energy:      -1.1372704157729143</code></pre>
</div>
</div>
</section>
<section id="vqe.energy_estimation" class="level3">
<h3 class="anchored" data-anchor-id="vqe.energy_estimation">VQE.energy_estimation<a class="anchor" id="24"></a></h3>
<p>The <code>VQE.energy_estimation</code> is a convenient method that allows you to run a single energy estimation, for some given variational parameters.</p>
<p>This would allow you to compare maybe different (initial?) variational parameters, or could be used to rebuild the underlying ansatz circuit for specific values of the variational parameters, without involving the classical optimization.</p>
<p>The UCCSD ansatz supports a few “shortcut” keywords for some parameters, such as “MP2”, “ones” or “random” (don’t hesitate to explore the <code>ansatz</code> attribute of your <code>VQESolver</code> object, in particular the <code>n_var_params</code> value). We can compare the energy they return: we see below that the mp2 parameters are a much better pick as initial parameters, but not as good as the optimal ones found by <code>simulate</code> earlier.</p>
<p>Since this method builds the ansatz circuit for the input parameter, you can then grab the corresponding circuit. If you know the optimal parameters (from maybe a previous call to <code>simulate</code>), you can then grab the optimal circuit. Check out the <code>linq</code> tutorials to get an idea of how you could explore, export and send this circuit to a collaborator or a compute backend !</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare energies associated to different variational parameters</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>energy <span class="op">=</span> vqe_solver.energy_estimation(<span class="st">"ones"</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>energy<span class="sc">:.7f}</span><span class="ss"> (params = </span><span class="sc">{</span>vqe_solver<span class="sc">.</span>ansatz<span class="sc">.</span>var_params<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>energy <span class="op">=</span> vqe_solver.energy_estimation(<span class="st">"MP2"</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>energy<span class="sc">:.7f}</span><span class="ss"> (params = </span><span class="sc">{</span>vqe_solver<span class="sc">.</span>ansatz<span class="sc">.</span>var_params<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>energy <span class="op">=</span> vqe_solver.energy_estimation(vqe_solver.optimal_var_params)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>energy<span class="sc">:.7f}</span><span class="ss"> (params = </span><span class="sc">{</span>vqe_solver<span class="sc">.</span>ansatz<span class="sc">.</span>var_params<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co"># You can retrieve the circuit corresponding to the last parameters you have used</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>optimal_circuit <span class="op">=</span> vqe_solver.ansatz.circuit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>-0.3369215 (params = [1. 1.])
-1.1346304 (params = [2e-05, 0.03632416060255425])
-1.1372704 (params = [-5.4412497e-05  5.6522190e-02])</code></pre>
</div>
</div>
</section>
<section id="vqe.get_resources" class="level3">
<h3 class="anchored" data-anchor-id="vqe.get_resources">VQE.get_resources<a class="anchor" id="25"></a></h3>
<p>What we can or can’t simulate on backends today (may they be classical simulators or QPUs) is essentially driven by resource requirements. Metrics that correlate to the number of qubits, gates or measurements an algorithm would require to be performed accurately tell a lot about its feasibility on NISQ hardware, and can be used to compare different approaches, without having to actually do any simulation.</p>
<p>This method is able to grab the relevant information for our <code>VQESolver</code> by peeking into the underlying ansatz and qubit Hamiltonian objects. The information you receive is tied to the options you picked for VQE, and may not be true for all sets of variational parameters, depending on how the ansatz circuit is built, and potential optimizations done in the future to the circuit. We also return the number of variational parameters in VQE, as the difficulty of classical optimization plays an important role in the success of the algorithm.</p>
<p>More features for estimating the number of measurements to run an experiment with a given accuracy are on our roadmap.</p>
<p>Here’s what our current example returns:</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>resources <span class="op">=</span> vqe_solver.get_resources()</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(resources)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>{'qubit_hamiltonian_terms': 15, 'circuit_width': 4, 'circuit_gates': 158, 'circuit_2qubit_gates': 64, 'circuit_var_gates': 12, 'vqe_variational_parameters': 2}</code></pre>
</div>
</div>
</section>
<section id="vqe.get_rdm" class="level3">
<h3 class="anchored" data-anchor-id="vqe.get_rdm">VQE.get_rdm<a class="anchor" id="26"></a></h3>
<p>The <code>get_rdm</code> method enables us to compute the one- and two-electron Reduced Density Matrices (RDM) using the ansatz circuit previously built by <code>VQESolver</code>, for some input variational parameters. This can come in handy, and is in particular used by the DMET problem decomposition technique, further detailed in another notebook.</p>
<p>Below, we compute these RDMs using the optimal variational parameters found by a previous call to <code>simulate</code>, and only print the one-electron RDM.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>onerdm, twordm <span class="op">=</span> vqe_solver.get_rdm(vqe_solver.optimal_var_params)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(onerdm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1.97455062+0.j 0.        +0.j]
 [0.        +0.j 0.02544938+0.j]]</code></pre>
</div>
</div>
</section>
</section>
<section id="option-frozen-orbitals" class="level2">
<h2 class="anchored" data-anchor-id="option-frozen-orbitals">3. Option: frozen orbitals<a class="anchor" id="3"></a></h2>
<p>The <code>VQESolver</code> class supports a <code>frozen_orbitals</code> option, allowing a user to pass either a list of indices (integers) referring to the orbitals to freeze, or a single integer indicating that all orbitals up to that index (excluded) must be frozen. For instance, just passing <code>3</code> would be equivalent to passing <code>[0, 1, 2]</code>.</p>
<p>Internally, this information is parsed and allows us to track which orbitals are active or frozen and occupied or virtual, through an object carrying molecular data which is an attribute of the <code>VQESolver</code>. By default, the option “frozen_core” is selected. If this string is detected, the function <code>tangelo.toolboxes.molecular_computation.frozen_orbitals.get_frozen_core</code> is called. It takes a <code>Molecule</code> or a <code>SecondQuantizedMolecule</code> object and returns an integer corresponding to the number of low-energy orbitals. In short, no orbital for each period 1 element, one orbital for each period 2 element and five orbitals for each period 3 element are summed up and frozen in the subsequent calculation. It is important to emphasize that this option does nothing if a custom qubit Hamiltonian is provided instead of a molecule.</p>
<p>Let’s have a look at this quickly, taking a H4 molecule in sto-3g basis as an example. We can compare the results provided by VQE to our classical CCSD solver, which also support frozen orbitals with a slightly different interface.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>H4 <span class="op">=</span> [[<span class="st">"H"</span>, [<span class="fl">0.7071067811865476</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>]], [<span class="st">"H"</span>, [<span class="fl">0.0</span>, <span class="fl">0.7071067811865476</span>, <span class="fl">0.0</span>]],</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>      [<span class="st">"H"</span>, [<span class="op">-</span><span class="fl">1.0071067811865476</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>]], [<span class="st">"H"</span>, [<span class="fl">0.0</span>, <span class="op">-</span><span class="fl">1.0071067811865476</span>, <span class="fl">0.0</span>]]]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>mol_H4 <span class="op">=</span> SecondQuantizedMolecule(H4, q<span class="op">=</span><span class="dv">0</span>, spin<span class="op">=</span><span class="dv">0</span>, basis<span class="op">=</span><span class="st">"sto-3g"</span>, frozen_orbitals<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">3</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>vqe_options <span class="op">=</span> {<span class="st">"molecule"</span>: mol_H4}</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>vqe_solver_h4_frozen <span class="op">=</span> VQESolver(vqe_options)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>vqe_solver_h4_frozen.build()</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>energy_vqe_h4_frozen <span class="op">=</span> vqe_solver_h4_frozen.simulate()</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"VQE energy: </span><span class="ch">\t</span><span class="ss"> </span><span class="sc">{</span>energy_vqe_h4_frozen<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>ccsd_solver <span class="op">=</span> CCSDSolver(mol_H4)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>energy_ccsd_h4_frozen <span class="op">=</span> ccsd_solver.simulate()</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"CCSD energy: </span><span class="ch">\t</span><span class="ss"> </span><span class="sc">{</span>energy_ccsd_h4_frozen<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>, vqe_solver_h4_frozen.get_resources())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>VQE energy:      -1.8943598012228877
CCSD energy:     -1.894360237665742

 {'qubit_hamiltonian_terms': 15, 'circuit_width': 4, 'circuit_gates': 158, 'circuit_2qubit_gates': 64, 'circuit_var_gates': 12, 'vqe_variational_parameters': 2}</code></pre>
</div>
</div>
<p>Frozen orbitals offer a trade-off between resource requirements and accuracy. By freezing orbitals that seem not to contribute significantly to the computation, we may drastically reduce resource requirements. In this example, we sacrificed a noticeable amount of accuracy but also drastically reduced resource requirements and ended up with a formulation that was much easier to solve. Notice how <code>simulate</code> takes longer to execute here, and compare both energies and resource requirements to the previous cell.</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>mol_H4 <span class="op">=</span> SecondQuantizedMolecule(H4, q<span class="op">=</span><span class="dv">0</span>, spin<span class="op">=</span><span class="dv">0</span>, basis<span class="op">=</span><span class="st">"sto-3g"</span>, frozen_orbitals<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>vqe_options <span class="op">=</span> {<span class="st">"molecule"</span>: mol_H4}</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>vqe_solver_h4 <span class="op">=</span> VQESolver(vqe_options)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>vqe_solver_h4.build()</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>energy_vqe_h4 <span class="op">=</span> vqe_solver_h4.simulate()</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"VQE energy: </span><span class="ch">\t</span><span class="ss"> </span><span class="sc">{</span>energy_vqe_h4<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>, vqe_solver_h4.get_resources())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>VQE energy:      -1.9778372805046642

 {'qubit_hamiltonian_terms': 185, 'circuit_width': 8, 'circuit_gates': 2692, 'circuit_2qubit_gates': 1312, 'circuit_var_gates': 160, 'vqe_variational_parameters': 14}</code></pre>
</div>
</div>
</section>
<section id="option-ansatz-and-qubit-mapping" class="level2">
<h2 class="anchored" data-anchor-id="option-ansatz-and-qubit-mapping">4. Option: ansatz and qubit mapping<a class="anchor" id="4"></a></h2>
<p>VQE relies on a qubit mapping in order to encode the fermionic-Hamiltonian into a spin-Hamiltonian which can be expressed natively on quantum hardware. This enables us to represent the occupation of fermionic orbital basis states in terms of the internal state of a collection of qubits. Meanwhile, the ansatz drives what portion of the Hilbert space can be explored by VQE, as we change the values of the variational parameters.</p>
<p>We can choose from a number of built-in ansatze (UCCSD, UCC1, UCC3…) and qubit mappings (Jordan-Wigner, Bravyi-Kitaev, symmetry-conserving Bravyi-Kitaev). In the previous examples, the default options for these two entities were selected. You may have noticed that the qubit mapping was Jordan-Wigner (<code>'jw'</code>), and the ansatz was UCCSD (<code>Ansatze.UCCSD</code>).</p>
<p>The choice of qubit mapping and ansatz impacts resource requirements but also accuracy. Designing “shallow” ansatze with low resource requirements that yield accurate results is an active topic of research.</p>
<p>Below, we show how the qubit mapping impacts our example on H2 using the UCCSD ansatz. Notice the difference in resource requirements, classical optimization, and the difference in accuracy.</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.algorithms <span class="im">import</span> BuiltInAnsatze <span class="im">as</span> Ansatze</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co"># VQE-UCCSD on H2 with different qubit mappings</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> qm <span class="kw">in</span> [<span class="st">'jw'</span>, <span class="st">'bk'</span>, <span class="st">'scbk'</span>]:</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    vqe_options <span class="op">=</span> {<span class="st">"molecule"</span>: mol_H2, <span class="st">"ansatz"</span>: Ansatze.UCCSD, <span class="st">"qubit_mapping"</span>: qm}</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    vqe_solver <span class="op">=</span> VQESolver(vqe_options)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    vqe_solver.build()</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    vqe_solver.simulate()</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>, vqe_solver.get_resources(), <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
 {'qubit_hamiltonian_terms': 15, 'circuit_width': 4, 'circuit_gates': 158, 'circuit_2qubit_gates': 64, 'circuit_var_gates': 12, 'vqe_variational_parameters': 2} 


 {'qubit_hamiltonian_terms': 15, 'circuit_width': 4, 'circuit_gates': 107, 'circuit_2qubit_gates': 46, 'circuit_var_gates': 12, 'vqe_variational_parameters': 2} 


 {'qubit_hamiltonian_terms': 5, 'circuit_width': 2, 'circuit_gates': 22, 'circuit_2qubit_gates': 4, 'circuit_var_gates': 4, 'vqe_variational_parameters': 2} 
</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/home/alex/Codes/Tangelo/tangelo/toolboxes/qubit_mappings/statevector_mapping.py:149: RuntimeWarning: Symmetry-conserving Bravyi-Kitaev enforces all spin-up followed by all spin-down ordering.
  warnings.warn("Symmetry-conserving Bravyi-Kitaev enforces all spin-up followed by all spin-down ordering.", RuntimeWarning)</code></pre>
</div>
</div>
<blockquote class="blockquote">
<p>:warning: Each ansatz works differently, or may not be compatible with all qubit mappings. We encourage you to check out the documentation. In particular, how the <code>Ansatz</code> class work and how to implement your own custom ansatz into VQE is covered in a separate notebook <a href="../../examples/variational_methods/vqe_custom_ansatz_hamiltonian.html"><code>vqe_custom_ansatz_hamiltonian.ipynb</code></a>.</p>
</blockquote>
<p>We can also try using the restricted UCC ansatze UCC1 and UCC3 to solve this problem:</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># VQE-UCCSD on H2 with ansatze UCC1 and UCC3</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> az <span class="kw">in</span> [Ansatze.UCC1, Ansatze.UCC3]:</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    vqe_options <span class="op">=</span> {<span class="st">"molecule"</span>: mol_H2, <span class="st">"ansatz"</span>: az, <span class="st">"up_then_down"</span>: <span class="va">True</span>}</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    vqe_solver <span class="op">=</span> VQESolver(vqe_options)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    vqe_solver.build()</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    vqe_solver.simulate()</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>, vqe_solver.get_resources(), <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
 {'qubit_hamiltonian_terms': 15, 'circuit_width': 4, 'circuit_gates': 17, 'circuit_2qubit_gates': 6, 'circuit_var_gates': 1, 'vqe_variational_parameters': 1} 


 {'qubit_hamiltonian_terms': 15, 'circuit_width': 4, 'circuit_gates': 23, 'circuit_2qubit_gates': 8, 'circuit_var_gates': 3, 'vqe_variational_parameters': 3} 
</code></pre>
</div>
</div>
</section>
<section id="option-classical-optimization" class="level2">
<h2 class="anchored" data-anchor-id="option-classical-optimization">5. Option: classical optimization<a class="anchor" id="5"></a></h2>
<p>You also have full control over the classical optimization strategy you wish to follow. Earlier, we showed how the <code>initial_var_params</code> attribute of the <code>VQESolver</code> class could be used in different ways: check out the implementation of your <code>ansatz</code> object to see what is supported.</p>
<p>Users can also provide their own optimizer, which will be called in <code>VQESolver.simulate</code> and be passed a handle to the <code>VQESolver.energy_estimation</code> function and the initial variational parameters. Below, we decide to use the COBYLA optimizer from scipy:</p>
<p>It is required that both the resulting function value and resulting parameters (<code>result.fun</code> and <code>result.x</code> respectively for the example below) are returns for the user defined function. This allows easy access after optimization to the optimal energy from <code>vqe_solver.optimal_energy</code>, and optimal parameters from <code>vqe_solver.optimal_var_params</code>.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cobyla_optimizer(func, var_params):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> scipy.optimize <span class="im">import</span> minimize</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> minimize(func, var_params, method<span class="op">=</span><span class="st">"COBYLA"</span>, options<span class="op">=</span>{<span class="st">"disp"</span>: <span class="va">True</span>, <span class="st">"maxiter"</span>: <span class="dv">100</span>, <span class="st">'rhobeg'</span>:<span class="fl">0.1</span>})</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\t</span><span class="ss">Optimal UCCSD energy: </span><span class="sc">{</span>result<span class="sc">.</span>fun<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\t</span><span class="ss">Optimal UCCSD variational parameters: </span><span class="sc">{</span>result<span class="sc">.</span>x<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\t</span><span class="ss">Number of Function Evaluations : </span><span class="sc">{</span>result<span class="sc">.</span>nfev<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result.fun, result.x</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Use "optimizer" and "initial_var_params" to customize your classical optimization</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>vqe_options <span class="op">=</span> {<span class="st">"molecule"</span>: mol_H2, <span class="st">"optimizer"</span>: cobyla_optimizer, <span class="st">"initial_var_params"</span>: [<span class="fl">1.</span>, <span class="fl">2.</span>]}</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>vqe_solver <span class="op">=</span> VQESolver(vqe_options)</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>vqe_solver.build()</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>optimal_energy <span class="op">=</span> vqe_solver.simulate()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    Optimal UCCSD energy: -1.1372704174429256
   Normal return from subroutine COBYLA

   NFVALS =   36   F =-1.137270E+00    MAXCV = 0.000000E+00
   X = 1.570763E+00   2.412707E+00

    Optimal UCCSD variational parameters: [1.57076299 2.41270658]
    Number of Function Evaluations : 36</code></pre>
</div>
</div>
</section>
<section id="option-compute-backend" class="level2">
<h2 class="anchored" data-anchor-id="option-compute-backend">6. Option: compute backend<a class="anchor" id="6"></a></h2>
<p>The <code>VQESolver</code> class relies on the <code>linq</code> submodule in order to simulate your quantum circuits.</p>
<p>For more information about the <code>backend</code> attribute of your <code>VQE_Solver</code> object, of type <code>tangelo.linq.Simulator</code>, we recommend you check the <code>linq</code> tutorial notebooks.</p>
<p>This object allows you to pick from a number of different classical simulators, with significantly different performance, some supporting noisy simulation. The parameters <code>n_shots</code> introduces statistical noise in the computation, which correlates to accuracy of energy estimation, while <code>noise_model</code> enables us to model noise in the circuit to an extent. These parameters are provided to enable the modeling of experiments that may be closer to the behaviour of quantum hardware.</p>
<p>Below, we specify that we’d like our <code>VQESolver</code> to use the simulator from the <code>cirq</code> Python package as a backend, and leave the two other parameters to <code>None</code> to signify that we want the simulation to be exact.</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>my_backend_options <span class="op">=</span> {<span class="st">"target"</span>: <span class="st">"cirq"</span>, <span class="st">"n_shots"</span>: <span class="va">None</span>, <span class="st">"noise_model"</span>: <span class="va">None</span>}</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>vqe_options <span class="op">=</span> {<span class="st">"molecule"</span>: mol_H2, <span class="st">"backend_options"</span>: my_backend_options, <span class="st">"verbose"</span>: <span class="va">True</span>}</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>vqe_solver <span class="op">=</span> VQESolver(vqe_options)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>vqe_solver.build()</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> term, coef <span class="kw">in</span> vqe_solver.qubit_hamiltonian.terms.items():</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    vqe_solver.qubit_hamiltonian.terms[term] <span class="op">=</span> coef.real</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>vqe_solver.simulate()</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>opt_energy <span class="op">=</span> vqe_solver.optimal_energy</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>opt_params <span class="op">=</span> vqe_solver.optimal_var_params</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>VQESolver optimization results:
    Optimal VQE energy: -1.1372704157729134
    Optimal VQE variational parameters: [-5.44125627e-05  5.65221900e-02]
    Number of Iterations : 3
    Number of Function Evaluations : 10
    Number of Gradient Evaluations : 3</code></pre>
</div>
</div>
<p>Running VQE on a noisy backend is a challenge in itself, and it is hard to predict what will be the behavior on the algorithm when the output is based on drawing shots (samples), which reflects the probabilistic nature of a quantum processor.</p>
<p>What optimizer should be used for a noisy function? How does it correlate with the number of shots (samples) we need to gather for each energy estimation ? Is there any hope for VQE to be useful on a quantum computer ? All of these are open questions.</p>
<p>Below, we illustrate how one can see that the amount of shots (samples) taken for energy estimation leads to better accuracy:</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>my_backend_options <span class="op">=</span> {<span class="st">"target"</span>: <span class="st">"qulacs"</span>, <span class="st">"n_shots"</span>: <span class="dv">1</span>, <span class="st">"noise_model"</span>: <span class="va">None</span>}</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>vqe_options <span class="op">=</span> {<span class="st">"molecule"</span>: mol_H2, <span class="st">"backend_options"</span>: my_backend_options}</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>vqe_solver <span class="op">=</span> VQESolver(vqe_options)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>vqe_solver.build()</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n_shots <span class="kw">in</span> [<span class="dv">10</span><span class="op">**</span><span class="dv">2</span>, <span class="dv">10</span><span class="op">**</span><span class="dv">4</span>, <span class="dv">10</span><span class="op">**</span><span class="dv">6</span>]:</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    vqe_solver.backend.n_shots <span class="op">=</span> n_shots</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    energy <span class="op">=</span> vqe_solver.energy_estimation(opt_params)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Energy estimation with </span><span class="sc">{</span>n_shots<span class="sc">:.1E}</span><span class="ss"> shots = </span><span class="sc">{</span>energy<span class="sc">}</span><span class="ss"> </span><span class="ch">\t</span><span class="ss">(Error: </span><span class="sc">{</span><span class="bu">abs</span>(energy <span class="op">-</span> opt_energy)<span class="sc">:.2E}</span><span class="ss">)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Energy estimation with 1.0E+02 shots = -1.1335574814374392  (Error: 3.71E-03)
Energy estimation with 1.0E+04 shots = -1.1358696314459025  (Error: 1.40E-03)
Energy estimation with 1.0E+06 shots = -1.1372051734252862  (Error: 6.52E-05)</code></pre>
</div>
</div>
</section>
<section id="closing-words" class="level2">
<h2 class="anchored" data-anchor-id="closing-words">Closing words</h2>
<p>This concludes our overview of <code>VQESolver</code>. Due to the complexity of the topic, we did not explore in details some of the underlying objects it relies on, such as the ansatz object and the backend object.</p>
<p>For a more in-depth discussion on these objects, please refer to the documentation and check out the other notebooks we have in this folder, or maybe the <code>linq</code> notebooks.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>