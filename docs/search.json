[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Welcome !\nThis website contains the jupyter notebooks for Tangelo. This includes tutorial notebooks and research-related notebooks. Anyone can contribute a notebook to the repository!\nIf you are new to Tangelo, we suggest you start with 1. The basics, and Quantum Chemistry Basics. After that, what you are most interested in determines where you go next !\nThere are multiple ways to run and play with these notebooks: through Binder, Google Colab, a local install (…).\nAn overview of the many notebooks so far (there may be more, including example scripts as well):\n\nWorkflow Basics\n\n1. The basics\n2. QPU Connection\n3. Noisy Simulation\nSymbolic Simulation\n\nChemistry\n\nQuantum Chemistry Basics\nExcited State methods\n\nVariational Methods\n\nVQE\nVQE with user defined ansatz\nAdapt VQE Solver\nIterative Qubit Coupled Cluster using only Clifford Circuits\n\nMeasurement Reduction\n\nClassical Shadows\n\nProblem Decomposition\n\nDensity Matrix Embedding Theory\nDMET Unrestricted Hartree-Fock\nMIFNO\nONIOM\n\nHardware Experiments\n\nEnd-to-End hardware experiment\nHardware Experiment using QEMIST Cloud\nBerylium IBM quantum experiment\nUmbrella inversion Braket\n\nFault Tolerant\n\nState Preparation using Quantum Signal Processing"
  },
  {
    "objectID": "examples/variational_methods/vqe.html",
    "href": "examples/variational_methods/vqe.html",
    "title": "VQE with Tangelo",
    "section": "",
    "text": "Open In Colab\nTangelo provides various toolboxes, which can be leveraged to build quantum chemistry workflows relying on quantum computing. One example of such a workflow is the Variational Quantum Eigensolver (VQE). We provide an implementation of VQE that supports several options, and may provide valuable help in your research and applications.\nThis notebook assumes that you already have installed Tangelo in your Python environment, or have updated your Python path so that the imports can be resolved. If not, executing the cell below installs the minimal requirements for this notebook.\n# Installation of tangelo if not already installed.\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet\n\n# Installation of qulacs if not already installed.\ntry:\n    import qulacs\nexcept ModuleNotFoundError:\n    !pip install qulacs --quiet"
  },
  {
    "objectID": "examples/variational_methods/vqe.html#table-of-contents",
    "href": "examples/variational_methods/vqe.html#table-of-contents",
    "title": "VQE with Tangelo",
    "section": "Table of contents:",
    "text": "Table of contents:\n\n1. Overview of VQE\n2. VQESolver class\n\n2.1 VQESolver instantiation\n2.2 VQESolver.build\n2.3 VQESolver.simulate\n2.4 VQESolver.energy_estimation\n2.5 VQESolver.get_resources\n2.6 VQESolver.get_rdm\n\n3. Option: frozen orbitals\n4. Option: ansatz and qubit mapping\n5. Option: classical optimizers and initial parameters\n6. Option: compute backend"
  },
  {
    "objectID": "examples/variational_methods/vqe.html#overview-of-vqe",
    "href": "examples/variational_methods/vqe.html#overview-of-vqe",
    "title": "VQE with Tangelo",
    "section": "1. Overview of VQE ",
    "text": "1. Overview of VQE \nThe Variational Quantum Eigensolver (VQE) [Peruzzo_et_al.,_2014, McClean_et_al.,_2015] has been introduced as a hybrid quantum–classical algorithm for simulating quantum systems. Some examples of quantum simulation using VQE include solving the molecular electronic Schrödinger equation and model systems in condensed matter physics (e.g., Fermi– and Bose–Hubbard models). In this notebook, we focus on VQE within the context of solving the molecular electronic structure problem for the ground-state energy of a molecular system. The second-quantized Hamiltonian of such a system, within the Born-Oppenheimer approximation, assumes the following form:\n\\[\n\\hat{H} = h_{\\text{nuc}} + \\sum\\limits_{p,q} h^{p}_{q} a^{\\dagger}_p a_q + \\sum\\limits_{p,q,r,s} h^{pq}_{rs} a^{\\dagger}_p a^{\\dagger}_q a_s a_r\\nonumber\n\\]\nHere, \\(h_{\\text{nuc}}\\) denotes the nuclear repulsion energy. In what follows below, we use the mean-field solution from Hartee-Fock (HF) self-consistent theory as our computational starting point. As such, the basis-orbitals and coefficients \\(h_p^q\\), \\(h_{rs}^{pq}\\), are evaluated in the basis of molecular orbitals from HF. The Hamiltonian is then transformed into the qubit basis (e.g., Jordan–Wigner, Bravyi–Kitaev). This means that it is expressed entirely in terms of operators acting on qubits:\n\\[\n\\hat{H} = h_{\\text{nuc}} + \\sum\\limits_{\\substack{p \\\\ \\alpha}} h_{p}^{\\alpha} \\sigma_p^{\\alpha} + \\sum\\limits_{\\substack{p,q \\\\ \\alpha,\\beta}} h_{pq}^{\\alpha\\beta}\\sigma_p^{\\alpha}\\otimes\\sigma_{q}^{\\beta} + \\sum\\limits_{\\substack{p,q,r \\\\ \\alpha,\\beta,\\gamma}}h_{pqr}^{\\alpha\\beta\\gamma}\\sigma_p^{\\alpha}\\otimes\\sigma_{q}^{\\beta}\\otimes\\sigma_r^{\\gamma} + \\ldots \\nonumber\n\\]\nIn this expression, the \\(\\sigma_p^\\alpha\\) are Pauli matrices (\\(\\alpha \\in \\{x,y,z\\}\\)), acting on the \\(p\\)-th qubit. We now consider a trial wavefunction ansatz \\(\\vert \\Psi(\\vec{\\theta}) \\rangle = U(\\vec{\\theta}) \\vert 0 \\rangle\\) that depends on \\(m\\) parameters defining \\(\\vec{\\theta}=(\\theta_1, \\theta_2, \\ldots, \\theta_m)\\), which enter a unitary operator that acts on the reference (i.e., mean-field) state \\(\\vert 0 \\rangle\\). The variational principle dictates that we can minimize the expectation value of the Hamiltonian,\n\\[\nE = \\min\\limits_{\\vec{\\theta}} \\frac{\\langle \\Psi(\\vec{\\theta}) \\vert \\hat{H} \\vert \\Psi(\\vec{\\theta}) \\rangle}{\\langle \\Psi(\\vec{\\theta}) \\vert \\Psi(\\vec{\\theta}) \\rangle} \\geq E_{\\text{gs}}\\nonumber\n\\]\nto determine the optimal set of variational parameters. The energy thus computed will be an upper bound to the true ground-state energy \\(E_{\\text{gs}}\\). Once a suitable variational trial ansatz has been chosen (e.g., a unitary coupled-cluster ansatz, a heuristic ansatz), we must provide a suitable set of initial guess parameters. If our ansatz is defined in the formalism of second-quantization, we must also transform it into the qubit basis before proceeding. We must also apply other approximations (e.g., Trotter–Suzuki) to render it amenable for translation into a quantum circuit. The resulting qubit form of the ansatz can then be translated into a quantum circuit and, thus, able to be implemented on quantum hardware. Once the initial state has been prepared using a quantum circuit, energy measurements are performed using quantum hardware or an appropriate simulation tool. The energy value obtained is the sum of the measurements of the expectation values of each of the terms that contribute to the Hamiltonian (assuming the wavefunction has been normalized to unity):\n\\[\nE = \\langle \\Psi(\\vec{\\theta}) \\vert \\hat{H} \\vert \\Psi(\\vec{\\theta}) \\rangle =\\langle\\hat{H}\\rangle = h_{\\text{nuc}} + \\sum_{\\substack{p \\\\ \\alpha}} h_{p}^{\\alpha} \\langle\\sigma_p^{\\alpha}\\rangle + \\sum_{\\substack{p,q \\\\ \\alpha,\\beta}} h_{pq}^{\\alpha\\beta}\\langle\\sigma_p^{\\alpha}\\otimes\\sigma_{q}^{\\beta}\\rangle + \\sum_{\\substack{p,q,r \\\\ \\alpha,\\beta,\\gamma}}h_{pqr}^{\\alpha\\beta\\gamma}\\langle\\sigma_p^{\\alpha}\\otimes\\sigma_{q}^{\\beta}\\otimes\\sigma_r^{\\gamma}\\rangle + \\ldots \\nonumber\n\\]\nThe computed energy is then input to a classical optimizer in order to find a new set of variational parameters, which are then used to prepare a new state (i.e., a quantum circuit) on the quantum hardware. The process is repeated until convergence. The algorithm is illustrated below."
  },
  {
    "objectID": "examples/variational_methods/vqe.html#vqesolver-class",
    "href": "examples/variational_methods/vqe.html#vqesolver-class",
    "title": "VQE with Tangelo",
    "section": "2. VQESolver class",
    "text": "2. VQESolver class\nIn the following, we will demonstrate various features of the VQESolver class using a simple H2 molecule, defined with the SecondQuantizedMolecule class. This molecule is built below:\n\nfrom tangelo import SecondQuantizedMolecule\n\nH2 = [('H', (0, 0, 0)),('H', (0, 0, 0.74137727))]\nmol_H2 = SecondQuantizedMolecule(H2, q=0, spin=0, basis=\"sto-3g\")\n\nThe VQESolver class implements the VQE electronic structure solver and can be found under the electronic_structure_solver module, along with FCISolver and CCSDSolver, which are classical electronic structure solvers that we will only use here to compare reference results.\nIn essence, VQE can simply be run using these 3 steps - Instantiate the VQESolver object with the desired options and molecule - Call the build method to construct the objects (e.g. ansatz circuit) required to perform VQE - Call the simulate method to execute the VQE algorithm\nIn this section, we will go through these 3 steps, and introduce you to other useful functionalities.\n\nVQESolver object instantiation\nThe VQESolver class can be instantiated by passing a dictionary. Currently, the molecule field must be provided, and everything else is optional. In the future, this constraint may be relaxed to support different workflows, relying directly on a precomputed qubit operator for example.\nIn the cell below, we initiate a VQESolver object with this molecule, and display the various attributes of the objects. Notice that some of them have been filled with default values.\n\nfrom tangelo.algorithms import VQESolver\n\nvqe_options = {\"molecule\": mol_H2}\nvqe_solver = VQESolver(vqe_options)\nvars(vqe_solver)\n\n{'molecule': SecondQuantizedMolecule(xyz=[('H', (0.0, 0.0, 0.0)), ('H', (0.0, 0.0, 0.74137727))], q=0, spin=0, n_atoms=2, n_electrons=2, n_min_orbitals=8, basis='sto-3g', ecp={}, symmetry=False, mf_energy=-1.1166856303994788, mo_energies=array([-0.5779842,  0.6697221]), mo_occ=array([2., 0.]), mean_field=&lt;pyscf.scf.hf.RHF object at 0x7fa46c643040&gt;, n_mos=2, n_sos=4, active_occupied=[0], frozen_occupied=[], active_virtual=[1], frozen_virtual=[]),\n 'qubit_mapping': 'jw',\n 'ansatz': &lt;BuiltInAnsatze.UCCSD: 0&gt;,\n 'optimizer': &lt;bound method VQESolver._default_optimizer of &lt;tangelo.algorithms.variational.vqe_solver.VQESolver object at 0x7fa46e659910&gt;&gt;,\n 'initial_var_params': None,\n 'backend_options': {'target': None, 'n_shots': None, 'noise_model': None},\n 'penalty_terms': None,\n 'deflation_circuits': [],\n 'deflation_coeff': 1,\n 'ansatz_options': {},\n 'up_then_down': False,\n 'qubit_hamiltonian': None,\n 'verbose': False,\n 'ref_state': None,\n 'reference_circuit': &lt;tangelo.linq.circuit.Circuit at 0x7fa429202220&gt;,\n 'default_backend_options': {'target': None,\n  'n_shots': None,\n  'noise_model': None},\n 'optimal_energy': None,\n 'optimal_var_params': None,\n 'builtin_ansatze': {&lt;BuiltInAnsatze.HEA: 3&gt;,\n  &lt;BuiltInAnsatze.ILC: 9&gt;,\n  &lt;BuiltInAnsatze.QCC: 6&gt;,\n  &lt;BuiltInAnsatze.QMF: 5&gt;,\n  &lt;BuiltInAnsatze.UCC1: 1&gt;,\n  &lt;BuiltInAnsatze.UCC3: 2&gt;,\n  &lt;BuiltInAnsatze.UCCGD: 8&gt;,\n  &lt;BuiltInAnsatze.UCCSD: 0&gt;,\n  &lt;BuiltInAnsatze.UpCCGSD: 4&gt;,\n  &lt;BuiltInAnsatze.VSQS: 7&gt;}}\n\n\nOur object’s attributes have been populated using the dictionary provided by the user, and default values for the fields that had not been specified in there. Among these attributes, you will see a number of them related to classical optimization, ansatz circuits, qubit mappings or complementary information regarding the molecular system.\nThe VQESolver class has several methods that are relevant to us, we’ll go through them one by one.\n\n\nVQESolver.build\nThis method builds all the internal objects required by VQE, based on the options provided during object instantiation. It will build the mean-field if necessary, the fermionic and qubit hamiltonians corresponding to your molecular system, as well as the ansatz circuit (for default values of variational parameters if none have been provided so far), and the backend performing quantum circuit simulation or execution (a classical simulator or quantum processor).\nAfter we run build, we can see that a number of objects have been built and are now populating the attributes of our VQESolver object.\n\nvqe_solver.build()\nvars(vqe_solver)\n\n{'molecule': SecondQuantizedMolecule(xyz=[('H', (0.0, 0.0, 0.0)), ('H', (0.0, 0.0, 0.74137727))], q=0, spin=0, n_atoms=2, n_electrons=2, n_min_orbitals=8, basis='sto-3g', ecp={}, symmetry=False, mf_energy=-1.1166856303994788, mo_energies=array([-0.5779842,  0.6697221]), mo_occ=array([2., 0.]), mean_field=&lt;pyscf.scf.hf.RHF object at 0x7fa46c643040&gt;, n_mos=2, n_sos=4, active_occupied=[0], frozen_occupied=[], active_virtual=[1], frozen_virtual=[]),\n 'qubit_mapping': 'jw',\n 'ansatz': &lt;tangelo.toolboxes.ansatz_generator.uccsd.UCCSD at 0x7fa42916e760&gt;,\n 'optimizer': &lt;bound method VQESolver._default_optimizer of &lt;tangelo.algorithms.variational.vqe_solver.VQESolver object at 0x7fa46e659910&gt;&gt;,\n 'initial_var_params': [2e-05, 0.03632416060255425],\n 'backend_options': {'target': None, 'n_shots': None, 'noise_model': None},\n 'penalty_terms': None,\n 'deflation_circuits': [],\n 'deflation_coeff': 1,\n 'ansatz_options': {},\n 'up_then_down': False,\n 'qubit_hamiltonian': (-0.09883484730799569+0j) [] +\n (-0.045321883918106265+0j) [X0 X1 Y2 Y3] +\n (0.045321883918106265+0j) [X0 Y1 Y2 X3] +\n (0.045321883918106265+0j) [Y0 X1 X2 Y3] +\n (-0.045321883918106265+0j) [Y0 Y1 X2 X3] +\n (0.17120123806595938+0j) [Z0] +\n (0.16862327595071586+0j) [Z0 Z1] +\n (0.12054612740556847+0j) [Z0 Z2] +\n (0.16586801132367474+0j) [Z0 Z3] +\n (0.1712012380659594+0j) [Z1] +\n (0.16586801132367474+0j) [Z1 Z2] +\n (0.12054612740556847+0j) [Z1 Z3] +\n (-0.22279639651093203+0j) [Z2] +\n (0.17434948757007068+0j) [Z2 Z3] +\n (-0.22279639651093203+0j) [Z3],\n 'verbose': False,\n 'ref_state': None,\n 'reference_circuit': &lt;tangelo.linq.circuit.Circuit at 0x7fa429202220&gt;,\n 'default_backend_options': {'target': None,\n  'n_shots': None,\n  'noise_model': None},\n 'optimal_energy': None,\n 'optimal_var_params': None,\n 'builtin_ansatze': {&lt;BuiltInAnsatze.HEA: 3&gt;,\n  &lt;BuiltInAnsatze.ILC: 9&gt;,\n  &lt;BuiltInAnsatze.QCC: 6&gt;,\n  &lt;BuiltInAnsatze.QMF: 5&gt;,\n  &lt;BuiltInAnsatze.UCC1: 1&gt;,\n  &lt;BuiltInAnsatze.UCC3: 2&gt;,\n  &lt;BuiltInAnsatze.UCCGD: 8&gt;,\n  &lt;BuiltInAnsatze.UCCSD: 0&gt;,\n  &lt;BuiltInAnsatze.UpCCGSD: 4&gt;,\n  &lt;BuiltInAnsatze.VSQS: 7&gt;},\n 'backend': &lt;tangelo.linq.simulator.Simulator at 0x7fa42916e7c0&gt;}\n\n\nIn particular we notice:\n\nqubit Hamiltonian: the qubit operator used for computing the expectation value in the energy estimation step of VQE\nbackend is a Simulator object that was defined in a submodule called linq, allowing us to define how a quantum circuit should be run. Currently, the default option is to run using an exact simulation (no noise) using the qulacs classical simulator.\nansatz: is now an object that implements the UCCSD ansatz. We go into more details about builtin and custom ansatze in a separate notebook. For now, it is useful to notice that one can peek at the UCCSD quantum circuit that was built, or the value of the variational parameters for this ansatz. This quantum circuit is in the format implemented in linq.\n\n\nprint(f\"Variational parameters: {vqe_solver.ansatz.var_params}\\n\")\nprint(vqe_solver.ansatz.circuit)\n\nVariational parameters: [2e-05, 0.03632416060255425]\n\nCircuit object. Size 158 \n\nX         target : [0]   \nX         target : [1]   \nRX        target : [0]   parameter : 1.5707963267948966\nH         target : [2]   \nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nRZ        target : [2]   parameter : 2e-05   (variational)\nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \nH         target : [2]   \nRX        target : [0]   parameter : -1.5707963267948966\nH         target : [0]   \nRX        target : [2]   parameter : 1.5707963267948966\nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nRZ        target : [2]   parameter : 12.566350614359173  (variational)\nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \nRX        target : [2]   parameter : -1.5707963267948966\nH         target : [0]   \nRX        target : [1]   parameter : 1.5707963267948966\nH         target : [3]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nRZ        target : [3]   parameter : 2e-05   (variational)\nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nH         target : [3]   \nRX        target : [1]   parameter : -1.5707963267948966\nH         target : [1]   \nRX        target : [3]   parameter : 1.5707963267948966\nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nRZ        target : [3]   parameter : 12.566350614359173  (variational)\nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nRX        target : [3]   parameter : -1.5707963267948966\nH         target : [1]   \nRX        target : [0]   parameter : 1.5707963267948966\nRX        target : [1]   parameter : 1.5707963267948966\nRX        target : [2]   parameter : 1.5707963267948966\nH         target : [3]   \nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nRZ        target : [3]   parameter : 0.018162080301277125    (variational)\nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \nH         target : [3]   \nRX        target : [2]   parameter : -1.5707963267948966\nRX        target : [1]   parameter : -1.5707963267948966\nRX        target : [0]   parameter : -1.5707963267948966\nRX        target : [0]   parameter : 1.5707963267948966\nH         target : [1]   \nRX        target : [2]   parameter : 1.5707963267948966\nRX        target : [3]   parameter : 1.5707963267948966\nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nRZ        target : [3]   parameter : 12.548208534057895  (variational)\nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \nRX        target : [3]   parameter : -1.5707963267948966\nRX        target : [2]   parameter : -1.5707963267948966\nH         target : [1]   \nRX        target : [0]   parameter : -1.5707963267948966\nH         target : [0]   \nH         target : [1]   \nRX        target : [2]   parameter : 1.5707963267948966\nH         target : [3]   \nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nRZ        target : [3]   parameter : 12.548208534057895  (variational)\nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \nH         target : [3]   \nRX        target : [2]   parameter : -1.5707963267948966\nH         target : [1]   \nH         target : [0]   \nH         target : [0]   \nRX        target : [1]   parameter : 1.5707963267948966\nRX        target : [2]   parameter : 1.5707963267948966\nRX        target : [3]   parameter : 1.5707963267948966\nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nRZ        target : [3]   parameter : 12.548208534057895  (variational)\nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \nRX        target : [3]   parameter : -1.5707963267948966\nRX        target : [2]   parameter : -1.5707963267948966\nRX        target : [1]   parameter : -1.5707963267948966\nH         target : [0]   \nRX        target : [0]   parameter : 1.5707963267948966\nH         target : [1]   \nH         target : [2]   \nH         target : [3]   \nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nRZ        target : [3]   parameter : 0.018162080301277125    (variational)\nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \nH         target : [3]   \nH         target : [2]   \nH         target : [1]   \nRX        target : [0]   parameter : -1.5707963267948966\nRX        target : [0]   parameter : 1.5707963267948966\nRX        target : [1]   parameter : 1.5707963267948966\nH         target : [2]   \nRX        target : [3]   parameter : 1.5707963267948966\nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nRZ        target : [3]   parameter : 0.018162080301277125    (variational)\nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \nRX        target : [3]   parameter : -1.5707963267948966\nH         target : [2]   \nRX        target : [1]   parameter : -1.5707963267948966\nRX        target : [0]   parameter : -1.5707963267948966\nH         target : [0]   \nRX        target : [1]   parameter : 1.5707963267948966\nH         target : [2]   \nH         target : [3]   \nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nRZ        target : [3]   parameter : 0.018162080301277125    (variational)\nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \nH         target : [3]   \nH         target : [2]   \nRX        target : [1]   parameter : -1.5707963267948966\nH         target : [0]   \nH         target : [0]   \nH         target : [1]   \nH         target : [2]   \nRX        target : [3]   parameter : 1.5707963267948966\nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nRZ        target : [3]   parameter : 12.548208534057895  (variational)\nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \nRX        target : [3]   parameter : -1.5707963267948966\nH         target : [2]   \nH         target : [1]   \nH         target : [0]   \n\n\n\n\n:warning: If you are not familiar with the linq submodule, we recommend you check at some point the tutorial covering the basics. You can however keep going through this notebook without issues.\n\n\n\nVQE.simulate\nAfter VQE.build has been run, we now have all the objects needed to run the VQE algorithm, which consists in a classical optimization loop over an energy estimation function. This energy estimation is obtained by computing the expectation value of our qubit Hamiltonian, with regards to the variational ansatz circuit.\nThe classical loop is driven by the selected optimizer (we’ll see a bit later how you can choose that), as well as the initial variational parameters.\nThis method returns the optimal energy computed during the optimization process. As a byproduct, the attributes optimal_energy and optimal_var_params of our VQESolver object have been updated. If you have turned on the verbose option, your output will print more information about energy during the optimization process.\n\nenergy_vqe = vqe_solver.simulate()\nprint(f\"\\nOptimal energy: \\t {energy_vqe}\")\nprint(f\"Optimal parameters: \\t {vqe_solver.optimal_var_params}\")\n\n\nOptimal energy:      -1.1372704157729143\nOptimal parameters:      [-5.4412497e-05  5.6522190e-02]\n\n\nThat’s it, we ran VQE ! We can quickly check whether or not it did well on this system, with the options we picked: let’s compare that to what classical approaches like CCSD or FCI can do. UCCSD captures single and double excitations, and should be exact for a system like H2, assuming the classical optimization of the variational parameters was succesful.\nThe CCSDSolver and FCISolver objects have a slightly different interface than VQESolver but are very straightforward. As we can see, the energies are in agreement, indicating that VQE did a good job.\n\nfrom tangelo.algorithms import FCISolver, CCSDSolver\n\nfci_solver = FCISolver(mol_H2)\nenergy_fci = fci_solver.simulate()\n\nccsd_solver = CCSDSolver(mol_H2)\nenergy_ccsd = ccsd_solver.simulate()\n\nprint(f\"FCI energy: \\t {energy_fci}\")\nprint(f\"CCSD energy: \\t {energy_ccsd}\")\nprint(f\"VQE energy: \\t {energy_vqe}\")\n\nFCI energy:      -1.1372704220924397\nCCSD energy:     -1.1372704220914702\nVQE energy:      -1.1372704157729143\n\n\n\n\nVQE.energy_estimation\nThe VQE.energy_estimation is a convenient method that allows you to run a single energy estimation, for some given variational parameters.\nThis would allow you to compare maybe different (initial?) variational parameters, or could be used to rebuild the underlying ansatz circuit for specific values of the variational parameters, without involving the classical optimization.\nThe UCCSD ansatz supports a few “shortcut” keywords for some parameters, such as “MP2”, “ones” or “random” (don’t hesitate to explore the ansatz attribute of your VQESolver object, in particular the n_var_params value). We can compare the energy they return: we see below that the mp2 parameters are a much better pick as initial parameters, but not as good as the optimal ones found by simulate earlier.\nSince this method builds the ansatz circuit for the input parameter, you can then grab the corresponding circuit. If you know the optimal parameters (from maybe a previous call to simulate), you can then grab the optimal circuit. Check out the linq tutorials to get an idea of how you could explore, export and send this circuit to a collaborator or a compute backend !\n\n# Compare energies associated to different variational parameters\nenergy = vqe_solver.energy_estimation(\"ones\")\nprint(f\"{energy:.7f} (params = {vqe_solver.ansatz.var_params})\")\n\nenergy = vqe_solver.energy_estimation(\"MP2\")\nprint(f\"{energy:.7f} (params = {vqe_solver.ansatz.var_params})\")\n\nenergy = vqe_solver.energy_estimation(vqe_solver.optimal_var_params)\nprint(f\"{energy:.7f} (params = {vqe_solver.ansatz.var_params})\")\n\n# You can retrieve the circuit corresponding to the last parameters you have used\noptimal_circuit = vqe_solver.ansatz.circuit\n\n-0.3369215 (params = [1. 1.])\n-1.1346304 (params = [2e-05, 0.03632416060255425])\n-1.1372704 (params = [-5.4412497e-05  5.6522190e-02])\n\n\n\n\nVQE.get_resources\nWhat we can or can’t simulate on backends today (may they be classical simulators or QPUs) is essentially driven by resource requirements. Metrics that correlate to the number of qubits, gates or measurements an algorithm would require to be performed accurately tell a lot about its feasibility on NISQ hardware, and can be used to compare different approaches, without having to actually do any simulation.\nThis method is able to grab the relevant information for our VQESolver by peeking into the underlying ansatz and qubit Hamiltonian objects. The information you receive is tied to the options you picked for VQE, and may not be true for all sets of variational parameters, depending on how the ansatz circuit is built, and potential optimizations done in the future to the circuit. We also return the number of variational parameters in VQE, as the difficulty of classical optimization plays an important role in the success of the algorithm.\nMore features for estimating the number of measurements to run an experiment with a given accuracy are on our roadmap.\nHere’s what our current example returns:\n\nresources = vqe_solver.get_resources()\nprint(resources)\n\n{'qubit_hamiltonian_terms': 15, 'circuit_width': 4, 'circuit_gates': 158, 'circuit_2qubit_gates': 64, 'circuit_var_gates': 12, 'vqe_variational_parameters': 2}\n\n\n\n\nVQE.get_rdm\nThe get_rdm method enables us to compute the one- and two-electron Reduced Density Matrices (RDM) using the ansatz circuit previously built by VQESolver, for some input variational parameters. This can come in handy, and is in particular used by the DMET problem decomposition technique, further detailed in another notebook.\nBelow, we compute these RDMs using the optimal variational parameters found by a previous call to simulate, and only print the one-electron RDM.\n\nonerdm, twordm = vqe_solver.get_rdm(vqe_solver.optimal_var_params)\nprint(onerdm)\n\n[[1.97455062+0.j 0.        +0.j]\n [0.        +0.j 0.02544938+0.j]]"
  },
  {
    "objectID": "examples/variational_methods/vqe.html#option-frozen-orbitals",
    "href": "examples/variational_methods/vqe.html#option-frozen-orbitals",
    "title": "VQE with Tangelo",
    "section": "3. Option: frozen orbitals",
    "text": "3. Option: frozen orbitals\nThe VQESolver class supports a frozen_orbitals option, allowing a user to pass either a list of indices (integers) referring to the orbitals to freeze, or a single integer indicating that all orbitals up to that index (excluded) must be frozen. For instance, just passing 3 would be equivalent to passing [0, 1, 2].\nInternally, this information is parsed and allows us to track which orbitals are active or frozen and occupied or virtual, through an object carrying molecular data which is an attribute of the VQESolver. By default, the option “frozen_core” is selected. If this string is detected, the function tangelo.toolboxes.molecular_computation.frozen_orbitals.get_frozen_core is called. It takes a Molecule or a SecondQuantizedMolecule object and returns an integer corresponding to the number of low-energy orbitals. In short, no orbital for each period 1 element, one orbital for each period 2 element and five orbitals for each period 3 element are summed up and frozen in the subsequent calculation. It is important to emphasize that this option does nothing if a custom qubit Hamiltonian is provided instead of a molecule.\nLet’s have a look at this quickly, taking a H4 molecule in sto-3g basis as an example. We can compare the results provided by VQE to our classical CCSD solver, which also support frozen orbitals with a slightly different interface.\n\nH4 = [[\"H\", [0.7071067811865476, 0.0, 0.0]], [\"H\", [0.0, 0.7071067811865476, 0.0]],\n      [\"H\", [-1.0071067811865476, 0.0, 0.0]], [\"H\", [0.0, -1.0071067811865476, 0.0]]]\n\nmol_H4 = SecondQuantizedMolecule(H4, q=0, spin=0, basis=\"sto-3g\", frozen_orbitals=[0, 3])\n\n\nvqe_options = {\"molecule\": mol_H4}\nvqe_solver_h4_frozen = VQESolver(vqe_options)\nvqe_solver_h4_frozen.build()\n\nenergy_vqe_h4_frozen = vqe_solver_h4_frozen.simulate()\nprint(f\"VQE energy: \\t {energy_vqe_h4_frozen}\")\n\nccsd_solver = CCSDSolver(mol_H4)\nenergy_ccsd_h4_frozen = ccsd_solver.simulate()\nprint(f\"CCSD energy: \\t {energy_ccsd_h4_frozen}\")\n\nprint(\"\\n\", vqe_solver_h4_frozen.get_resources())\n\nVQE energy:      -1.8943598012228877\nCCSD energy:     -1.894360237665742\n\n {'qubit_hamiltonian_terms': 15, 'circuit_width': 4, 'circuit_gates': 158, 'circuit_2qubit_gates': 64, 'circuit_var_gates': 12, 'vqe_variational_parameters': 2}\n\n\nFrozen orbitals offer a trade-off between resource requirements and accuracy. By freezing orbitals that seem not to contribute significantly to the computation, we may drastically reduce resource requirements. In this example, we sacrificed a noticeable amount of accuracy but also drastically reduced resource requirements and ended up with a formulation that was much easier to solve. Notice how simulate takes longer to execute here, and compare both energies and resource requirements to the previous cell.\n\nmol_H4 = SecondQuantizedMolecule(H4, q=0, spin=0, basis=\"sto-3g\", frozen_orbitals=None)\n\nvqe_options = {\"molecule\": mol_H4}\nvqe_solver_h4 = VQESolver(vqe_options)\nvqe_solver_h4.build()\n\nenergy_vqe_h4 = vqe_solver_h4.simulate()\nprint(f\"VQE energy: \\t {energy_vqe_h4}\")\nprint(\"\\n\", vqe_solver_h4.get_resources())\n\nVQE energy:      -1.9778372805046642\n\n {'qubit_hamiltonian_terms': 185, 'circuit_width': 8, 'circuit_gates': 2692, 'circuit_2qubit_gates': 1312, 'circuit_var_gates': 160, 'vqe_variational_parameters': 14}"
  },
  {
    "objectID": "examples/variational_methods/vqe.html#option-ansatz-and-qubit-mapping",
    "href": "examples/variational_methods/vqe.html#option-ansatz-and-qubit-mapping",
    "title": "VQE with Tangelo",
    "section": "4. Option: ansatz and qubit mapping",
    "text": "4. Option: ansatz and qubit mapping\nVQE relies on a qubit mapping in order to encode the fermionic-Hamiltonian into a spin-Hamiltonian which can be expressed natively on quantum hardware. This enables us to represent the occupation of fermionic orbital basis states in terms of the internal state of a collection of qubits. Meanwhile, the ansatz drives what portion of the Hilbert space can be explored by VQE, as we change the values of the variational parameters.\nWe can choose from a number of built-in ansatze (UCCSD, UCC1, UCC3…) and qubit mappings (Jordan-Wigner, Bravyi-Kitaev, symmetry-conserving Bravyi-Kitaev). In the previous examples, the default options for these two entities were selected. You may have noticed that the qubit mapping was Jordan-Wigner ('jw'), and the ansatz was UCCSD (Ansatze.UCCSD).\nThe choice of qubit mapping and ansatz impacts resource requirements but also accuracy. Designing “shallow” ansatze with low resource requirements that yield accurate results is an active topic of research.\nBelow, we show how the qubit mapping impacts our example on H2 using the UCCSD ansatz. Notice the difference in resource requirements, classical optimization, and the difference in accuracy.\n\nfrom tangelo.algorithms import BuiltInAnsatze as Ansatze\n\n# VQE-UCCSD on H2 with different qubit mappings\nfor qm in ['jw', 'bk', 'scbk']:\n    vqe_options = {\"molecule\": mol_H2, \"ansatz\": Ansatze.UCCSD, \"qubit_mapping\": qm}\n    vqe_solver = VQESolver(vqe_options)\n    vqe_solver.build()\n    vqe_solver.simulate()\n    print(\"\\n\", vqe_solver.get_resources(), \"\\n\")\n\n\n {'qubit_hamiltonian_terms': 15, 'circuit_width': 4, 'circuit_gates': 158, 'circuit_2qubit_gates': 64, 'circuit_var_gates': 12, 'vqe_variational_parameters': 2} \n\n\n {'qubit_hamiltonian_terms': 15, 'circuit_width': 4, 'circuit_gates': 107, 'circuit_2qubit_gates': 46, 'circuit_var_gates': 12, 'vqe_variational_parameters': 2} \n\n\n {'qubit_hamiltonian_terms': 5, 'circuit_width': 2, 'circuit_gates': 22, 'circuit_2qubit_gates': 4, 'circuit_var_gates': 4, 'vqe_variational_parameters': 2} \n\n\n\n/home/alex/Codes/Tangelo/tangelo/toolboxes/qubit_mappings/statevector_mapping.py:149: RuntimeWarning: Symmetry-conserving Bravyi-Kitaev enforces all spin-up followed by all spin-down ordering.\n  warnings.warn(\"Symmetry-conserving Bravyi-Kitaev enforces all spin-up followed by all spin-down ordering.\", RuntimeWarning)\n\n\n\n:warning: Each ansatz works differently, or may not be compatible with all qubit mappings. We encourage you to check out the documentation. In particular, how the Ansatz class work and how to implement your own custom ansatz into VQE is covered in a separate notebook vqe_custom_ansatz_hamiltonian.ipynb.\n\nWe can also try using the restricted UCC ansatze UCC1 and UCC3 to solve this problem:\n\n# VQE-UCCSD on H2 with ansatze UCC1 and UCC3\nfor az in [Ansatze.UCC1, Ansatze.UCC3]:\n    vqe_options = {\"molecule\": mol_H2, \"ansatz\": az, \"up_then_down\": True}\n    vqe_solver = VQESolver(vqe_options)\n    vqe_solver.build()\n    vqe_solver.simulate()\n    print(\"\\n\", vqe_solver.get_resources(), \"\\n\")\n\n\n {'qubit_hamiltonian_terms': 15, 'circuit_width': 4, 'circuit_gates': 17, 'circuit_2qubit_gates': 6, 'circuit_var_gates': 1, 'vqe_variational_parameters': 1} \n\n\n {'qubit_hamiltonian_terms': 15, 'circuit_width': 4, 'circuit_gates': 23, 'circuit_2qubit_gates': 8, 'circuit_var_gates': 3, 'vqe_variational_parameters': 3}"
  },
  {
    "objectID": "examples/variational_methods/vqe.html#option-classical-optimization",
    "href": "examples/variational_methods/vqe.html#option-classical-optimization",
    "title": "VQE with Tangelo",
    "section": "5. Option: classical optimization",
    "text": "5. Option: classical optimization\nYou also have full control over the classical optimization strategy you wish to follow. Earlier, we showed how the initial_var_params attribute of the VQESolver class could be used in different ways: check out the implementation of your ansatz object to see what is supported.\nUsers can also provide their own optimizer, which will be called in VQESolver.simulate and be passed a handle to the VQESolver.energy_estimation function and the initial variational parameters. Below, we decide to use the COBYLA optimizer from scipy:\nIt is required that both the resulting function value and resulting parameters (result.fun and result.x respectively for the example below) are returns for the user defined function. This allows easy access after optimization to the optimal energy from vqe_solver.optimal_energy, and optimal parameters from vqe_solver.optimal_var_params.\n\ndef cobyla_optimizer(func, var_params):\n    from scipy.optimize import minimize\n    result = minimize(func, var_params, method=\"COBYLA\", options={\"disp\": True, \"maxiter\": 100, 'rhobeg':0.1})\n    \n    print(f\"\\tOptimal UCCSD energy: {result.fun}\")\n    print(f\"\\tOptimal UCCSD variational parameters: {result.x}\")\n    print(f\"\\tNumber of Function Evaluations : {result.nfev}\")\n    return result.fun, result.x\n    \n# Use \"optimizer\" and \"initial_var_params\" to customize your classical optimization\nvqe_options = {\"molecule\": mol_H2, \"optimizer\": cobyla_optimizer, \"initial_var_params\": [1., 2.]}\nvqe_solver = VQESolver(vqe_options)\nvqe_solver.build()\noptimal_energy = vqe_solver.simulate()\n\n    Optimal UCCSD energy: -1.1372704174429256\n   Normal return from subroutine COBYLA\n\n   NFVALS =   36   F =-1.137270E+00    MAXCV = 0.000000E+00\n   X = 1.570763E+00   2.412707E+00\n\n    Optimal UCCSD variational parameters: [1.57076299 2.41270658]\n    Number of Function Evaluations : 36"
  },
  {
    "objectID": "examples/variational_methods/vqe.html#option-compute-backend",
    "href": "examples/variational_methods/vqe.html#option-compute-backend",
    "title": "VQE with Tangelo",
    "section": "6. Option: compute backend",
    "text": "6. Option: compute backend\nThe VQESolver class relies on the linq submodule in order to simulate your quantum circuits.\nFor more information about the backend attribute of your VQE_Solver object, of type tangelo.linq.Simulator, we recommend you check the linq tutorial notebooks.\nThis object allows you to pick from a number of different classical simulators, with significantly different performance, some supporting noisy simulation. The parameters n_shots introduces statistical noise in the computation, which correlates to accuracy of energy estimation, while noise_model enables us to model noise in the circuit to an extent. These parameters are provided to enable the modeling of experiments that may be closer to the behaviour of quantum hardware.\nBelow, we specify that we’d like our VQESolver to use the simulator from the cirq Python package as a backend, and leave the two other parameters to None to signify that we want the simulation to be exact.\n\nmy_backend_options = {\"target\": \"cirq\", \"n_shots\": None, \"noise_model\": None}\nvqe_options = {\"molecule\": mol_H2, \"backend_options\": my_backend_options, \"verbose\": True}\nvqe_solver = VQESolver(vqe_options)\nvqe_solver.build()\n\nfor term, coef in vqe_solver.qubit_hamiltonian.terms.items():\n    vqe_solver.qubit_hamiltonian.terms[term] = coef.real\n\nvqe_solver.simulate()\n\nopt_energy = vqe_solver.optimal_energy\nopt_params = vqe_solver.optimal_var_params\n\nVQESolver optimization results:\n    Optimal VQE energy: -1.1372704157729134\n    Optimal VQE variational parameters: [-5.44125627e-05  5.65221900e-02]\n    Number of Iterations : 3\n    Number of Function Evaluations : 10\n    Number of Gradient Evaluations : 3\n\n\nRunning VQE on a noisy backend is a challenge in itself, and it is hard to predict what will be the behavior on the algorithm when the output is based on drawing shots (samples), which reflects the probabilistic nature of a quantum processor.\nWhat optimizer should be used for a noisy function? How does it correlate with the number of shots (samples) we need to gather for each energy estimation ? Is there any hope for VQE to be useful on a quantum computer ? All of these are open questions.\nBelow, we illustrate how one can see that the amount of shots (samples) taken for energy estimation leads to better accuracy:\n\nmy_backend_options = {\"target\": \"qulacs\", \"n_shots\": 1, \"noise_model\": None}\nvqe_options = {\"molecule\": mol_H2, \"backend_options\": my_backend_options}\nvqe_solver = VQESolver(vqe_options)\nvqe_solver.build()\n\nfor n_shots in [10**2, 10**4, 10**6]:\n    vqe_solver.backend.n_shots = n_shots\n    energy = vqe_solver.energy_estimation(opt_params)\n    print(f\"Energy estimation with {n_shots:.1E} shots = {energy} \\t(Error: {abs(energy - opt_energy):.2E})\")\n\nEnergy estimation with 1.0E+02 shots = -1.1335574814374392  (Error: 3.71E-03)\nEnergy estimation with 1.0E+04 shots = -1.1358696314459025  (Error: 1.40E-03)\nEnergy estimation with 1.0E+06 shots = -1.1372051734252862  (Error: 6.52E-05)"
  },
  {
    "objectID": "examples/variational_methods/vqe.html#closing-words",
    "href": "examples/variational_methods/vqe.html#closing-words",
    "title": "VQE with Tangelo",
    "section": "Closing words",
    "text": "Closing words\nThis concludes our overview of VQESolver. Due to the complexity of the topic, we did not explore in details some of the underlying objects it relies on, such as the ansatz object and the backend object.\nFor a more in-depth discussion on these objects, please refer to the documentation and check out the other notebooks we have in this folder, or maybe the linq notebooks."
  },
  {
    "objectID": "examples/variational_methods/adapt.html",
    "href": "examples/variational_methods/adapt.html",
    "title": "ADAPT-VQE",
    "section": "",
    "text": "Open In Colab\nADAPT-VQE was introduced by Grimsley et al as a solution to the often impracticably deep, and not necessarily accurate, static VQE circuits. In ansatze like UCCSD, one easily reaches the order of thousands of gates, even for modestly sized molecules. In UCCSD and its generalized UCCGSD, the number of fermionic excitations in the ansatz scales like \\(\\mathcal{O}(N^2M^2)\\), and \\(\\mathcal{O}(N^4)\\) respectively. Here \\(N\\) refers to the number of spin-orbitals in the problem basis, and \\(M\\) the number of electrons. .\nIn ADAPT-VQE, an ansatz which approximates not UCCSD/UCCGSD, but in fact FCI, is built iteratively. Over a series of cycles, the ansatz circuit is grown to achieve an approximation to FCI with a minimal number of circuit elements. In this way, ADAPT-VQE can be thought as a meta-VQE: at each cycle, a new ansatz is defined, and its parameters optimized according to conventional VQE. As the cycles proceed, the ansatz grows in both complexity and expressibility. This algorithm comes at the expense of a significant increase in measurement overhead. In order to identify the best operator to append to the present ansatz circuit, a large number of measurements are performed to rank the available operators in order of their ability to further reduce the ansatz state energy.\nIn this notebook, we explore the implementation of this algorithm, available in Tangelo. The original algorithm is examined first, and has shown some success in reducing the number of variational parameters required to express the quantum state. Then, we examine another version of ADAPT-VQE which is successful at reducing the circuit size by using a pool of operators defined from the Qubit Hamiltonian.\nThis notebook assumes that you already have installed Tangelo in your Python environment, or have updated your Python path so that the imports can be resolved. If not, executing the cell below installs the minimal requirements for this notebook.\n# Installation of tangelo if not already installed.\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet"
  },
  {
    "objectID": "examples/variational_methods/adapt.html#original-adapt-vqe",
    "href": "examples/variational_methods/adapt.html#original-adapt-vqe",
    "title": "ADAPT-VQE",
    "section": "Original ADAPT-VQE",
    "text": "Original ADAPT-VQE\nADAPT-VQE relies on three principal steps.\n\nUse the UCCGSD pool \\(\\{P_i\\}\\), a set of available operators from which we will iteratively construct the ansatz.\nRank operators by evaluating the gradient for each operator in the pool \\(\\frac{\\partial E^{(k)}}{\\partial \\theta_i} = \\langle \\psi_k|[H,P_i]|\\psi_k\\rangle\\). Exit if the largest partial derivative is less than some cutoff or max iterations have been reached.\nAppend \\(U_k = \\mathrm{exp}[i\\theta_k P_k]\\)(index) to the ansatz \\(U=\\prod_k U_k(\\theta_k)\\), and optimize \\(\\langle H\\rangle\\) using VQE.\nReturn to step 2.\n\nThe UCCGSD pool allows for high accuracy with a small number of cycles and consequently very few variational parameters. However, the circuit remains very deep, as each excitation consists of many multi-qubit Pauli rotations.\n\nRunning the Adapt-VQE algorithm\nWe define a molecule \\(H_4\\) in this case and use the AdaptSolver class to run Adapt-VQE.\n\nfrom tangelo import SecondQuantizedMolecule\nfrom tangelo.algorithms import ADAPTSolver\n\nH4 = [(\"H\", (0, 0, 0)), (\"H\", (0, 1.4, 0)), (\"H\", (0, 2.8, 0)), (\"H\", (0, 4.2, 0))]\nmol = SecondQuantizedMolecule(H4, q=0, spin=0, basis=\"sto-3g\", frozen_orbitals=None)\n\nopt_dict = {\"molecule\": mol, \"tol\": 0.01, \"max_cycles\": 7, \"verbose\": False, \"qubit_mapping\": \"jw\"}\n\nadapt_solver = ADAPTSolver(opt_dict)\nadapt_solver.build()\nadapt_solver.simulate()\n\n-2.0282112841599287\n\n\nAfter 7 cycles, we force the algorithm to terminate. We can now compare the results against the predictions of FCI.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom tangelo.algorithms import FCISolver\n\nfci_solver = FCISolver(mol)\nexact = fci_solver.simulate()\nerrors = np.array(adapt_solver.energies) - exact\nfig,ax = plt.subplots(1,1)\nax.plot(errors)\nax.set_xlabel('ADAPT Iteration')\nax.set_ylabel('Error (Ha)')\nax.set_title('ADAPT-VQE: H$_4$')\nax.set_yscale('log')\nprint(f'Final Error: {errors[-1] :.4E}')\n\nFinal Error: 8.5921E-04\n\n\n\n\n\nOk, so after 7 cycles, we have an error of 0.9 mHa, within chemical accuracy of FCI. How does this all compare against UCCSD-VQE?\n\nfrom tangelo.algorithms import VQESolver, BuiltInAnsatze\n\nvqe_solver = VQESolver({'molecule': mol, 'ansatz': BuiltInAnsatze.UCCSD})\nvqe_solver.build()\nvqe_solver.simulate()\n\n-2.028138757838466\n\n\n\nprint(f'ADAPT-VQE ERROR: {adapt_solver.energies[-1] - exact :0.4E} Ha')\nprint(f'UCCSD-VQE ERROR: {vqe_solver.optimal_energy - exact :0.4E} Ha')\n\nADAPT-VQE ERROR: 8.5921E-04 Ha\nUCCSD-VQE ERROR: 9.3174E-04 Ha\n\n\nFrom the perspective of energy accuracy, the two have reached very similar results. The big advantage here however, are in the resources required for the ADAPT-VQE ansatz circuit:\n\nprint(f'ADAPT RESOURCES:\\n {adapt_solver.get_resources()}\\n')\nprint(f'UCCSD RESOURCES:\\n {vqe_solver.get_resources()}')\n\nADAPT RESOURCES:\n {'qubit_hamiltonian_terms': 185, 'circuit_width': 8, 'circuit_depth': 1384, 'circuit_2qubit_gates': 1152, 'circuit_var_gates': 128, 'vqe_variational_parameters': 7}\n\nUCCSD RESOURCES:\n {'qubit_hamiltonian_terms': 185, 'circuit_width': 8, 'circuit_depth': 1702, 'circuit_2qubit_gates': 1312, 'circuit_var_gates': 160, 'vqe_variational_parameters': 14}\n\n\nWe have managed here to reduce the total number of variational parameters by a factor of two while keeping all the gate requirements similar. With ADAPT-VQE, the scaling of the number of parameters that need to be optimized should be better than the \\(\\mathcal{O}(N^2M^2)\\) scaling of UCCSD-VQE.\nThere is another version of ADAPT-VQE which focuses on reducing the circuit depth instead of reducing the number of variational parameters. Although, this version can also reduce the number of variational parameters by truncating the number of cycles, it is not as efficient in the respect as the orignal ADAPT-VQE implementation. This is what we will explore next."
  },
  {
    "objectID": "examples/variational_methods/adapt.html#reducing-circuit-depth-with-adapt-vqe",
    "href": "examples/variational_methods/adapt.html#reducing-circuit-depth-with-adapt-vqe",
    "title": "ADAPT-VQE",
    "section": "Reducing circuit depth with ADAPT-VQE",
    "text": "Reducing circuit depth with ADAPT-VQE\nThere are two obvious avenues along which one can be creative in the implementation of ADAPT-VQE–these are the selection of the operator pool \\(\\{P_i\\}\\), and the ranking strategy. Above, we have specified that we are using the gradient to perform this ranking procedure. This is the only method which has been used previously, and we will continue to do so here. Regarding the choice of operator pool, the original method used the UCCGSD ansatz to generate the pool, i.e. the single, double fermionic excitations. Subsequent work has focused on qubit-native operators, and we’ll follow this strategy as well. As we have shown above, the UCCGSD pool allows for high accuracy with a small number of cycles (and consequently very few variational parameters), but the circuit remains very deep. We will now show how to use a custom Hamiltonian-inspired qubit-pool to generate shorter circuits.\n\nHamiltonian-Inspired Qubit-ADAPT\nWe are going to use the qubit Hamiltonian \\(H\\) to establish a set of pool generators to use in our implementation of ADAPT-VQE. For each term in the Hamiltonian which acts on a distinct combination of qubits, we’ll add a pool operator which is guaranteed to have a non-zero commutator with respect to H, and therefore a finite gradient. This will give us a fairly compact set of operators in the pool, all of which are likely to be useful in our ansatz construction. To do this, we will scan through all terms in the qubit Hamiltonian. For each, we will identify the Pauli operators associated with electronic excitation (X and Y gates). We discard Z gates from the Pauli string. If the number of Y gates in a string is even, we can use this to construct an excitation pool element that preserves T-symmetry, by flipping one of the other X gates to a Y, or a Y to an X. Below, we’ll flip the first X or Y to its partner.\n\ndef get_pool(qubit_hamiltonian, n_qubits):\n    \"\"\"Use Hamiltonian to identify non-commuting Pauli strings to use as operator pool.\n    We identify terms with even number of Y-operators, in order to define excitations \n    which preserve T-reversal symmetry. We remove all Z operators, and we flip the first\n    X or Y to its partner (i.e. X &lt;&gt; Y).\n    Args:\n        qubit_hamiltonian (QubitOperator): input Hamiltonian\n        n_qubits (int): number of qubits for Hamiltonian\n    \n    Returns:\n        pool_generators (list of QubitOperator): list of generators\n    \"\"\"\n    import numpy as np\n    from tangelo.toolboxes.operators.operators import QubitOperator\n\n    pauli_lookup = {'Z':1, 'X':2, 'Y':3}\n    pauli_reverse_lookup = ['I', 'Z', 'X', 'Y']\n    pool_generators, pool_tuples = list(), list()\n    indices = list()\n\n    for term in qubit_hamiltonian.terms:\n        pauli_string = np.zeros(n_qubits, dtype=int)\n        \n        #identify all X or Y factors\n        for index, action in term:\n            if pauli_lookup[action] &gt; 1:\n                pauli_string[index] = pauli_lookup[action]\n\n        #only allow one operator acting on a given set of qubits\n        action_mask = tuple(pauli_string &gt; 1)\n        if action_mask in indices:\n            continue\n\n        #only consider terms with even number of Y\n        if sum(pauli_string) % 2 == 0 and sum(pauli_string) &gt; 0:\n            #identify qubit operator to change X&lt;&gt;Y\n            flip_index = np.where(pauli_string &gt; 1)[0][0]\n            pauli_string[flip_index] += (-1)**(pauli_string[flip_index] % 2) \n\n            #update set of used qubit combinations\n            indices.append(action_mask)\n            #create QubitOperator for the new generator\n            operator_tuple = tuple([(index,pauli_reverse_lookup[pauli]) for index, pauli in enumerate(pauli_string) if pauli &gt; 0])\n            #We don't use the coefficients directly, so since we need to multiply by 1.j for evaluating gradients, \n            #I'm just instantiating these with that coefficient in place\n            pool_generators.append(QubitOperator(operator_tuple, 1.0j))\n            pool_tuples.append(operator_tuple)\n    \n    return pool_generators\n\nTo exemplify the generation of an operator pool, we will apply this method to a simple Hamiltonian consisting of a single fermionic excitation and its Hermitian conjugate.\n\nfrom tangelo.toolboxes.operators import QubitOperator\nqubit_operator = QubitOperator(((0, 'X'), (1, 'X'), (2, 'Y'), (3, 'Y')), -1.0) \\\n                  + QubitOperator(((0, 'X'), (1, 'Y'), (2, 'Y'), (3, 'X')), 1.0) \\\n                  + QubitOperator(((0, 'Y'), (1, 'X'), (2, 'X'), (3, 'Y')), 1.0) \\\n                  + QubitOperator(((0, 'Y'), (1, 'Y'), (2, 'X'), (3, 'X')), -1.0) \npool_generators = get_pool(qubit_operator, n_qubits=4)\nprint(f'OPERATOR POOL: {pool_generators}')\n\nOPERATOR POOL: [1j [Y0 X1 Y2 Y3]]\n\n\nWe have used a qubit Hamiltonian where all operators act on the same qubit indices. This results in just a single generator pool element. As we traverse the qubit_hamiltonian in order, the generator corresponds to the first term in the Hamiltonian, with the first X operator switched to a Y operator. So from XXYY, we have YXYY.\n\n\nDefining the problem\nFor the generator pool we’ve considered here, the smallest non-trivial problem to consider is \\(H_4\\), as \\(H_2\\) has only one generator and ADAPT terminates at FCI accuracy after a single iteration. So we’ll apply the qubit-ADAPT algorithm to the same \\(H_4\\) molecule as we did above with the UCCGSD pool. We obtain the qubit operator using fermion_to_qubit_mapping to make use of the pool function defined above.\n\nfrom tangelo.toolboxes.qubit_mappings.mapping_transform import fermion_to_qubit_mapping\nfrom tangelo.toolboxes.operators import count_qubits\n\nfermion_operator = mol._get_fermionic_hamiltonian()\nqubit_operator = fermion_to_qubit_mapping(fermion_operator, 'jw', mol.n_active_sos, mol.n_electrons)\nn_qubits = count_qubits(qubit_operator)\n\nWith the problem defined and the get_pool function prepared, we can proceed to initiate the ADAPT-VQE method. This is as simple as defining the problem with a options dictionary and initiating the ADAPTSolver class.\n\nfrom tangelo.algorithms import ADAPTSolver\n\nopt_dict = {\"molecule\": mol,\n            \"pool\": get_pool,\n            \"pool_args\": {\"qubit_hamiltonian\": qubit_operator, \"n_qubits\": n_qubits},\n            \"tol\": 0.01,\n            \"max_cycles\": 12,\n            \"verbose\": False}\n\nadapt_solver = ADAPTSolver(opt_dict)\nadapt_solver.build()\nadapt_solver.simulate()\n\n-2.0276601175490274\n\n\nAfter 12 cycles, we force the algorithm to terminate. We can now compare the results against the predictions of FCI.\n\nerrors = np.array(adapt_solver.energies) - exact\nfig,ax = plt.subplots(1,1)\nax.plot(errors)\nax.set_xlabel('ADAPT Iteration')\nax.set_ylabel('Error (Ha)')\nax.set_title('qubit-ADAPT: H$_4$')\nax.set_yscale('log')\nprint(f'Final Error: {errors[-1] :.4E}')\n\nFinal Error: 1.4104E-03\n\n\n\n\n\nOk so after 12 cycles, we have an error of 1.4 mHa, within chemical accuracy of FCI. How does this all compare against UCCSD-VQE?\n\nprint(f'ADAPT-VQE ERROR: {adapt_solver.energies[-1] - exact :0.4E} Ha')\nprint(f'UCCSD-VQE ERROR: {vqe_solver.optimal_energy - exact :0.4E} Ha')\n\nADAPT-VQE ERROR: 1.4104E-03 Ha\nUCCSD-VQE ERROR: 9.3174E-04 Ha\n\n\nFrom the perspective of energy accuracy, the two have reached very similar results, within a factor of two. The big advantage here however, are in the resources required for this ansatz circuit:\n\nprint(f'ADAPT RESOURCES:\\n {adapt_solver.get_resources()}\\n')\nprint(f'UCCSD RESOURCES:\\n {vqe_solver.get_resources()}')\n\nADAPT RESOURCES:\n {'qubit_hamiltonian_terms': 185, 'circuit_width': 8, 'circuit_depth': 98, 'circuit_2qubit_gates': 72, 'circuit_var_gates': 12, 'vqe_variational_parameters': 12}\n\nUCCSD RESOURCES:\n {'qubit_hamiltonian_terms': 185, 'circuit_width': 8, 'circuit_depth': 1702, 'circuit_2qubit_gates': 1312, 'circuit_var_gates': 160, 'vqe_variational_parameters': 14}\n\n\nWe have managed here to reduce the total number of gates, the number of 2-qubit gates, and the number of variational gates by an order of magnitude.\nWe note that this qubit-ADAPT-VQE has run with 2 fewer variational parameters than UCCSD-VQE. This is much closer to the UCCSD-VQE than the original ADAPT-VQE. Therefore, using these two variants of ADAPT-VQE, we have the opportunity to compromise between optimization complexity and circuit complexity by choosing the operator pool. Both versions will converge to the correct FCI solution given enough cycles, however the original ADAPT-VQE will require more quantum resources while the qubit ADAPT-VQE will require more classical resources. This flexibility in resource requirements is an important advantage for the ADAPT-VQE algorithm over static ansatze.\n\n\nRestricting Quantum numbers\nThere is one small problem with a qubit inspired ansatz. It does not generally respect the symmetry of the problem. We can now examine the \\(\\hat{S}^2\\), \\(\\hat{S}_Z\\) and the \\(\\hat{N}\\) operators to determine if any loss of symmetry has occured. For this problem, the ground state is a singlet with four electrons so the expected values are \\(S^2=0\\), \\(S_Z=0\\) and \\(N=4\\) respectively.\n\nexact_s2 = 0\nexact_sz = 0\nexact_n = mol.n_active_electrons\nadapt_s2 = adapt_solver.vqe_solver.operator_expectation('S^2')\nadapt_sz = adapt_solver.vqe_solver.operator_expectation('Sz')\nadapt_n = adapt_solver.vqe_solver.operator_expectation('N')\nuccsd_s2 = vqe_solver.operator_expectation('S^2')\nuccsd_sz = vqe_solver.operator_expectation('Sz')\nuccsd_n = vqe_solver.operator_expectation('N')\n\nprint(f'Adapt quantum numbers errors: N = {adapt_n-exact_n:6.4f}, Sz = {adapt_sz-exact_sz:6.4f}, S^2 = {adapt_s2-exact_s2:6.4f}')\nprint(f'UCCSD quantum numbers errors: N = {uccsd_n-exact_n:6.4f}, Sz = {uccsd_sz-exact_sz:6.4f}, S^2 = {uccsd_s2-exact_s2:6.4f}')\n\nAdapt quantum numbers errors: N = 0.0001, Sz = 0.0004, S^2 = 0.0015\nUCCSD quantum numbers errors: N = -0.0000, Sz = -0.0000, S^2 = 0.0000\n\n\nAs you can see, there are small errors in the desired quantum numbers with qubit-Adapt while UCCSD has the correct expectation values. Therefore, the resulting representation is not exactly what we wanted. To address this problem we can add a penalty term to the qubit hamiltonian and minimize this modified qubit_hamiltonian directly using Adapt-VQE instead of the molecular hamiltonian. Generating this new Hamiltonian is as simple as creating a dictionary of [penalty_weight,  desired_quantum_number] for each operator and using the combined_penalty function. For this example, we choose a penalty_weight of 1/2 for each term which is usually a reasonable choice.\n\nfrom tangelo.toolboxes.ansatz_generator.penalty_terms import combined_penalty\nfrom tangelo.toolboxes.operators.operators import qubitop_to_qubitham\n\n# Define dictionary of desired quantum numbers [penalty_weight, desired_quantum_number]\npenalty_weight = 1/2\ndict_penalty_terms = {'N': [penalty_weight, exact_n],\n                      'Sz': [penalty_weight, exact_sz],\n                      'S^2': [penalty_weight, exact_s2]}\n\npen_fermion_operator = combined_penalty(mol.n_active_mos, opt_penalty_terms=dict_penalty_terms)\npen_qubit_operator = fermion_to_qubit_mapping(fermion_operator=pen_fermion_operator,\n                                              mapping='jw',\n                                              n_spinorbitals=mol.n_active_sos,\n                                              n_electrons=mol.n_electrons)\nqubit_operator_with_pen = qubit_operator + pen_qubit_operator\nopt_dict = {\"qubit_hamiltonian\": qubit_operator_with_pen,\n            \"n_electrons\": mol.n_electrons,\n            \"n_spinorbitals\": mol.n_active_sos,\n            \"spin\": mol.spin,\n            \"pool\": get_pool,\n            \"pool_args\": {\"qubit_hamiltonian\": qubit_operator_with_pen, \"n_qubits\": n_qubits},\n            \"tol\": 0.01,\n            \"max_cycles\": 12,\n            \"verbose\": False}\n\nadapt_solver_with_pen = ADAPTSolver(opt_dict)\nadapt_solver_with_pen.build()\nadapt_solver_with_pen.simulate()\n\n-2.0222593086636214\n\n\nWe can now check that minimizing this new Hamiltonian resulted in a state with the correct operator expectation values.\n\n# Since we initialized VQESolver with a QubitHamiltonian, we need to provide the corresponding number of molecular\n# orbitals to use the built-in operators S^2, Sz and N.\nadapt_with_pen_s2 = adapt_solver_with_pen.vqe_solver.operator_expectation('S^2', n_active_mos=mol.n_active_mos)\nadapt_with_pen_sz = adapt_solver_with_pen.vqe_solver.operator_expectation('Sz', n_active_mos=mol.n_active_mos)\nadapt_with_pen_n = adapt_solver_with_pen.vqe_solver.operator_expectation('N', n_active_mos=mol.n_active_mos)\n\nprint(f'ADAPT-VQE ERROR: {adapt_solver_with_pen.vqe_solver.operator_expectation(qubit_operator) - exact :0.4E} Ha')\nprint(f'UCCSD-VQE ERROR: {vqe_solver.optimal_energy - exact :0.4E} Ha\\n')\nprint(f'ADAPT RESOURCES:\\n {adapt_solver_with_pen.get_resources()}')\nprint(f'UCCSD RESOURCES:\\n {vqe_solver.get_resources()}\\n')\nprint(f'Adapt quantum numbers: N = {adapt_with_pen_n - exact_n:6.4f}, Sz = {adapt_with_pen_sz - exact_sz:6.4f}, S^2 = {adapt_with_pen_s2 - exact_s2:6.4f}')\nprint(f'UCCSD quantum numbers: N = {uccsd_n - exact_n:6.4f}, Sz = {uccsd_sz - exact_sz:6.4f}, S^2 = {uccsd_s2 - exact_s2:6.4f}')\n\nADAPT-VQE ERROR: 6.7615E-03 Ha\nUCCSD-VQE ERROR: 9.3174E-04 Ha\n\nADAPT RESOURCES:\n {'qubit_hamiltonian_terms': 695, 'circuit_width': 8, 'circuit_depth': 87, 'circuit_2qubit_gates': 72, 'circuit_var_gates': 12, 'vqe_variational_parameters': 12}\nUCCSD RESOURCES:\n {'qubit_hamiltonian_terms': 185, 'circuit_width': 8, 'circuit_depth': 1702, 'circuit_2qubit_gates': 1312, 'circuit_var_gates': 160, 'vqe_variational_parameters': 14}\n\nAdapt quantum numbers: N = -0.0000, Sz = 0.0000, S^2 = 0.0000\nUCCSD quantum numbers: N = -0.0000, Sz = -0.0000, S^2 = 0.0000\n\n\nAs you can see, we have now found a state that has the correct symmetry properties but the resulting energy is now larger than chemical accuracy. Therefore, more cycles of ADAPT-VQE are needed if chemical accuracy is desired."
  },
  {
    "objectID": "examples/variational_methods/adapt.html#conclusion",
    "href": "examples/variational_methods/adapt.html#conclusion",
    "title": "ADAPT-VQE",
    "section": "Conclusion",
    "text": "Conclusion\nIn this notebook, we’ve explored an implementation of the original ADAPT-VQE algorithm, and the Hamiltonian-inspired qubit variant, using the tools available in Tangelo. It is clear that the number of parameters required for accurate results can be made much smaller with the orignal algorithm, while the qubit version can reduce the circuit depth greatly. The second section illustrates how users can create their own pool of qubit operators through their own get_pool function, to explore their own avenues."
  },
  {
    "objectID": "examples/variational_methods/iqcc_using_clifford.html",
    "href": "examples/variational_methods/iqcc_using_clifford.html",
    "title": "Iterative Qubit Coupled Cluster using only Clifford circuits",
    "section": "",
    "text": "This notebook shows how to implement iQCC using only Clifford circuits with Tangelo, and accompanies a note released at arXiv:2211.10501. We provide here the abstract of the article in this notebook for convenience and highlight the main steps of our implementation. Please refer to the article for full details."
  },
  {
    "objectID": "examples/variational_methods/iqcc_using_clifford.html#closing-words",
    "href": "examples/variational_methods/iqcc_using_clifford.html#closing-words",
    "title": "Iterative Qubit Coupled Cluster using only Clifford circuits",
    "section": "Closing words",
    "text": "Closing words\nThis notebook shows that a variant of iQCC can be implemented while only using Clifford circuits as described in our manuscript. This method can be used to initialize the QCC ansatz for VQE or to create short depth circuits that improve the success probability of fault-tolerant algorithms such as phase estimation."
  },
  {
    "objectID": "examples/variational_methods/vqe_custom_ansatz_hamiltonian.html",
    "href": "examples/variational_methods/vqe_custom_ansatz_hamiltonian.html",
    "title": "Tangelo VQE: Custom Ansatz and qubit Hamiltonian Tutorial",
    "section": "",
    "text": "Open In Colab\nTangelo comes packaged with an implementation of several standard ansatz circuits for the user to take advantage of. In this tutorial, we’ll explore how you can incorporate the built in VQESolver into your own workflow, by introducing a user-defined custom ansatz circuit and/or a qubit Hamiltonian. We’ll base our work here on the VQESolver class, and take advantage of tools readily available through Tangelo.\n# Installation of tangelo if not already installed.\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet\nimport numpy as np\n\nfrom tangelo.algorithms import VQESolver, FCISolver\nfrom tangelo import SecondQuantizedMolecule\nfrom tangelo.toolboxes.ansatz_generator.ansatz import Ansatz\nfrom tangelo.toolboxes.qubit_mappings.statevector_mapping import get_reference_circuit\nfrom tangelo.toolboxes.qubit_mappings.mapping_transform import get_qubit_number, fermion_to_qubit_mapping\nfrom tangelo.linq import Circuit, Gate"
  },
  {
    "objectID": "examples/variational_methods/vqe_custom_ansatz_hamiltonian.html#hardware-efficient-ansatz",
    "href": "examples/variational_methods/vqe_custom_ansatz_hamiltonian.html#hardware-efficient-ansatz",
    "title": "Tangelo VQE: Custom Ansatz and qubit Hamiltonian Tutorial",
    "section": "Hardware Efficient Ansatz",
    "text": "Hardware Efficient Ansatz\nFor our example, we’re going to implement the so-called Hardware Efficient Ansatz (HEA), developed by Kandala et al at IBM. In this ansatz, a circuit is constructed with repeated layers of a simple structure. Each layer consists of entangling gates (e.g. CNOT or CZ) which couple neighbouring qubits, followed by a series of Euler rotations carried out as single-qubit rotations \\(\\mathrm{exp}\\{i\\theta_i^1 Z_i\\}\\mathrm{exp}\\{i\\theta_i^2 X_i\\}\\mathrm{exp}\\{i\\theta_i^3 Z_i\\}\\). We’ll start by initializing our Ansatz class, and then fill in the functionality required to implement this ansatz in VQESolver.\nTo construct our HEA ansatz, we’re going to make use of the three helper functions defined here. The first will go through a register of qubits and add a layer of Euler-rotations as prescribed above. The second adds two columns of alternating CNOT gates, establishing long-range entanglement. The third brings these together into a sequence of alternating entanglers and Euler rotations.\n\ndef EulerCircuit(n_qubits):\n    \"\"\"Construct a circuit applying an Euler Z-X-Z rotation to each qubit.\"\"\"\n    circuit = Circuit()\n    for target in range(n_qubits):\n        circuit.add_gate(Gate(\"RZ\" , target, parameter=0.0, is_variational=True))\n        circuit.add_gate(Gate(\"RX\", target, parameter=0.0, is_variational=True))\n        circuit.add_gate(Gate(\"RZ\", target, parameter=0.0, is_variational=True))\n    return circuit\n\ndef EntanglerCircuit(n_qubits):\n    \"\"\"Construct a circuit applying two columns of staggered CNOT gates to all qubits\n     and their neighbours\"\"\"\n    circuit = Circuit()\n    for ii in range(n_qubits//2):\n        circuit.add_gate(Gate(\"CNOT\", control=2*ii, target=2*ii + 1))\n    for ii in range(n_qubits//2 - 1):\n        circuit.add_gate(Gate(\"CNOT\", control=2*ii + 1, target=2*(ii+1)))\n    return circuit\n\ndef HEACircuit(n_qubits, n_layers):\n    \"\"\"Construct a circuit consisting of alternating sequence of Euler rotations and entanglers\"\"\"\n    circuit = EulerCircuit(n_qubits)\n    for ii in range(n_layers):\n        circuit += EntanglerCircuit(n_qubits)\n        circuit += EulerCircuit(n_qubits)\n    return circuit"
  },
  {
    "objectID": "examples/variational_methods/vqe_custom_ansatz_hamiltonian.html#ansatz-class",
    "href": "examples/variational_methods/vqe_custom_ansatz_hamiltonian.html#ansatz-class",
    "title": "Tangelo VQE: Custom Ansatz and qubit Hamiltonian Tutorial",
    "section": "Ansatz Class",
    "text": "Ansatz Class\nIn the VQESolver, we are expecting an instance of an abstract Ansatz class, which will be responsible for constructing the variational circuit we use to minimize the energy of our problem. To build up our own Ansatz class, we’ll require the following.\n\ninit: an initialization function to instantiate the class.\nset_var_params: initialize the variational circuit parameters\nupdate_var_params: update the parametric gates in the circuit\nprepare_reference_state: get fixed circuit for initializing the reference, e.g. HF state.\nbuild_circuit: instantiate the variational circuit object\n\nBelow, we’re going to type out the entire class as we will use it. This is a lot of code in one place. So afterwards, we’ll break it down into each of the relevant member methods.\n\nclass HEA(Ansatz):\n\n    def __init__(self, n_spinorbitals, n_electrons, n_layers, mapping='jw'):\n\n        self.n_spinorbitals = n_spinorbitals\n        self.n_qubits = get_qubit_number(mapping, n_spinorbitals)\n        self.n_electrons = n_electrons\n        #number of layers of repeated entangler + Euler rotations\n        self.n_layers = n_layers\n        \n        #specify fermion-to-qubit mapping (required for the initial reference state)\n        self.mapping = mapping\n        \n        #Each layer has 3 variational parameters per qubit, and one non-variational entangler\n        #There is an additional layer with no entangler.\n        self.n_var_params = self.n_qubits * 3 * (self.n_layers + 1)\n\n        self.var_params = None\n        self.circuit = None\n\n    def set_var_params(self, var_params=None):\n        \"\"\"Set initial variational parameter values\"\"\"\n        if var_params is None:\n            var_params = np.random.random(self.n_var_params)\n        elif var_params == \"ones\":\n            var_params = np.ones(self.n_var_params, dtype=float)\n        elif len(var_params) != self.n_var_params:\n            raise ValueError('Invalid number of parameters.')\n        self.var_params = var_params\n        return var_params\n\n    def update_var_params(self, var_params):\n        \"\"\"Update variational parameters (done repeatedly during VQE)\"\"\"\n        for param_index in range(self.n_var_params):\n            self.circuit._variational_gates[param_index].parameter = var_params[param_index]\n    \n    def prepare_reference_state(self):\n        \"\"\"Prepare a circuit generating the HF reference state.\"\"\"\n        return get_reference_circuit(n_spinorbitals=self.n_spinorbitals, n_electrons=self.n_electrons,mapping=self.mapping)\n\n    def build_circuit(self, var_params=None):\n        \"\"\"Construct the variational circuit to be used as our ansatz.\"\"\"\n        self.var_params = self.set_var_params(var_params)\n\n        reference_state_circuit = self.prepare_reference_state()\n        hea_circuit = HEACircuit(self.n_qubits, self.n_layers)\n\n        if reference_state_circuit.size != 0:\n            self.circuit = reference_state_circuit + hea_circuit\n        else:\n            self.circuit = hea_circuit\n        return self.circuit\n\nVery briefly, we’ll go through the member methods required to construct an Ansatz class. These code blocks duplicate the code above. We emphasize here that these member functions can be really as simple or as elaborate as you like.\nLet’s start with set_var_params. We’re going to do something very basic and just force this to be a random or all ones numpy array. We add some error handling in case the number of parameters is incompatible with the number of variational gates in the ansatz circuit. Have a look at the implementation of UCCSD to see how you can make this more fancy and interesting.\n\ndef set_var_params(self, var_params=None):\n\n    if var_params is None:\n        var_params = np.random.random(self.n_var_params)\n    elif var_params == \"ones\":\n        var_params = np.ones(self.n_var_params, dtype=float)\n    elif len(var_params) != self.n_var_params:\n        raise ValueError('Invalid number of parameters.')\n    self.var_params = var_params\n    return var_params\n\nNext, we’ll implement update_var_params, where the circuit is updated with a new batch of variational parameters. The tangelo.linq Circuit class keeps a record of the variational gates in the circuit, making this update very straightforward, and avoids having to rebuild the circuit from scratch. All variational gates in the circuit are updated as per the var_params argument.\n\ndef update_var_params(self, var_params):\n    for param_index in range(self.n_var_params):\n        self.circuit._variational_gates[param_index].parameter = var_params[param_index]\n\nNext, we’ll use the methods from the qubit_mappings toolbox to construct a Hartree-Fock reference state. This will just generate a circuit with an X-gate applied to each qubit which we want to begin in the \\(|1\\rangle\\) state.\n\ndef prepare_reference_state(self):\n    circuit = get_reference_circuit(n_spinorbitals=self.n_spinorbitals, n_electrons=self.n_electrons, mapping=self.mapping)\n    return circuit\n\nFinally, we’ll implement the build_circuit method. As compared to the three others here, this is really the only method in the present case that requires much effort–everything else above has followed pretty boilerplate code. For this, we’re just going to alternate between entanglers and Euler rotations, using the HEACircuit helper function we defined earlier. We then combine this with the Hartree Fock reference circuit. In the event that no qubits are instantiated as \\(|1\\rangle\\), we skip this empty reference circuit.\n\ndef build_circuit(self, var_params=None):\n    \"\"\"Construct the variational circuit to be used as our ansatz.\"\"\"\n    self.var_params = self.set_var_params(var_params)\n\n    reference_state_circuit = self.prepare_reference_state()\n    hea_circuit = HEACircuit(self.n_qubits, self.n_layers)\n\n    if reference_state_circuit.size != 0:\n        self.circuit = reference_state_circuit + hea_circuit\n    else:\n        self.circuit = hea_circuit\n    return self.circuit"
  },
  {
    "objectID": "examples/variational_methods/vqe_custom_ansatz_hamiltonian.html#using-a-molecule-object-as-input",
    "href": "examples/variational_methods/vqe_custom_ansatz_hamiltonian.html#using-a-molecule-object-as-input",
    "title": "Tangelo VQE: Custom Ansatz and qubit Hamiltonian Tutorial",
    "section": "Using a molecule object as input",
    "text": "Using a molecule object as input\n\nH2 = [('H', (0, 0, 0)),('H', (0, 0, 0.74137727))]\nmol_H2 = SecondQuantizedMolecule(H2, q=0, spin=0, basis=\"sto-3g\")\n\nWith this molecule prepared, we’re ready to instantiate our ansatz, and feed it into VQE. I’ll access details of the molecule required to build our ansatz circuit (i.e. number of spin-orbitals and number of electrons) from the molecule object. Feel free to change the number of layers in the circuit, and explore how this changes VQE results, and timing.\n\nn_spinorbitals = mol_H2.n_active_sos\nn_electrons = mol_H2.n_active_electrons\nhea_layers = 4\nHEA_ansatz = HEA(n_spinorbitals=n_spinorbitals, n_electrons=n_electrons, n_layers=hea_layers)\n\nFinally, we can instantiate the VQESolver, and run. We have decided to initialize all the variational parameters to ones through an option supported in the set_var_params of our HEA ansatz class.\n\nvqe_options = {\"molecule\": mol_H2, \"qubit_mapping\": 'JW', 'ansatz': HEA_ansatz, \"initial_var_params\": \"ones\"}\n\nHEA_VQE = VQESolver(vqe_options)\nHEA_VQE.build()\nHEA_VQE.simulate()\n\n/tmp/ipykernel_46116/549362070.py:25: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\n  elif var_params == \"ones\":\n\n\n-1.1372335845006827"
  },
  {
    "objectID": "examples/variational_methods/vqe_custom_ansatz_hamiltonian.html#using-a-custom-qubit-operator-as-input",
    "href": "examples/variational_methods/vqe_custom_ansatz_hamiltonian.html#using-a-custom-qubit-operator-as-input",
    "title": "Tangelo VQE: Custom Ansatz and qubit Hamiltonian Tutorial",
    "section": "Using a custom qubit operator as input",
    "text": "Using a custom qubit operator as input\nVQESolver can also directly take as input a custom qubit operator instead of computing a Hamiltonian starting from a molecule. This situation can be relevant in the case where one wants to perform VQE using a qubit Hamiltonian: * That does not correspond to a molecular system; * That has been tailored by the user (to reduce complexity or to study something specific); * That is too expensive to recompute.\nAs written in the previous section, it is possible to get the same result by providing VQESolver with a qubit Hamiltonian instead of a molecule. First, let’s store the optimal variational parameters to use them as a starting point for comparison.\nNext step is to generate the qubit Hamiltonian. With the help of MolecularData and fermion_to_qubit_mapping, we are able to generate a fermionic Hamiltonian and transform it into operations doable on a quantum computer.\n\nfermionic_hamiltonian_H2 = mol_H2.fermionic_hamiltonian\nqubit_hamiltonian_H2 = fermion_to_qubit_mapping(fermionic_hamiltonian_H2, mapping=\"jw\", n_spinorbitals=n_spinorbitals, n_electrons=n_electrons)\nprint(qubit_hamiltonian_H2)\n\n(-0.09883484730799569+0j) [] +\n(-0.045321883918106265+0j) [X0 X1 Y2 Y3] +\n(0.045321883918106265+0j) [X0 Y1 Y2 X3] +\n(0.045321883918106265+0j) [Y0 X1 X2 Y3] +\n(-0.045321883918106265+0j) [Y0 Y1 X2 X3] +\n(0.17120123806595938+0j) [Z0] +\n(0.16862327595071586+0j) [Z0 Z1] +\n(0.12054612740556847+0j) [Z0 Z2] +\n(0.16586801132367474+0j) [Z0 Z3] +\n(0.1712012380659594+0j) [Z1] +\n(0.16586801132367474+0j) [Z1 Z2] +\n(0.12054612740556847+0j) [Z1 Z3] +\n(-0.22279639651093203+0j) [Z2] +\n(0.17434948757007068+0j) [Z2 Z3] +\n(-0.22279639651093203+0j) [Z3]\n\n\nNotes: Users can directly retrieve the qubit Hamiltonian object used in VQESolver by accessing its qubit_hamiltonian attribute.\nThe dihydrogen molecule ground state energy is computed again from this qubit Hamiltonian (which is identical to the one used in the first part computed from the molecule).\n\nvqe_alternative_options = {\"qubit_hamiltonian\": qubit_hamiltonian_H2, 'ansatz': HEA_ansatz, \"initial_var_params\": \"ones\"}\n\nHEA_VQE_HAMILTONIAN = VQESolver(vqe_alternative_options)\nHEA_VQE_HAMILTONIAN.build()\nHEA_VQE_HAMILTONIAN.simulate()\n\n/tmp/ipykernel_46116/549362070.py:25: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\n  elif var_params == \"ones\":\n\n\n-1.1372335845006827\n\n\nThe behaviour of VQE is identical to the previous one. Regarding chemical accuracy, how well did we do here? Let’s compare against Hartree Fock and FCI.\n\nenergy_fci = FCISolver(mol_H2).simulate()\nenergy_hf = mol_H2.mf_energy\nenergy_vqe = HEA_VQE.optimal_energy\nenergy_vqe_hamiltonian = HEA_VQE_HAMILTONIAN.optimal_energy\nprint(f'FCI ENERGY: {energy_fci :.7f} Ha')\nprint(f'HF ENERGY: {energy_hf :.7f} Ha')\nprint(f'HEA-VQE ENERGY (from molecule): {energy_vqe :.7f} Ha')\nprint(f'HEA-VQE ENERGY (from qubit Hamiltonian): {energy_vqe_hamiltonian :.7f} Ha')\n\nFCI ENERGY: -1.1372704 Ha\nHF ENERGY: -1.1166856 Ha\nHEA-VQE ENERGY (from molecule): -1.1372336 Ha\nHEA-VQE ENERGY (from qubit Hamiltonian): -1.1372336 Ha"
  },
  {
    "objectID": "examples/variational_methods/vqe_custom_ansatz_hamiltonian.html#using-a-custom-circuit-as-input",
    "href": "examples/variational_methods/vqe_custom_ansatz_hamiltonian.html#using-a-custom-circuit-as-input",
    "title": "Tangelo VQE: Custom Ansatz and qubit Hamiltonian Tutorial",
    "section": "Using a custom circuit as input",
    "text": "Using a custom circuit as input\nLastly, it is possible to pass a pre-built arbitrary circuit with variational gates as input to VQESolver. In that case, VQESolver will optimize the variational parameters of these gates in order to minimize the cost function, which still requires a qubit Hamiltonian. This situation can be relevant to users who wish to apply variational approaches to arbitrary circuits or a circuit they got from other collaborators.\n\ncircuit = HEA_ansatz.build_circuit()\nprint(circuit)\n\nCircuit object. Size 74 \n\nX         target : [0]   \nX         target : [1]   \nRZ        target : [0]   parameter : 0.0     (variational)\nRX        target : [0]   parameter : 0.0     (variational)\nRZ        target : [0]   parameter : 0.0     (variational)\nRZ        target : [1]   parameter : 0.0     (variational)\nRX        target : [1]   parameter : 0.0     (variational)\nRZ        target : [1]   parameter : 0.0     (variational)\nRZ        target : [2]   parameter : 0.0     (variational)\nRX        target : [2]   parameter : 0.0     (variational)\nRZ        target : [2]   parameter : 0.0     (variational)\nRZ        target : [3]   parameter : 0.0     (variational)\nRX        target : [3]   parameter : 0.0     (variational)\nRZ        target : [3]   parameter : 0.0     (variational)\nCNOT      target : [1]   control : [0]   \nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nRZ        target : [0]   parameter : 0.0     (variational)\nRX        target : [0]   parameter : 0.0     (variational)\nRZ        target : [0]   parameter : 0.0     (variational)\nRZ        target : [1]   parameter : 0.0     (variational)\nRX        target : [1]   parameter : 0.0     (variational)\nRZ        target : [1]   parameter : 0.0     (variational)\nRZ        target : [2]   parameter : 0.0     (variational)\nRX        target : [2]   parameter : 0.0     (variational)\nRZ        target : [2]   parameter : 0.0     (variational)\nRZ        target : [3]   parameter : 0.0     (variational)\nRX        target : [3]   parameter : 0.0     (variational)\nRZ        target : [3]   parameter : 0.0     (variational)\nCNOT      target : [1]   control : [0]   \nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nRZ        target : [0]   parameter : 0.0     (variational)\nRX        target : [0]   parameter : 0.0     (variational)\nRZ        target : [0]   parameter : 0.0     (variational)\nRZ        target : [1]   parameter : 0.0     (variational)\nRX        target : [1]   parameter : 0.0     (variational)\nRZ        target : [1]   parameter : 0.0     (variational)\nRZ        target : [2]   parameter : 0.0     (variational)\nRX        target : [2]   parameter : 0.0     (variational)\nRZ        target : [2]   parameter : 0.0     (variational)\nRZ        target : [3]   parameter : 0.0     (variational)\nRX        target : [3]   parameter : 0.0     (variational)\nRZ        target : [3]   parameter : 0.0     (variational)\nCNOT      target : [1]   control : [0]   \nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nRZ        target : [0]   parameter : 0.0     (variational)\nRX        target : [0]   parameter : 0.0     (variational)\nRZ        target : [0]   parameter : 0.0     (variational)\nRZ        target : [1]   parameter : 0.0     (variational)\nRX        target : [1]   parameter : 0.0     (variational)\nRZ        target : [1]   parameter : 0.0     (variational)\nRZ        target : [2]   parameter : 0.0     (variational)\nRX        target : [2]   parameter : 0.0     (variational)\nRZ        target : [2]   parameter : 0.0     (variational)\nRZ        target : [3]   parameter : 0.0     (variational)\nRX        target : [3]   parameter : 0.0     (variational)\nRZ        target : [3]   parameter : 0.0     (variational)\nCNOT      target : [1]   control : [0]   \nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nRZ        target : [0]   parameter : 0.0     (variational)\nRX        target : [0]   parameter : 0.0     (variational)\nRZ        target : [0]   parameter : 0.0     (variational)\nRZ        target : [1]   parameter : 0.0     (variational)\nRX        target : [1]   parameter : 0.0     (variational)\nRZ        target : [1]   parameter : 0.0     (variational)\nRZ        target : [2]   parameter : 0.0     (variational)\nRX        target : [2]   parameter : 0.0     (variational)\nRZ        target : [2]   parameter : 0.0     (variational)\nRZ        target : [3]   parameter : 0.0     (variational)\nRX        target : [3]   parameter : 0.0     (variational)\nRZ        target : [3]   parameter : 0.0     (variational)\n\n\n\nThe dihydrogen energy is recomputed for the third time by using its qubit Hamiltonian and the abstract circuit provided. We are here optimizing the variational parameters of the pre-built circuit, in an attempt to return the minimal energy for this ansatz.\n\nvqe_second_alternative_options = {\"qubit_hamiltonian\": qubit_hamiltonian_H2, \"ansatz\": circuit, \"initial_var_params\": \"random\"}\n\nHEA_VQE_CIRCUIT = VQESolver(vqe_second_alternative_options)\nHEA_VQE_CIRCUIT.build()\nHEA_VQE_CIRCUIT.simulate()\n\n-1.1370682042984708\n\n\nNote: Users may also give VQESolver a SecondQuantizedMolecule with a custom circuit. The energy at the end is the very same as the previous calculations with a molecule + custom ansatz and a qubit Hamiltonian.\n\nenergy_vqe_circuit = HEA_VQE_CIRCUIT.optimal_energy\nprint(f'HEA-VQE ENERGY (from a circuit): {energy_vqe_circuit :.7f} Ha')\n\nHEA-VQE ENERGY (from a circuit): -1.1370682 Ha"
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html",
    "href": "examples/hardware_experiments/umbrella_inversion.html",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "",
    "text": "# Download data files and images for this notebook\n!wget https://github.com/goodchemistryco/Tangelo-Examples/raw/main/examples/img/umbrella_inversion_H3Op.png --quiet\n!wget https://github.com/goodchemistryco/Tangelo-Examples/raw/main/examples/hardware_experiments/data/umbrella_inversion.zip --quiet\n!unzip -qq umbrella_inversion.zip\n# Install Tangelo with pip, from the develop branch on Github\n!pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet\n\n# Install an optional simulator backend (ex: Qulacs)\n!pip install qulacs --quiet"
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#table-of-contents",
    "href": "examples/hardware_experiments/umbrella_inversion.html#table-of-contents",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "Table of contents:",
    "text": "Table of contents:\n\n1 Introduction\n2 The umbrella inversion\n3 Reduce problem size with MI-FNO\n3.1 Generate the MIFNO fragments\n3.2 Import fragment data\n4 Explore quantum workflows with Tangelo\n4.1 ADAPT VQE circuit\n4.2 Simulate the noisy quantum device\n5.1 Preparing and running a quantum experiment on Amazon Braket\n5.2 Construct classical shadow and purify\n5.3 Energy resummation and plot\n6 Bonus: Nuclear Dynamics Simulation"
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#introduction",
    "href": "examples/hardware_experiments/umbrella_inversion.html#introduction",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "1 Introduction ",
    "text": "1 Introduction \nIn this notebook we present an experimental study of the umbrella inversion on a quantum computer using Tangelo, Amazon Braket, and QEMIST Cloud. A blog post about this study is available on Amazon’s Quantum Blog.\nThe umbrella inversion is a quantum effect related to tunnelling, that can be that can be observed in many organic molecules with a free electron pair residing on a trivalent atom. These include amines containing a nitrogen centre but it can also be observed in hydronium H\\(_3\\)O\\(^+\\), in which the central atom is oxygen. We start our experiment setup by defining the hydronium molecule, and choosing a the chemical basis cc-pVDZ for our calculation.\n\natoms = \"\"\"\nO    -0.63100    1.21783    0.07611\nH     0.34564    1.31652   -0.02093\nH    -0.97483    1.78491    0.80631\nH    -0.88121    0.27338    0.21147\n\"\"\"\n\ncharge = 1\nspin = 0\nbasis = \"cc-pVDZ\""
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#the-umbrella-inversion",
    "href": "examples/hardware_experiments/umbrella_inversion.html#the-umbrella-inversion",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "2 The umbrella inversion ",
    "text": "2 The umbrella inversion \nLet’s illustrate the umbrella inversion using the hydronium molecule. We first define a function that can vary the molecular geometry as the positions of the hydrogen atoms change around the oxygen centre. This can be parameterized in terms of a single angle between the H-O bond and the molecule’s main rotational axis. To simplify the problem, we assume the bond length does not depend on the angle, and is equal to 0.986\\(\\overset{\\circ}{A}\\).\n\ndef H3O_angle(theta):\n    d = 0.986\n    theta = theta*np.pi/180\n    C, S = np.cos(theta), np.sin(theta)\n    c, s = np.cos(np.pi/3), np.sin(np.pi/3)\n    H_pos = d*np.array([[   S,    0, C],\n                        [-S*c,  S*s, C],\n                        [-S*c, -S*s, C]])\n    return [[\"O\", (0.,0.,0.)], [\"H\", tuple(H_pos[0])], [\"H\", tuple(H_pos[1])], [\"H\", tuple(H_pos[2])]]\n\nWe calculate the energy of the molecule for a range of angles. Here, we limit ourselves to the Hartree-Fock solution. We build the system as a SecondQuantizedMolecule object, which automatically calculates the mean-field energy.\n\nimport numpy as np\n\nfrom tangelo import SecondQuantizedMolecule\n\ntheta = np.linspace(60, 120, 31)\nrhf = []\n\nfor t in theta:\n    mol_theta = SecondQuantizedMolecule(H3O_angle(t), q=charge, spin=spin, basis=basis)\n    rhf.append(mol_theta.mean_field.e_tot)\n\nPlotting the results below we see the double well potential of the umbrella curve, showing two geometries with optimal ground state energies the system may tunnel between. This tunelling corresponds to the electron pair flipping from one side of the oxygen atom to the other - or equivalenty, the hydrogen atoms moving from one side to the other.\n\nimport pylab as plt\n\nplt.plot(theta, rhf)\nplt.xlabel(\"Angle [deg]\")\nplt.ylabel(\"Energy [Ha]\")\n\nText(0, 0.5, 'Energy [Ha]')"
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#reduce-problem-size-with-mi-fno",
    "href": "examples/hardware_experiments/umbrella_inversion.html#reduce-problem-size-with-mi-fno",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "3 Reduce problem size with MI-FNO ",
    "text": "3 Reduce problem size with MI-FNO \nStudying the umbrella inversion by tackling this chemical system head-on is well beyond the capabilities of current quantum computers. For instance, a straightforward approach using the Variational Quantum Eigensolver (VQE) algorithm with the UCCSD ansatz would yield circuits requiring over 50 qubits, millions of gates, and hundreds of thousands variational parameters. Numerical results would be drown in noise. In order to explore this problem with quantum computing, a more sophisticated workflow is necessary.\nThis section describes how tools such as QEMIST Cloud and Tangelo can be combined to extend the range of chemical systems that can be explored with nascent quantum devices. The MI-FNO method available in QEMIST cloud can be employed to decompose the initial problem into a collection of smaller subproblems (“fragments”), whose resolution requires less computational resources. These approaches are also commonly referred to as “fragmentation” or “embedding” techniques.\nFor our quantum experiment, we attempt to solve one of these subproblems using a quantum workflow. We then analyze the results and assess the difference in total energy between our quantum experiment and the fully classical calculations.\nIn the first part, we show how to apply MI-FNO to the system of interest and compute classical reference values. We then show how to import them into Tangelo, to enable our quantum exploration."
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#generate-the-mi-fno-fragments",
    "href": "examples/hardware_experiments/umbrella_inversion.html#generate-the-mi-fno-fragments",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "3.1 Generate the MI-FNO fragments ",
    "text": "3.1 Generate the MI-FNO fragments \nThe following code excerpt illustrates how QEMIST Cloud users can perform a MI-FNO decomposition using our client library, and obtain reference results computed with our classical solvers.\nHere we define a molecule object, and then our approach, based on combining the Heat-Bath Configuration interaction (HBCI) classical solver, the Method of Increments (MI) and the Frozen Natural Orbitals (FNO) method for the virtual space cutoff. We request an estimate of the cost of the simulation and then perform it.\nTo simplify this notebook, the results of this simulation have been precomputed and provided. The code snippets are available below, but were not designed to be run in this notebook as QEMIST Cloud is not yet publically available at the time of writing.\nimport os\nos.environ['QEMIST_PROJECT_ID'] = \"your-project-ID\"\nos.environ['QEMIST_AUTH_TOKEN'] = \"your-authentication-token\"\n\nfrom qemist_client.molecule import Molecule\nfrom qemist_client.problem_decomposition import IncrementalDecomposition\nfrom qemist_client.problem_reduction import FNO\nfrom qemist_client.electronic_structure_solvers import HBCI\nfrom qemist_client.util import get_results, check_problem_cost\n\nqemist_mol = Molecule(atoms, basis=basis, charge=charge, spin=spin)\n\nhbci_solver = HBCI()\nfno = FNO(hbci_solver, export_fragment_data=True)\nmi_solver = IncrementalDecomposition(electronic_structure_solver=fno, \n                                     truncation_order=3, \n                                     method_of_truncation_threshold=5e-3)\n\n# Request a cost estimate of the simulation beforehand\ncost = check_problem_cost(qemist_mol, mi_solver)\n\n# Submit the problem to QEMIST Cloud\nhandle = mi_solver.simulate(system=qemist_mol)\nThe following code exports the fragment data resulting from the QEMIST Cloud simulation, later to be imported into Tangelo.\n\nimport json\n\npath = \"./data_H3O_ccpvdz_mifno_hbci/\"\njfile = \"H3O_CCPVDZ_MIFNO_HBCI.json\"\n\n# Retrieve results using handle\nqemist_res = get_results(handle)\n\n# Export subproblem data to individual files\nwith open(path + jfile, \"w\") as f:\n    json.dump(qemist_res, f)\n    \nfor n_trunc, frags in qemist_res[\"subproblem_data\"].items():\n    for frag_id, frag in frags.items():\n        prob_handle = frag[\"problem_handle\"]\n\n        if prob_handle:\n            frag_res = get_results(prob_handle)\n\n            with open(path + f\"/{prob_handle}.json\", \"w\") as f:\n                json.dump(frag_res, f)"
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#import-fragment-data",
    "href": "examples/hardware_experiments/umbrella_inversion.html#import-fragment-data",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "3.2 Import fragment data ",
    "text": "3.2 Import fragment data \nWe import the data resulting from the simulation run by QEMIST Cloud into Tangelo and prepare the quantum experiment using the fragment data. The MIFNOHelper class provided by Tangelo handles most of the work.\nPrinting the resulting object displays reference energies computed by QEMIST Cloud, as well as the breakdown of the fragments and how they contribute to the energy the system. We find out that the initial problem was broken into: - 4 1-body fragments - 6 2-body fragments - 4 3-body fragments\nThese subproblems contribute differently to the total energy of the system and their computational complexity vary. This information can guide us in selecting subproblems that are relevant to current quantum devices or quantum algorithms.\nThis exploration is currently done manually, with the purpose of research in mind. As advances in quantum hardware and algorithms are made, automated scheduling and streamlined execution of relevant subproblems on quantum devices through QEMIST Cloud could become a reality.\n\nfrom tangelo.problem_decomposition import MIFNOHelper\n\n# Read the results from the json files\nfno_fragments = MIFNOHelper(mi_json_file=path+jfile, fno_json_folder=path)\nprint(fno_fragments)\n\n# Import MO coeffs\nfno_fragments.retrieve_mo_coeff(path)\n\n(All the energy values are in hartree)\nTotal MI-FNO energy = -76.52019103159677\nCorrelation energy = -0.2093647955082076\nMean-field energy = -76.31082623608856\n            epsilon  energy_total  correction  energy_correlation\n(1,)      -0.027343    -76.338169   -0.009120           -0.027343\n(2,)      -0.027344    -76.338170   -0.009120           -0.027344\n(3,)      -0.027344    -76.338170   -0.009120           -0.027344\n(4,)      -0.017714    -76.328540   -0.017714           -0.017714\n(1, 2)    -0.016601    -76.382115   -0.026852           -0.071288\n(1, 3)    -0.016601    -76.382115   -0.026852           -0.071288\n(1, 4)    -0.024389    -76.380272   -0.029541           -0.069446\n(2, 3)    -0.016602    -76.382116   -0.026852           -0.071290\n(2, 4)    -0.024390    -76.380274   -0.029541           -0.069448\n(3, 4)    -0.024390    -76.380274   -0.029541           -0.069448\n(1, 2, 3)  0.000446    -76.442216   -0.052484           -0.131389\n(1, 2, 4)  0.004302    -76.444305   -0.057833           -0.133479\n(1, 3, 4)  0.004302    -76.444305   -0.057833           -0.133479\n(2, 3, 4)  0.004302    -76.444307   -0.057833           -0.133481\n\n\nWe choose fragment (2,), one of the one-body fragments listed above, as the focus of our quantum experiment. The code cell below constructs its Hamiltonian and maps it into qubit form using the scBK mapping. This yields a two-qubit problem which can be easily fitted on any quantum device. The Hamiltonian only involves X and Z Pauli operators, which means we only need to run simulations in a handful of measurement bases, as shown below.\nYou can try selecting a different fragment and see what qubit Hamiltonian comes out of it. For instance, some 3-body fragments yield Hamiltonians mapped to 12 qubits (10 if using scBK for the mapping).\n\nfrom tangelo.toolboxes.qubit_mappings.mapping_transform import fermion_to_qubit_mapping\n\n# Select fragment of interest.\nselected_fragment = \"(2,)\"\n\nfrozen_orbitals = fno_fragments[selected_fragment][\"frozen_orbitals_truncated\"]\ncorrection = fno_fragments[selected_fragment][\"correction\"]\ne_tot_frag = fno_fragments[selected_fragment][\"energy_total\"]\n\n# Create molecule object for fragment, and compute the molecular integrals.\nmol = SecondQuantizedMolecule(atoms, q=charge, spin=spin, basis=basis, frozen_orbitals=frozen_orbitals)\n\n# Selection of a fragment and computing the related FermionOperator.\nferm_op = fno_fragments.compute_fermionoperator(mol, selected_fragment)\nferm_op.n_electrons, ferm_op.n_spinorbitals = fno_fragments.n_electrons_spinorbs(selected_fragment)\nferm_op.spin = spin\n\n# Map FermionOperator to QubitOperator.\nn_electrons, n_spinorbitals = fno_fragments.n_electrons_spinorbs(selected_fragment)\nqu_op = fermion_to_qubit_mapping(ferm_op, mapping=\"scbk\", n_spinorbitals=n_spinorbitals, n_electrons=n_electrons)\n\nprint(qu_op)\n\n-75.03707306024805 [] +\n0.025894296540557086 [X0] +\n0.21772992233328325 [X0 X1] +\n0.025894165002379746 [X0 Z1] +\n0.6466599564486686 [Z0] +\n0.025894165002379746 [Z0 X1] +\n0.0195667370570633 [Z0 Z1] +\n0.02589429654055709 [X1] +\n0.6466599564486686 [Z1]"
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#explore-quantum-workflows-with-tangelo",
    "href": "examples/hardware_experiments/umbrella_inversion.html#explore-quantum-workflows-with-tangelo",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "4 Explore quantum workflows with Tangelo ",
    "text": "4 Explore quantum workflows with Tangelo \nA number of quantum solvers are available in Tangelo. In order to design an interesting quantum experiment, we need to do some exploration and try to find an approach with reasonable compute requirements (number of qubits, number of gate operations, number of measurements, etc). This section first shows how we investigated an approach based on ADAPT-VQE using an exact simulator, and then attempted to account for the presence of noise for the target quantum device."
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#adapt-vqe-circuit",
    "href": "examples/hardware_experiments/umbrella_inversion.html#adapt-vqe-circuit",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "4.1 ADAPT VQE circuit ",
    "text": "4.1 ADAPT VQE circuit \nHere we use the ADAPT ansatz with a pool of operators defined using Qubit Coupled Cluster (QCC) by constructing a Direct Inversion Set (DIS) from a qubit Hamiltonian. For our use case, this approach results in a shallow circuit that is within current quantum devices capabilities.\nMore algorithms are available in Tangelo, each supporting a number of built-in options and user customization: we invite you to explore them.\n\nfrom tangelo.toolboxes.ansatz_generator._qubit_cc import construct_dis\nfrom tangelo.toolboxes.ansatz_generator._qubit_mf import init_qmf_from_hf\n\ndef qcc_pool(mol: SecondQuantizedMolecule, mapping, up_then_down, qubit_hamiltonian):\n    qmf_var_params = init_qmf_from_hf(mol.n_active_sos, mol.n_active_electrons, \n                                      mapping, up_then_down, mol.spin)\n    dis = construct_dis(qubit_hamiltonian, qmf_var_params, 0.)\n    dis_flat = [item for sublist in dis for item in sublist]\n    return dis_flat\n\n\nfrom tangelo.algorithms import ADAPTSolver\n\npool_args = {\"mol\": mol, \"mapping\": \"scbk\", \"up_then_down\": True, \"qubit_hamiltonian\": qu_op}\nopt_dict = {\"qubit_hamiltonian\": qu_op, \"tol\": 0.01, \"max_cycles\": 5,\n            \"qubit_mapping\": \"scbk\", \"n_spinorbitals\": n_spinorbitals, \"n_electrons\": n_electrons, \n            \"spin\": spin, \"pool\": qcc_pool, \"pool_args\": pool_args}\n\nadapt_solver = ADAPTSolver(opt_dict)\nadapt_solver.build()\nadapt_solver.simulate()\n\nadapt_circ = adapt_solver.vqe_solver.optimal_circuit\n\n/usr/local/lib/python3.9/dist-packages/tangelo/toolboxes/qubit_mappings/statevector_mapping.py:149: RuntimeWarning: Symmetry-conserving Bravyi-Kitaev enforces all spin-up followed by all spin-down ordering.\n  warnings.warn(\"Symmetry-conserving Bravyi-Kitaev enforces all spin-up followed by all spin-down ordering.\", RuntimeWarning)\n\n\nA quick look at the ADAPT circuit resulting from the code above. It is shallow enough for the current quantum devices.\n\nadapt_circ.draw()\n\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found.\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found.\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found.\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found.\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found.\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found.\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found.\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found.\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found.\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found.\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found.\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found.\nWARNING:matplotlib.font_manager:findfont: Font family 'Arial' not found."
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#optional-simulate-the-noisy-quantum-device",
    "href": "examples/hardware_experiments/umbrella_inversion.html#optional-simulate-the-noisy-quantum-device",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "4.2 Optional: Simulate the noisy quantum device ",
    "text": "4.2 Optional: Simulate the noisy quantum device \nWe can run the circuit on a noisy simulator and recompute the fragment energy to get some idea of what to expect before we commit to running a full experiment, which costs money and time.\nBelow we define a noise model based on specifications of the IonQ Harmony device, which is the machine we considered for running our experiment. The data used came from the Amazon Braket device page, during summer 2022.\n\nfrom tangelo.linq.noisy_simulation import NoiseModel\n\n# Define 1- and 2-qubit gate error  (Based on Braket dashboard)\nn1q = 1 - 0.9953\nn2q = 1 - 0.9394\n\n# Build a simple depolarization model using the gates in our circuit\nnmd = NoiseModel()\nnmd.add_quantum_error(\"CNOT\", \"depol\", n2q)\nfor gate in [\"RX\", \"RZ\", \"X\", \"H\"]:\n    nmd.add_quantum_error(gate, \"depol\", n1q)\n\nAs with quantum hardware, we need to append the circuit with measurement basis gates before submitting them to a device or simulator. In the case of the selected 1-body fragment, we would need to acquire measurements in the four bases specified below, as the terms in the Hamiltonian only commute with these.\n\nfrom tangelo.linq import Circuit\nfrom tangelo.linq.helpers.circuits import measurement_basis_gates, pauli_string_to_of\n\ncircs = []\nbasis_list = [\"ZZ\", \"XZ\", \"ZX\", \"XX\"]\n\nfor b in basis_list:\n    c = adapt_circ.copy()\n    c += Circuit(measurement_basis_gates(pauli_string_to_of(b)))\n    circs.append(c)\n\nWe perform a noisy simulation of the four circuits and obtain the corresponding frequency histograms, here using Cirq as a backend.\n\nfrom tangelo.linq import get_backend\n\nsim = get_backend(\"cirq\", n_shots=10**6, noise_model=nmd)\nhists = [sim.simulate(c)[0] for c in circs]\n\nWe can then use them to compute the expectation value for the energy of the fragment. We employ histogram aggregation to use all available data for the terms that can be computed from more than one measurement basis. The Histogram class facilitates these steps.\n\nfrom tangelo.toolboxes.post_processing.histogram import Histogram, aggregate_histograms\nfrom tangelo.linq.helpers.circuits import pauli_of_to_string, get_compatible_bases\n\nhist_dict = {b: Histogram(h, 10**6) for b,h in zip(basis_list, hists)}\nen = 0.\n\nfor t,c in qu_op.terms.items():\n    p = pauli_of_to_string(t,2)\n    bl = get_compatible_bases(p, basis_list)\n    en += aggregate_histograms(*[hist_dict[b] for b in bl]).get_expectation_value(t,c)\n\nprint(\"MI-FNO energy:     \", e_tot_frag)\nprint(\"Aggregated energy: \", en + correction)\n\nMI-FNO energy:      -76.33817036745623\nAggregated energy:  -76.16544280598923\n\n\nWe can use the computed fragment energy to recalculate the full system energy to get an idea of the impact on overall total energy:\n\n# Energy resummation\ne_mifno = fno_fragments.e_tot\ne_sim= fno_fragments.mi_summation({\"(2,)\": en})\n\nprint(\"MI-FNO energy:     \", e_mifno)\nprint(\"Simulated energy: \", e_sim)\n\nMI-FNO energy:      -76.52019103159677\nSimulated energy:  -76.34746347012977\n\n\nWe see that the energy simulated using the noise level obtained from the characterization of the IonQ Harmony device differs significantly from the MI-FNO energy. This motivates us to introduce some error mitigation techniques in order to correct for the hardware noise."
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#running-on-amazon-braket",
    "href": "examples/hardware_experiments/umbrella_inversion.html#running-on-amazon-braket",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "5.1 Running on Amazon Braket ",
    "text": "5.1 Running on Amazon Braket \nTangelo provides tools to construct a randomized shadow. For simplicity here, since for a two qubit system there are very few measurement bases, we excplitly specify them to expose more clearly how we use Braket. We define all the possible measurement bases below, and for each of these we append first the symmetry verification circuit and then transform the system qubits into the corresponding measurement basis. QEMIST Cloud users can leverage the Tangelo integration to submit the experiments to Amazon Braket, as shown below. Since QEMIST Cloud is not yet publically available, we simply provide the code snippets and their outputs.\n\nn_shots = 10**5\n\n# All 2-qubit measurement bases needed for the classical shadow\ncs_basis_list = [\"ZZ\", \"XZ\", \"ZX\", \"XX\", \"YZ\", \"ZY\", \"YY\", \"XY\", \"YX\"]\n\nfrom tangelo.linq.qpu_connection import QEMISTCloudConnection\n\nqemcl = QEMISTCloudConnection()\nqemcl.job_estimate(adapt_circ, n_shots)\nThe code cell above returns the prices for running 10,000 shots of the circuit provided, on the supported quantum devices and simulators, here part of Amazon Braket’s selection. Here’s the output from back then:\n{'arn:aws:braket:::device/qpu/ionq/ionQdevice': 100.3,\n 'arn:aws:braket:::device/quantum-simulator/amazon/sv1': 0.038,\n 'arn:aws:braket:us-west-1::device/qpu/rigetti/Aspen-M-1': 3.8}\nThe code below adds the symmetry post-selection gates and the measurement gates to define our quantum circuit for each of the measurement bases, and submits them to Braket, using their QEMIST Cloud credits. It is however possible for Braket users to submit these jobs using the Braket API or our convenience wrappers, with their own Braket credentials.\nWe submit overall 9 quantum circuits, differing by their final measurement gates.\nbackend = 'arn:aws:braket:::device/qpu/ionq/ionQdevice'\n\njob_ids = {}\n\n# Build circuits and submit to Amazon Braket\nfor basis in cs_basis_list:\n    meas_circ = Circuit(measurement_basis_gates(pauli_string_to_of(basis)))\n    final_circ = adapt_symmpostselect_circ + meas_circ\n\n    job_id = qemcl.job_submit(final_circ, n_shots=n_shots, backend=backend)\n    job_ids[basis] = job_id\n\n# Retrieve results and save to json file\nres = {basis: qemcl.job_result(job_id)[0] for basis, job_id in job_ids.items()}\n\nwith open(\"./ionq_data/H3Op_sym_postselect_10000_ionq.json\", \"w\") as file:\n    json.dump(res, file)\nReplacing job submission by cost estimation in the code above is a way to assess the total cost of the experiment before submitting anything. As experiments are usually done on a budget, this information is still rather central in its design. Here we’d get an estimate of about $900.\nBelow we read in the data that we obtained from our experiment on IonQ Harmony during the Summer of 2022, and perform full symmetry post-selection.\n\n# Load the data coming from our quantum experiment on Harmony\nwith open(\"./ionq_data/H3Op_sym_postselect_10000_ionq.json\", \"r\") as file:\n    res = json.load(file)\n\n# Perform post-selection\nres_post = {}\nfor base, hist in res.items():\n    h = Histogram(hist)\n    h.post_select({2: \"0\"})\n    res_post[base] = h\n\nprint(res_post)\n\n{'ZZ': {'00': 0.0087, '01': 0.0056, '10': 0.0053, '11': 0.9136}, 'XZ': {'00': 0.0101, '01': 0.5165, '10': 0.0051, '11': 0.4167}, 'ZX': {'00': 0.0049, '01': 0.0103, '10': 0.4553, '11': 0.4728}, 'XX': {'00': 0.1809, '01': 0.2659, '10': 0.2629, '11': 0.2281}, 'YZ': {'00': 0.0051, '01': 0.5002, '10': 0.0104, '11': 0.4106}, 'ZY': {'00': 0.0033, '01': 0.0101, '10': 0.4859, '11': 0.4321}, 'YY': {'00': 0.2659, '01': 0.185, '10': 0.2278, '11': 0.2549}, 'XY': {'00': 0.1904, '01': 0.1958, '10': 0.2416, '11': 0.2919}, 'YX': {'00': 0.2233, '01': 0.2413, '10': 0.221, '11': 0.2388}}"
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#post-processing-construct-classical-shadow-and-purify",
    "href": "examples/hardware_experiments/umbrella_inversion.html#post-processing-construct-classical-shadow-and-purify",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "5.2 Post-processing: construct classical shadow and purify ",
    "text": "5.2 Post-processing: construct classical shadow and purify \nWe can now construct a classical shadow and purify the state.\n\nfrom tangelo.toolboxes.measurements import RandomizedClassicalShadow\n\nbitstrings, unitaries = [], []\n    \nfor b, hist in res_post.items():\n    for s,f in hist.frequencies.items():\n        factor = round(f*(n_shots))\n        bitstrings.extend([s]*factor)\n        unitaries.extend([b]*factor)\n\nionq_cs_post = RandomizedClassicalShadow(unitaries=unitaries, bitstrings=bitstrings)\n\nAfter constructing the shadow, we can use convenience functions provided by Tangelo to compute the 1- and 2-RDM. Since this is a small, two qubit system, we can use the McWeeny technique to purify the 2-RDM and calculate the purified energy. Below we show a comparison of the difference between the purified and non-purified energies and suggests that purification mitigates the noise efficiently.\n\nfrom tangelo.toolboxes.post_processing.mc_weeny_rdm_purification import mcweeny_purify_2rdm\nfrom tangelo.toolboxes.molecular_computation.rdms import compute_rdms, energy_from_rdms\n\nrdm1_p, rdm2_p, rdm1_ss_p, rdm2_ss_p = compute_rdms(ferm_op, \"scbk\", True, exp_data=res)\nrdm1_p_pur, rdm2_p_pur = mcweeny_purify_2rdm(rdm2_p.real)\n\n\ne_p_exp = energy_from_rdms(ferm_op, rdm1_ss_p, rdm2_ss_p)\ne_p_pur = energy_from_rdms(ferm_op, rdm1_p_pur, rdm2_p_pur)\n\nprint(\"Experiment energy:\", e_p_exp)\nprint(\"Purified energy:  \", e_p_pur)\nprint(\"Diff from MI-FNO:   \", e_p_pur-(e_tot_frag-correction))\n\nExperiment energy: -76.2369464417231\nPurified energy:   -76.3276400895683\nDiff from MI-FNO:    0.001410481713961076\n\n\nA similar calculation can be performed for non-post-selected data, which one can obtain by removing the ancilla qubit and adding together the corresponding frequencies. This data can also be purified to see the effect of the two mitigation techniques separately. For brevity, we present the final results:\n\ne_exp = -76.2685\ne_pur = -76.3138\n\nFinally, we can estimate the error of the energy by using a technique called bootstrapping. This consists in generating an ensemble of new histograms by resampling from the experimental data and calculating a standard devition of the resulting energies. For brevity, here we only present the results of those calculations. You can find more details about bootstrapping in this notebook.\n\ne_exp_err = 0.0037\ne_pur_err = 0.0019\ne_p_exp_err = 0.0037\ne_p_pur_err = 0.0007"
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#energy-resummation-and-plot",
    "href": "examples/hardware_experiments/umbrella_inversion.html#energy-resummation-and-plot",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "5.3 Energy resummation and plot ",
    "text": "5.3 Energy resummation and plot \nFinally, we need to recalculate the energy of the full system using this fragment energy to see the final result. We plot the whole data set, including the Hartree-Fock and MI-FNO umbrella curve, and the four total energies calculated below. In the inset we show the lower portion of the whole plot to emphasize the impact of the error mitigation techniques. The shaded region around the curve indicates the regime of chemical accuracy.\n\n# Recompute total energy, overriding the fragment enregy with the different experimental results \net_exp = fno_fragments.mi_summation({\"(2,)\": e_exp})\net_pur = fno_fragments.mi_summation({\"(2,)\": e_pur})\net_post_exp = fno_fragments.mi_summation({\"(2,)\": e_p_exp})\net_post_pur = fno_fragments.mi_summation({\"(2,)\": e_p_pur})\n\nprint(\"Classical:\", fno_fragments.e_tot)\nprint(\"Raw:\", et_exp)\nprint(\"Raw purified:\", et_pur)\nprint(\"Post-selected:\", et_post_exp)\nprint(\"Post-selected purified:\", et_post_pur)\n\nClassical: -76.52019103159677\nRaw: -76.4596404603145\nRaw purified: -76.5049404603145\nPost-selected: -76.4280869020376\nPost-selected purified: -76.5187805498828\n\n\nWe load the MI-FNO data precomputed with QEMIST Cloud for various geometries of the system of interest, in order to better illustrate where the results sit compared to Hartree-Fock and the MI-FNO resolution.\n\nmifno_curve = np.loadtxt(\"H3Oplus_MIFNO_CCPVDZ.csv\", delimiter=\",\")[:,1:].T\n\n\nimport pylab as plt\n\nfig = plt.figure(figsize=(9,6), dpi=120)\nax = plt.axes([0.02,0.02,0.98,0.98])\n\nax.plot(theta, rhf, label=\"RHF\")\n\nax.plot(mifno_curve[0], mifno_curve[1], label=\"MIFNO\")\nax.fill_between(mifno_curve[0], mifno_curve[1]-0.0016, mifno_curve[1]+0.0016, color='orange', alpha=.1)\n\nax.errorbar(70, et_exp, e_exp_err, fmt=\".\", label=\"Raw\", capsize=5)\nax.errorbar(70, et_pur, e_pur_err, fmt=\".\", label=\"Purified\", capsize=5)\nax.errorbar(70, et_post_exp, e_p_exp_err, fmt=\".\", label=\"Post-selected\", capsize=5)\nax.errorbar(70, et_post_pur, e_p_pur_err, fmt=\".\", label=\"Post-selected + purified\", capsize=5)\n\nax.legend(loc=\"lower right\")\nax.set_ylabel(\"Energy [Ha]\")\nax.set_xlabel(\"Angle [deg]\")\n\nax2 = plt.axes([0.5,0.4,0.48,0.48])\nax2.plot([],[])\nax2.plot(mifno_curve[0], mifno_curve[1], label=\"MIFNO\")\nax2.fill_between(mifno_curve[0], mifno_curve[1]-0.0016, mifno_curve[1]+0.0016, color='orange', alpha=.1)\n\nax2.plot([],[])\nax2.errorbar(70, et_pur, e_pur_err, fmt=\".\", label=\"Purified\", capsize=5)\nax2.errorbar(70, et_post_exp, e_p_exp_err, fmt=\".\", label=\"Post-selected\", capsize=5)\nax2.errorbar(70, et_post_pur, e_p_pur_err, fmt=\".\", label=\"Post-selected + purified\", capsize=5)\n\n&lt;ErrorbarContainer object of 3 artists&gt;"
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#bonus-nuclear-dynamics-simulation",
    "href": "examples/hardware_experiments/umbrella_inversion.html#bonus-nuclear-dynamics-simulation",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "6 Bonus: Nuclear Dynamics Simulation ",
    "text": "6 Bonus: Nuclear Dynamics Simulation \nTo examine the umbrella inversion in action, we can perform a quantum simulation of the nuclear motion. This is not possible on current quantum devices: we run the following fault-tolerant approach on a simulator.\nWe start with calculating the coordinate change in mass-weighted coordinates.\n\n# Define constants for unit conversion, and hydrogen / oxygen atom mass\nangstrom2bohr = 1.8897259886\nme2amu = 1822.888486209\nhm = 1.00784 * me2amu\nom = 15.999 * me2amu\n\n# Reduced mass for simulation\nm = 3*hm*om/(3*hm+om)/me2amu\n\n# OH bond length\nd = 0.986 * angstrom2bohr\n\ndef calc_mw_coords(theta):\n    \"\"\"Calculate mass-weighted cartesian coordinates\"\"\"\n    theta = theta*np.pi/180\n    C, S = np.cos(theta), np.sin(theta)\n    c, s = np.cos(np.pi/3), np.sin(np.pi/3)\n    h_pos = d*np.array([[   S,    0, C],\n                        [-S*c,  S*s, C],\n                        [-S*c, -S*s, C]])\n    o_pos = np.zeros(3)\n    cmass = (hm*h_pos[0] + hm*h_pos[1] + hm*h_pos[2])/(3*hm+om)\n    mw_coords = np.zeros((4,3), dtype=float)\n    for i in range(3):\n        mw_coords[i] = (h_pos[i] - cmass)*np.sqrt(hm)  \n    mw_coords[3] = (o_pos-cmass)*np.sqrt(om)  \n    return mw_coords\n\n# Reference configuration \n# (Case where all atoms of H3O+ are on the same plane)\nref_config = calc_mw_coords(theta=90)\n\ndef calc_qs(theta, ref_config):\n    \"\"\"Return displacement in mass-weighted coordinates\"\"\"\n    new_config = calc_mw_coords(theta)\n    diff = 0\n    for i in range(4):\n        diff += np.dot(ref_config[i] - new_config[i], ref_config[i] - new_config[i])\n    return np.sqrt(diff)\n\nthetas = np.linspace(60, 120, 31)\nmass_weighted = np.zeros(31)\n\nfor i, theta in enumerate(thetas):\n    mass_weighted[i] = calc_qs(theta, ref_config)\n\n# Only returns absolute value of displacement so need to assign negative value \n# to one direction\nmass_weighted[:16] *= -1\n\nCalculate interpolation of data for any coordinate length to use for nuclear dynamics.\n\nfrom scipy.interpolate import CubicSpline\n\nspl = CubicSpline(mass_weighted, mifno_curve[1])\n\n# Use 8 qubits, corresponding to 64 grid pts for simulation\nn_qubits = 8\nn_pts = 2**n_qubits\nxdata = np.linspace(-114.75, 114.75, n_pts, endpoint=True)\ndx = xdata[1] - xdata[0]\ninterpolated_curve = spl(xdata)\n\nWe convert the interpolated data into an equivalent QubitOperator object.\n\nimport math\nfrom itertools import product\n\nfrom openfermion import get_sparse_operator\nfrom scipy.sparse import diags\n\nfrom tangelo.toolboxes.operators import QubitOperator\n\ndef qu_vpot(vals, order='lsq_first'):\n    \"Return representation of diagonal matrix as a QubitOperator where vals are the diagonal elements of the matrix.\"\n    n_qubits=round(math.log2(len(vals)))\n    new_vals = vals.copy()\n    if order == \"msq_first\":\n        new_vals = new_vals.reshape([2]*n_qubits).transpose(list(reversed(range(n_qubits)))).flatten() \n    v_op = QubitOperator()\n    for i in product([\"I\", \"Z\"], repeat=n_qubits):\n        tup = tuple([(j, op) for j, op in enumerate(i) if op != \"I\"])\n        qu_op = QubitOperator(tup)\n        v = get_sparse_operator(qu_op, n_qubits=n_qubits)\n        v_op += (diags(new_vals).dot(v)).trace()*QubitOperator(tup)\n    v_op /= 2**n_qubits\n    return v_op   \n\n# Choose qubit order so bitstrings are directly converted to data\nqubit_order = \"lsq_first\" \nqu_op_v = qu_vpot(interpolated_curve, qubit_order)\n\nWe initialize the wavefunction to the gaussian \\(\\sqrt{\\frac{2}{\\sigma \\sqrt{2\\pi}}}e^{-\\left(\\frac{x-x0}{\\sigma}\\right)^2}\\) in left configuration, with \\(\\sigma\\) as the normalization factor.\n\nfrom tangelo.linq.helpers.circuits.statevector import StateVector\n\nsigma = 10\nx0 = -50\ninit_vec = np.sqrt(2/sigma/np.sqrt(2*np.pi)) * np.exp(-((xdata - x0)/sigma)**2)*np.sqrt(dx)\ninitial_density = init_vec**2\n\nstate = StateVector(init_vec, order=qubit_order)\ninit_circuit = state.initializing_circuit()\n\nWe use the split operator method \\(e^{-i H \\Delta t}\\approx e^{-i p^2/2/m \\Delta t}e^{-i v \\Delta t}e^{-i p^2/2/m \\Delta t}\\). The kinetic energy term is calculated using the centered fast fourier transform for which the circuit can easily be generated using get_psquared_circuit. The potential evolution can be generated by calling trotterize. We run the simulation for about 1.2 ps.\n\nfrom tangelo.linq import get_backend\nfrom tangelo.toolboxes.circuits.grid_circuits import get_psquared_circuit\nfrom tangelo.toolboxes.ansatz_generator.ansatz_utils import trotterize\n\n# Specify qubit order to define psquared circuit (depends on statevector ordering)\nqubit_list = list(reversed(range(n_qubits))) \n\n# Build split operator with n_trotter_steps\ndef trotter_func(n_trotter_steps, time):\n    p2_circ = get_psquared_circuit(time/n_trotter_steps/2, dx=dx, mass=m, qubit_list=qubit_list)\n    vcirc = trotterize(operator=qu_op_v, time=time/n_trotter_steps, n_trotter_steps=1)\n    return (p2_circ + vcirc + p2_circ) * n_trotter_steps\n\n# Time evolution for about 1.2 picoseconds\ntime = 50000\nsim = get_backend()\nf, _ = sim.simulate(init_circuit + trotter_func(200, time))\n\nfinal_density = np.zeros(n_pts)\nfor key, prob in f.items():\n    final_density[int(key, base=2)] = prob\n\nNow let’s plot the initial and final densities, as well as our interpolated curve.\n\nimport matplotlib.image as image\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\n\nimport matplotlib.pyplot as plt\n\n# Overlay H3O+ molecule image\nfile = \"umbrella_inversion_H3Op.png\"\ninversion = image.imread(file)\nimagebox = OffsetImage(inversion, zoom=0.4)\nab = AnnotationBbox(imagebox, (0, -76.49), pad=0)\n\nfig, ax = plt.subplots(figsize = (12, 8))\n\n# Main plot\nax2 = ax.twinx()\nax2.add_artist(ab)\nax.plot(xdata, initial_density, xdata, final_density)\nax2.plot(xdata, interpolated_curve, 'g-')\nax.set_xlabel(\"Length along inversion $(\\sqrt{m_u} a_0)$\", fontsize=16)\nax.set_ylabel(\"Probability\", fontsize=16)\nax2.set_ylabel(\"Energy (Hartree)\", color='g', fontsize=16)\nax.legend([\"Initial Density\", \"Final Density\"], fontsize=16, loc=\"upper center\")\nax.set_ylim([-0.05, 0.08])\n\n(-0.05, 0.08)\n\n\n\n\n\nIn the figure, we see the initial density is localized in the left well signifying that the orientation of the molecule has the three hydrogen atoms below the oxygen nuclei (as depicted on the left side of the inset inversion process figure). The final density on the other hand shows peaks in the right well, which means that there is significant probability that the hydrogen atoms are localized above the oxygen atom. Even though the initial wave packet was localized below the barrier height, the wave packet tunneled through such that we have successfully witnessed the umbrella inversion!"
  },
  {
    "objectID": "examples/hardware_experiments/umbrella_inversion.html#closing-words",
    "href": "examples/hardware_experiments/umbrella_inversion.html#closing-words",
    "title": "Exploring the umbrella inversion with quantum computers",
    "section": "Closing words",
    "text": "Closing words\nThis notebook illustrates how Tangelo, QEMIST Cloud and Amazon Braket can be combined to explore the potential of quantum computing for chemistry simulation, here using the umbrella inversion as a use case. It accompanies an article published on AWS Quantum blog, which goes more into detail about the chemistry and the experimental results obtained on a quantum device.\nBy breaking down a problem instance into a collection of subproblems requiring a lower amount of computational resources, the problem decomposition techniques available in Tangelo and QEMIST Cloud can extend the range of use-cases within reach of current quantum devices. The toolboxes in Tangelo support researchers at every step of their quantum exploration, by providing algorithms or reusable building-blocks to express their own custom workflows and put their ideas to the test.\nWhat will you do with Tangelo ?"
  },
  {
    "objectID": "examples/hardware_experiments/qemist_cloud_hardware_experiments_braket.html",
    "href": "examples/hardware_experiments/qemist_cloud_hardware_experiments_braket.html",
    "title": "Submitting quantum hardware experiments with Tangelo and QEMIST Cloud",
    "section": "",
    "text": "This short tutorial shows how users can achieve that by simply installing both the Tangelo and QEMIST Cloud’s client library, and access all the backends available in Amazon Braket.\nTangelo users can express quantum circuits in various formats, which can be then submitted to one of the quantum cloud services providers using their account credentials and the API.\nThis short tutorial shows how users can access all the backends available in Amazon Braket by simply installing both the Tangelo and QEMIST Cloud’s client library, then running quantum hardware experiments using their QEMIST Cloud account credentials and credits."
  },
  {
    "objectID": "examples/hardware_experiments/qemist_cloud_hardware_experiments_braket.html#installation-environment",
    "href": "examples/hardware_experiments/qemist_cloud_hardware_experiments_braket.html#installation-environment",
    "title": "Submitting quantum hardware experiments with Tangelo and QEMIST Cloud",
    "section": "Installation & environment",
    "text": "Installation & environment\nIn order to succesfully submit an experiment, you will first need to:\n\ninstall Tangelo\ninstall qemist-client (QEMIST client library)\n\nOnce you have installed the two required packages, set up both environment variables QEMIST_PROJECT_ID and QEMIST_AUTH_TOKEN in your local environment. You may set these variables in your OS / terminal, or provide them in your script using the os module, as below:\n\nimport os\n\nos.environ['QEMIST_PROJECT_ID'] = \"your_project_id_string\"\nos.environ['QEMIST_AUTH_TOKEN'] = \"your_qemist_authentication_token\"\n\nIf these two variables are not properly set, you will get errors later on in some import statements related to qemist-client.\nAssuming you have access to the QEMIST Cloud dashboard: - You can get a project ID by navigating to Projects using the left-side bar, and selecting a project. - Your API token can be found by clicking the top-right dropdown menu and then API token"
  },
  {
    "objectID": "examples/hardware_experiments/qemist_cloud_hardware_experiments_braket.html#a-simple-example",
    "href": "examples/hardware_experiments/qemist_cloud_hardware_experiments_braket.html#a-simple-example",
    "title": "Submitting quantum hardware experiments with Tangelo and QEMIST Cloud",
    "section": "A simple example",
    "text": "A simple example\nFirst, we define a quantum circuit using the API provided by Tangelo. For the purpose of this tutorial, we here explicitly define a short circuit that simply prepares a Bell state. However, this feature works with any quantum circuit expressed in the Tangelo format, including those you may have obtained from a complicated custom workflow expressed with Tangelo.\n\nfrom tangelo.linq import Gate, Circuit\n\ncircuit = Circuit([Gate(\"H\", 0), Gate(\"CNOT\", 1, control=0)])\nprint(circuit)\n\nCircuit object. Size 2 \n\nH         target : 0   \nCNOT      target : 1   control : 0   \n\n\n\nIn order to submit a quantum job and run this circuit on one of the available devices, we import a few convenience functions from the Tangelo, which rely on the QEMIST client library. We illustrate their usage in the rest of the notebook.\n\nfrom tangelo.linq.qpu_connection import QEMISTCloudConnection\nqcloud_connection = QEMISTCloudConnection()\n\n\nJob price estimate\nBefore running one or several quantum experiments, it may be useful to have an estimate of the cost. We provide a convenience function job_estimate, which returns a dictionary featuring the price associated with the different backends available, in QEMIST Cloud credits (currently 1 QEMIST credit = 1 USD). These prices and backends are the ones available to us, using our own subscription to Amazon Braket and other cloud services: we make them available to you through this API.\nSome pricing formulas may take into account the specifics of your circuit, while others do not. Simulator backends sometimes charge per-the-minute and are therefore difficult to estimate: we currently choose to only return estimates for actual quantum devices.\nDo not hesitate to look directly into the official pricing provided by cloud providers (ex: https://aws.amazon.com/braket/pricing/) for the backends that we do not list or for which the estimate can be difficult to make.\n\nprice_estimates = qcloud_connection.job_estimate(circuit, n_shots=1000)\nprint(price_estimates)\n\n{'braket_ionq': 10.3, 'braket_rigetti': 0.65}\n\n\n\n\nJob submission\nThe job_submit function can be used to submit a quantum job on the target backends available in Amazon Braket (through their device arn), and the number of shots required. Both parameters are required. It returns a ID, used as a handle to your quantum job. This call is asynchronous / non-blocking, which means that it returns without waiting for the job to complete, allowing you to continue with your script in the meantime.\nFeel free to uncomment any of the lines below, if you wish to run the following commands on the backend of your choice. Note that the quantum devices are not guaranteed to be immediately available and that you will require a subscription to QEMIST Cloud.\n\nbackend = 'arn:aws:braket:::device/quantum-simulator/amazon/sv1'\n# backend = 'arn:aws:braket:::device/qpu/ionq/ionQdevice'\n# backend = 'arn:aws:braket:::device/qpu/rigetti/Aspen-9'\n# backend = 'arn:aws:braket:::device/quantum-simulator/amazon/dm1'\n\n\njob_id = qcloud_connection.job_submit(circuit, n_shots=100, backend=backend)\nprint(f\"Job submitted with job id :: {job_id}\")\n\n{'shots': 100, 'backend': 'arn:aws:braket:::device/quantum-simulator/amazon/sv1'}\nJob submitted with job id :: 60301948057975242\n\n\n\n\nJob status\nOnce your job has been submitted, you may query his status through the job_status. It may take time for this job to start, as your request has been queued with the desired cloud services: it could be instant or take hours for the job to start.\nThe return values are: ready, in_progress, complete, cancelled.\n\nprint(qcloud_connection.job_status(job_id))\n\nready\n\n\n\n\nJob cancel\nA job that has been submitted and has not yet started may be cancelled through the job_cancel command, which takes the job ID as parameter. You are free to uncomment this line and try, if you’d like.\n\n# print(qcloud_connection.job_cancel(job_id))\n\n\n\nJob result\nFinally, you can make a blocking call to retrieve your results using job_result. This function returns the histogram of frequencies associated with your quantum circuit, as well as the raw data provided by the quantum services provider, as nested dictionaries.\nThe histogram of frequencies is returned in a standard format, where the bitstrings read left-to-right: that is, the string 01 refers to the basis state that measured qubit 0 (resp. 1) in state \\(|0\\rangle\\) (resp. state \\(|1\\rangle\\)).\nFeel free to investigate and parse the output as you see fit: while the histogram of frequencies ensures you get the essentials in a standard format, the raw data blob is something you can save or dig into to find more about what actually happened on the device, now or later.\n\nfreqs, raw_data = qcloud_connection.job_results(job_id)\nprint(f\"Frequencies :: {freqs}\")\n\nFrequencies :: {'00': 0.53, '11': 0.47}\n\n\n\nprint(raw_data)\n\n{'fragment_type': 'QuantumCircuit', 'problem_handle': 60301948057975242, 'result': {'results': {'measurements': [[0, 0], [1, 1], [0, 0], [0, 0], [0, 0], [0, 0], [1, 1], [1, 1], [0, 0], [0, 0], [1, 1], [0, 0], [1, 1], [1, 1], [1, 1], [1, 1], [0, 0], [1, 1], [0, 0], [0, 0], [0, 0], [1, 1], [1, 1], [1, 1], [0, 0], [0, 0], [1, 1], [0, 0], [1, 1], [1, 1], [1, 1], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [1, 1], [0, 0], [1, 1], [0, 0], [0, 0], [0, 0], [1, 1], [1, 1], [1, 1], [0, 0], [1, 1], [1, 1], [0, 0], [0, 0], [1, 1], [0, 0], [0, 0], [0, 0], [1, 1], [1, 1], [0, 0], [0, 0], [1, 1], [1, 1], [0, 0], [1, 1], [1, 1], [1, 1], [0, 0], [0, 0], [0, 0], [1, 1], [0, 0], [1, 1], [1, 1], [0, 0], [1, 1], [0, 0], [0, 0], [1, 1], [1, 1], [0, 0], [0, 0], [0, 0], [0, 0], [1, 1], [1, 1], [1, 1], [0, 0], [0, 0], [1, 1], [1, 1], [0, 0], [0, 0], [0, 0], [0, 0], [1, 1], [0, 0], [1, 1], [1, 1], [0, 0], [0, 0], [1, 1], [1, 1]], 'measured_qubits': [0, 1], 'measurement_counts': {'00': 53, '11': 47}, 'measurement_probabilities': {'00': 0.53, '11': 0.47}}, 'metadata': {'action': {'results': [], 'instructions': [{'type': 'h', 'target': 0}, {'type': 'cnot', 'target': 1, 'control': 0}], 'basis_rotation_instructions': []}, 'rigettiMetadata': None}}, 'solve_time': 777, 'status': 'complete'}\n\n\n\n\nClosing words\nManaging multiple quantum cloud service subscriptions and juggling all those login credentials can be cumbersome and tedious. This notebook briefly demonstrates how users with a subscription to QEMIST Cloud can benefit from using our wrappers and submit hardware experiments to a broad range of backends with only one set of credentials, using our subscription."
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html",
    "href": "examples/hardware_experiments/overview_endtoend.html",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "",
    "text": "Open In Colab\nQuantum computing is a nascent field, and we have barely started to explore its applications. In order to revolutionize fields such as quantum chemistry, the community has to face challenges in both algorithms design and quantum hardware development. A major undertaking is designing approaches ensuring satisfying accuracy, while keeping computing resource requirements within the capabilities of Noisy Intermediate Scale Quantum (NISQ) devices to solve exciting problems.\nThis quantum SDK was designed to support our exploration with this goal in mind, and enables us to build our own end-to-end workflows by providing building-blocks from various toolboxes, and algorithms.\nThe present notebook attempts to provide a step-by-step tutorial from starting with an expression of a molecule all the way to post-processing the results coming from the quantum hardware to obtain successful final results. More specifically we cover the following steps:"
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html#table-of-contents",
    "href": "examples/hardware_experiments/overview_endtoend.html#table-of-contents",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "Table of contents:",
    "text": "Table of contents:\n\n1. Setting up your environment\n2. Introducing our use case\n3. Representing the input molecular data\n4. Calculating reference energy with classical solvers\n5. Exploring approaches using resource estimation and problem decomposition\n6. Validating the desired approach with simulators\n7. Minimizing the amount of resources needed for the hardware experiment\n\nMinimizing the number of measurements needed\nPicking the number of shots\nCircuit compilation and optimization\n\n8. Submitting an experiment to a quantum device\n\nUsing QEMIST Cloud\nUsing a cloud service API and format conversion\nEmulation on a noisy backend\n\n9. Post-processing and error-mitigation of raw hardware results\n\nError mitigation\nStatistical analysis of results\n\n10. Closing words\n\nIn this notebook, we illustrate how Tangelo can be used to re-enact one of our recent successful quantum chemistry experiments, done in collaboration with Dow and IonQ [Kawashima et al., 2021]. This experiment features an electronic system that could not be realistically solved with a heads-on approach on an existing quantum computer, yet produced great experimental results by combining the DMET problem decomposition technique [Knizia et al., 2013a and Knizia et al., 2013b] with the VQE algorithm [Kassal et al., 2011, Peruzzo et al., 2014 and Cao et al., 2019] and error-mitigation techniques [Bharti et al., 2021], running on an ion-trap-based quantum processor."
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html#setting-up-your-environment",
    "href": "examples/hardware_experiments/overview_endtoend.html#setting-up-your-environment",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "Setting up your environment ",
    "text": "Setting up your environment \nIn order to run this notebook, tangelo needs to be installed in your Python environment, or be found in your PYTHONPATH. Please refer to the installation instructions for any additional information, and how to install optional dependencies such as performant quantum circuit simulators. If Tangelo is not already installed, executing the cell below installs the minimal requirements for this notebook.\n\n# Pretty printer for more readable outputs\nimport pprint\npp = pprint.PrettyPrinter(width=160, compact=False, indent=1)\nfrom pprint import pprint\n\n# Installation of tangelo if not already installed.\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet"
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html#introducing-our-use-case-a-ring-of-10-hydrogen-atoms",
    "href": "examples/hardware_experiments/overview_endtoend.html#introducing-our-use-case-a-ring-of-10-hydrogen-atoms",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "Introducing our use case: a ring of 10 hydrogen atoms ",
    "text": "Introducing our use case: a ring of 10 hydrogen atoms \nIn order to cover all the steps of a successful quantum hardware experiment for the purpose of quantum chemistry simulation, we decided to reproduce the results of our recent collaboration with Dow and IonQ on the symmetric stretch of a ring of hydrogen atoms using this package. It includes all of the main steps required for quantum chemistry simulation on quantum hardware. In that collaboration, the ring of 10 hydrogen atoms was chosen to demonstrate the viability of Density Matrix Embedding Theory (DMET) as a problem decomposition technique for the purpose of electronic structure calculations. The DMET pipeline enables us to take into account all electrons in the molecule while greatly reducing the amount of computational resources needed.\nThe system studied in this notebook is characterized by a distance of 1.1\\(\\overset{\\circ}{A}\\) between hydrogen atoms, and is built in the MINAO basis. The emphasis on this pipeline is to retrieve electronic correlation energy while leveraging the power of NISQ devices. A full potential energy curve has been computed in [Kawashima et al., 2021] to study the repulsive, equilibrium, attractive and dissociative regimes."
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html#representing-the-input-molecular-data",
    "href": "examples/hardware_experiments/overview_endtoend.html#representing-the-input-molecular-data",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "Representing the input molecular data ",
    "text": "Representing the input molecular data \nFirst, we need to represent the molecular system of interest. Currently, Tangelo accepts some xyz input that specifies individual atoms paired with their corresponding xyz cartesian coordinates. We can pass this information as nested lists containing the atom string and the coordinate tuple (see example below) or as a single string, specifying one atom per line and separating each coordinate with a space.\nThe openbabel python package can be used to derive the cartesian coordinates from formats such as mol, mol2, ginp, com, pdb (…), and thus provides us with the ability to support your favorite format in the future, maybe even with your contribution to the codebase.\nCurrently, this package works with molecular Hamiltonians represented in second-quantization, which is the formalism almost all proof-of-concept demonstrations of quantum chemistry simulations on quantum hardware have utilized so far. We provide all the necessary functionalities to obtain SecondQuantizedMolecule data and Hamiltonians in order to represent this system adequately from the xyz coordinates. The minimal input for the creation of this object is a nested list of atomic coordinates (a multi-line string can also be thrown at the SecondQuantizedMolecule class).\nThis object instantiation includes the computation of the mean-field solutions, provided by a Hartree-Fock (HF) calculation. This is the starting point of post-HF calculations that introduce electronic correlation. Besides general molecular information, the SecondQuantizedMolecule contains data about molecular orbitals and spin-orbitals. One well-known use case for this is to freeze molecular orbitals with the frozen_orbitals argument, in order to reduce problem size, for example.\n\nfrom tangelo import SecondQuantizedMolecule\n\nxyz = [\n    ['H', (0.0, 1.780, 0.0)], \n    ['H', (-1.046, 1.44, 0.0)], \n    ['H', (-1.693, 0.55, 0.0)], \n    ['H', (-1.693, -0.55, 0.0)], \n    ['H', (-1.046, -1.44, 0.0)], \n    ['H', (0.0, -1.78, 0.0)], \n    ['H', (1.046, -1.44, 0.0)], \n    ['H', (1.693, -0.55, 0.0)], \n    ['H', (1.693, 0.55, 0.0)], \n    ['H', (1.046, 1.44, 0.0)]\n]\n\nmol = SecondQuantizedMolecule(xyz, q=0, spin=0, basis=\"minao\", frozen_orbitals=None)\npprint(mol.__dict__)\n\n{'active_occupied': [0, 1, 2, 3, 4],\n 'active_virtual': [5, 6, 7, 8, 9],\n 'basis': 'minao',\n 'ecp': {},\n 'frozen_occupied': [],\n 'frozen_orbitals': None,\n 'frozen_virtual': [],\n 'mean_field': RHF object of &lt;class 'pyscf.scf.hf.RHF'&gt;,\n 'mf_energy': -5.2772722844168225,\n 'mo_energies': array([-0.71250664, -0.63494046, -0.63486503, -0.4162918 , -0.41611742,\n        0.07821244,  0.07835203,  0.50868475,  0.50889667,  0.75894782]),\n 'mo_occ': array([2., 2., 2., 2., 2., 0., 0., 0., 0., 0.]),\n 'mo_symm_ids': None,\n 'mo_symm_labels': None,\n 'n_atoms': 10,\n 'n_electrons': 10,\n 'n_mos': 10,\n 'n_sos': 20,\n 'q': 0,\n 'spin': 0,\n 'symmetry': False,\n 'uhf': False,\n 'xyz': [('H', (0.0, 1.78, 0.0)),\n         ('H', (-1.046, 1.44, 0.0)),\n         ('H', (-1.6929999999999996, 0.55, 0.0)),\n         ('H', (-1.6929999999999996, -0.55, 0.0)),\n         ('H', (-1.046, -1.44, 0.0)),\n         ('H', (0.0, -1.78, 0.0)),\n         ('H', (1.046, -1.44, 0.0)),\n         ('H', (1.6929999999999996, -0.55, 0.0)),\n         ('H', (1.6929999999999996, 0.55, 0.0)),\n         ('H', (1.046, 1.44, 0.0))]}"
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html#calculating-reference-energy-with-classical-solvers",
    "href": "examples/hardware_experiments/overview_endtoend.html#calculating-reference-energy-with-classical-solvers",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "Calculating reference energy with classical solvers ",
    "text": "Calculating reference energy with classical solvers \nFor convenience, we provide access to several well-known classical solvers, such as FCI or CCSD. They may be helpful in investigating hybrid approaches pairing both classical and quantum solvers, or obtaining reference numerical results. The latter help us quantify the accuracy of the approaches we investigate in the rest of this notebook.\nWe find that our use case turns out to be a simple problem for FCI and CCSD, which can both be used in a straightforward way, by passing the molecule at instantiation and then calling the simulate method.\n\nfrom tangelo.algorithms import FCISolver, CCSDSolver\n\nfci_energy = FCISolver(mol).simulate()\nprint(f\"FCI energy: {fci_energy:.5f}\")\n\nccsd_energy = CCSDSolver(mol).simulate()\nprint(f\"CCSD energy: {ccsd_energy:.5f}\")\n\nFCI energy: -5.41008\nCCSD energy: -5.40627"
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html#exploring-approaches-using-resource-estimation-and-problem-decomposition",
    "href": "examples/hardware_experiments/overview_endtoend.html#exploring-approaches-using-resource-estimation-and-problem-decomposition",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "Exploring approaches using resource estimation and problem decomposition ",
    "text": "Exploring approaches using resource estimation and problem decomposition \nNow that we have the reference energy, we can try to tackle the same problem with a quantum computer. In order to do that we have to choose an appropriate quantum algorithm that is able to calculate the ground state energy of a molecule. In this tutorial we choose the VQE algorithm. Note that all the other steps in this pipeline are compatible with other quantum algorithms that can be used for the same purpose (like the phase estimation algorithm). VQE is a popular algorithm, and due to it producing very shallow circuits, it is often the choice for proof of concept demonstrations on near-term quantum hardware. See our VQE notebook for more details about this algorithm. Each quantum algorithm has requirements, i.e. its own unique building blocks and parameters. One important parameter to choose when working with VQE is the choice of strategy to build the parametric wave function (ansatz). At the beginning, we use the vanilla version of a well-known ansatze inspired by the Unitary Coupled Cluster operators in chemistry (a.k.a the UCC ansatze).\nWith this set up in mind, we can leverage Tangelo to estimate the resources required and the cost of this experiment. Later in the document, we show how by leveraging Tangelo and choosing smarter strategies to build an ansazte, one could turn a seemingly intractable problem into one easy to simulate on a quantum hardware. Resource estimation helps us assert the feasibility of an approach with regards to device capabilities (simulator or QPU), or compare it to alternatives, including what is considered state-of-the-art.\nResource estimation is important, as quantum computing is still a nascent field and the current quantum computers have modest capabilities (limited amount of qubits, low gate fidelity, coherence time, etc. It can be one of the drivers of our exploration, and help us identify the most appropriate approaches in our experiments, as well as their bottlenecks, where impactful breakthroughs could make a difference.\nLet’s see what happens when we attempt to tackle our use case with the well-known “standard” VQE algorithm, paired with the UCCSD ansatz and using the Jordan-Wigner (JW) qubit mapping:\n\nfrom tangelo.algorithms.variational import BuiltInAnsatze, VQESolver\n\n# VQE-UCCSD heads-on approach.\nvqe_options = {\"molecule\": mol, \"ansatz\": BuiltInAnsatze.UCCSD, \"qubit_mapping\": \"jw\"}\nvqe_solver = VQESolver(vqe_options)\nvqe_solver.build()\nprint(f\"\\nVQE-UCCSD JW\\n{pp.pformat(vqe_solver.get_resources())}\\n\")\n\n\nVQE-UCCSD JW\n{'circuit_2qubit_gates': 29184,\n 'circuit_depth': 32654,\n 'circuit_var_gates': 1804,\n 'circuit_width': 20,\n 'qubit_hamiltonian_terms': 3591,\n 'vqe_variational_parameters': 350}\n\n\n\nResource requirements show here a quantum circuit that is way beyond the capabilities of current quantum hardware. Although some devices may easily accommodate 20 qubits, the limited coherence time will cause a circuit like this to return nothing but noise. Therefore, even if these many qubits are accessible, executing such a deep circuit would result in the accumulation of noise and would yield irrelevant numerical results.\nEven worse: emulating such a quantum circuit is already a compute-intensive challenge for our classical computers, and can be time-consuming for even top-notch noiseless classical simulators the community has built so far. The numbers of parameters to optimize would require running this circuit many times over, and the size of that space makes converging to accurate results a daunting task in the first place, if not impossible in practice.\n\nProblem decomposition to reduce resource requirements \nProblem decomposition is an approach that can be investigated in order to reduce resource requirements, attempting to find the solution to the initial problem by solving a collection of smaller subproblems. This packages offers several problem decomposition techniques, such as DMET, which is the one we explore here (see DMET and ONIOM notebooks for more details).\nWe decompose more and more aggressively to show the impact on resource requirements, going down to fragments of size one atom. Since all fragments play a identical role in our case, for symmetry reasons, we only focus on one of them and treat the others with CCSD to simplify output and calculations.\nThe get_resources method allows us to peek at some metrics characterizing the fragment circuit, to get a sense of its complexity. What we see is the initial circuit for that particular fragment in our problem instance; we have not yet simulated anything, we merely built the initial objects required for the algorithm.\n\nfrom tangelo.problem_decomposition import DMETProblemDecomposition\nfrom tangelo.problem_decomposition.dmet import Localization\n\n# DMET-VQE, 5 fragments of size 2 atoms each\ndmet_options = {\"molecule\": mol, \"verbose\": False,\n                \"fragment_atoms\": [2]*5, \"fragment_solvers\": [\"vqe\"] + [\"ccsd\"]*4,\n                \"solvers_options\": [{\"qubit_mapping\": \"scBK\", \"initial_var_params\": \"ones\", \n                                     \"up_then_down\": True, \"verbose\": False}] + [{}]*4}\ndmet_solver = DMETProblemDecomposition(dmet_options)\ndmet_solver.build()\nprint(f\"DMET-VQE-UCCSD, 5 fragments \\n{pp.pformat(dmet_solver.get_resources()[0])}\\n\")\n\n# DMET-VQE, 10 fragments of size 1 atom each\ndmet_options = {\"molecule\": mol, \"verbose\": False,\n                \"fragment_atoms\": [1]*10, \"fragment_solvers\": [\"vqe\"] + [\"ccsd\"]*9,\n                \"solvers_options\": [{\"qubit_mapping\": \"scBK\", \"initial_var_params\": \"ones\", \n                                     \"up_then_down\": True, \"verbose\": False}] + [{}]*9}\ndmet_solver = DMETProblemDecomposition(dmet_options)\ndmet_solver.build()\nprint(f\"DMET-VQE-UCCSD, 10 fragments \\n{pp.pformat(dmet_solver.get_resources()[0])}\\n\")\n\nDMET-VQE-UCCSD, 5 fragments \n{'circuit_2qubit_gates': 1072,\n 'circuit_depth': 1461,\n 'circuit_var_gates': 144,\n 'circuit_width': 6,\n 'qubit_hamiltonian_terms': 325,\n 'vqe_variational_parameters': 14}\n\nDMET-VQE-UCCSD, 10 fragments \n{'circuit_2qubit_gates': 4, 'circuit_depth': 14, 'circuit_var_gates': 4, 'circuit_width': 2, 'qubit_hamiltonian_terms': 9, 'vqe_variational_parameters': 2}\n\n\n\nThe next calculation will be carried out with ten fragments of one atom (one fragment and bath orbitals), as depicted in the figure below.\n\n\n\nH10 DMET fragment"
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html#validating-the-desired-approach-with-simulators",
    "href": "examples/hardware_experiments/overview_endtoend.html#validating-the-desired-approach-with-simulators",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "Validating the desired approach with simulators ",
    "text": "Validating the desired approach with simulators \nThe idea behind DMET is to decompose a molecular system into its constituent fragments and its environment. Each fragment is treated independently and recombined at the end to recover the full molecular energy. DMET is an iterative process: at each iteration, the chemical potential is used to adjust both the total number of electrons in the system and in the fragment Hamiltonian. Through the adjustment of the chemical potential, we iterate until the number of electrons in all of the fragments, taken together, becomes equal to the total number of electrons in the entire system, within a user-defined threshold.\nThe algorithm then stops and the electronic structure is returned. For more information, see the DMET notebook on the subject.\nAggressively decomposing this system into 10 fragments of size 1 atom returns resource requirements that seem much more tractable for existing quantum devices, and seem appealing. But we know nothing about the accuracy we can expect from this approach, which relies on VQE to solve our subproblems. The fragments yield quantum circuits of a size that is very manageable for classical simulators, which can support us in the next steps.\n\nClassical simulation of a quantum circuit \nQuantum computers currently have limited access and capability. To study the applications of quantum computing on problem instances of reasonable size, we can use classical simulators and emulators in order to anticipate the behavior of quantum algorithms on real devices, in the presence or absence of noise.\nThis package provides a submodule called linq, which supports a collection of open-source quantum circuit simulators delivering different performance and features. We are free to choose the most relevant backend for our use cases, thinking about resource requirements, use of shots, presence or absence of noise, and accuracy of simulation, for example. Our algorithms manipulate circuits in our own intermediary representation, and a variety of functions exist in order to convert these objects into popular formats, compatible with other open-source tools.\nThe simulate method below runs the DMET algorithm using a simulator backend. We could specify the desired backend in the variable dmet_options described above when creating the DMETProblemDecomposition object. We however did not, and the current default choice is to go for a noiseless simulator: since our package relies on openfermion, which installs cirq as a dependency, cirq will be the default backend unless qulacs is found in your environment. Currently other supported local backends include qiskit and QDK.\n\ndmet_energy = dmet_solver.simulate()\n\n\nprint(f\" DMET-VQE 10 fragments: {dmet_energy:.5f}\\n Difference with FCI: {abs(dmet_energy-fci_energy):E}\")\n\n DMET-VQE 10 fragments: -5.40161\n Difference with FCI: 8.464849E-03"
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html#minimizing-the-amount-of-resources-needed-for-the-hardware-experiment",
    "href": "examples/hardware_experiments/overview_endtoend.html#minimizing-the-amount-of-resources-needed-for-the-hardware-experiment",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "Minimizing the amount of resources needed for the hardware experiment ",
    "text": "Minimizing the amount of resources needed for the hardware experiment \nBoth DMET and VQE are iterative methods: running all the quantum circuits arising in this algorithm with high accuracy on a quantum device would require a number of measurements and runtime beyond what is reasonable on the few quantum processors available today. A more reasonable experiment in the meantime may consist of looking at a single step, and reflect on whether or not this suggests that with more time and resources we could successfully run the whole algorithm on a quantum device, in theory.\nIn the following section, we decide to have a look at the very last step of the DMET-VQE process, for a single fragment: it resulted in a quantum circuit obtained through classical optimization, which can be used to compute the total energy of the system. Because of the symmetry in our use case, the total energy can be calculated by multiplying the fragment energy by the number of fragments. Thanks to the previous section, we know that we can be critical of these results and compare them to the ones obtained with DMET-VQE with a noiseless simulator, or even the FCI results.\nThe quantum_fragments_data attribute of our DMET solver object allows us to retrieve fragment information for those who were mapped to a quantum solver. In the case of VQE, this allows us to access the qubit Hamiltonian and quantum circuit obtained after running simulate.\n\n# Retrieving the DMET fragment information computed with VQE.\nfragment, fragment_qb_ham, fragment_circuit = dmet_solver.quantum_fragments_data[0]\n\nprint(fragment_circuit)\n\nCircuit object. Size 22 \n\nX         target : [0]   \nX         target : [1]   \nRX        target : [0]   parameter : 1.5707963267948966\nRZ        target : [0]   parameter : 3.1415958073076995  (variational)\nRX        target : [0]   parameter : -1.5707963267948966\nRX        target : [1]   parameter : 1.5707963267948966\nRZ        target : [1]   parameter : 3.1415958073076995  (variational)\nRX        target : [1]   parameter : -1.5707963267948966\nRX        target : [0]   parameter : 1.5707963267948966\nH         target : [1]   \nCNOT      target : [1]   control : [0]   \nRZ        target : [1]   parameter : 1.658627529909104   (variational)\nCNOT      target : [1]   control : [0]   \nH         target : [1]   \nRX        target : [0]   parameter : -1.5707963267948966\nH         target : [0]   \nRX        target : [1]   parameter : 1.5707963267948966\nCNOT      target : [1]   control : [0]   \nRZ        target : [1]   parameter : 1.658627529909104   (variational)\nCNOT      target : [1]   control : [0]   \nRX        target : [1]   parameter : -1.5707963267948966\nH         target : [0]   \n\n\n\n\nMinimizing the number of measurements needed \nThe computation of the total energy with DMET requires us to compute the 1- and 2-electron Reduced Density Matrices (1- and 2-RDM). Computing the entries of these matrices requires us to have a look at each term present in the fermionic Hamiltonian of our fragment, apply the same qubit mapping as used in the rest of the DMET algorithm, and compute the expectation value of the resulting qubit operator with regards to our fragment_circuit.\nIt turns out that different entries sometimes require running the fragment_circuit and measuring the qubits in the same computational bases. Since the DMET energy of a molecular system is a real number, it also means that qubit terms with imaginary coefficients are not relevant. Using this information, we scan the RDMs to find what terms/computational bases actually contribute to the calculation, in order to minimize computation.\nInstead of returning them as a list, we agglomerate these terms into a QubitOperator object (a subclass of Openfermion’s QubitOperator), which also keeps track of their prefactor.\n\nfrom tangelo.toolboxes.operators import FermionOperator, QubitOperator\nfrom tangelo.toolboxes.qubit_mappings.mapping_transform import fermion_to_qubit_mapping\n    \n# Find all the measurement bases that are needed to compute the RDMs.\n# Accumulate them in a QubitOperator object to manipulate them afterwards.\nqubit_op_rdm = QubitOperator()\nbases_to_measure = set()\n\nfor term in fragment.fermionic_hamiltonian.terms:\n    \n    # Fermionic term with a prefactor of 1.0.\n    fermionic_term = FermionOperator(term, 1.0)\n\n    qubit_term = fermion_to_qubit_mapping(fermion_operator=fermionic_term, mapping=\"scBK\",\n                                          n_spinorbitals=fragment.n_active_sos,\n                                          n_electrons=fragment.n_active_electrons,\n                                          up_then_down=True)\n    qubit_term.compress()\n\n    # Loop to go through all qubit terms. Keep new non-empty ones, with non-imaginary coefficient\n    for basis, coeff in qubit_term.terms.items():\n        if coeff.real != 0 and basis:\n            bases_to_measure.add(basis)\n            qubit_op_rdm.terms[basis] = coeff\n\npprint(qubit_op_rdm)\n\n0.25 [X0] +\n0.25 [X0 X1] +\n0.25 [X0 Z1] +\n-0.25 [Y0 Y1] +\n0.25 [Z0] +\n0.25 [Z0 X1] +\n0.25 [Z0 Z1] +\n0.25 [X1] +\n0.25 [Z1]\n\n\nAt first glance, 9 computational bases seem necessary, one per qubit term. However we notice that sometimes a single computational basis can be used to compute the expectation value of several of these qubit terms. For instance, the basis required for Z0Z1 could also be used for Z0 and Z1.\nIdentifying these computational bases and mapping them to these qubit operators is equivalent to “grouping” Hamiltonian terms, and allows us to narrow it down further. This is not a trivial problem in general, and several algorithms exist in order to attempt this. Groups are not unique, some may be better than others for different reasons (accuracy, or reducing the number of measurements), and the scaling of these algorithms is of utmost importance on more ambitious problem instances.\nOne of them relies on qubit-wise commutativity, and is shown below. If you would like to know more about this topic, you can have a look at the following references [McClean, J. et al. 2016 and Kandala, A. et al. 2017].\n\nfrom tangelo.toolboxes.measurements import group_qwc\n\nqwc_map = group_qwc(qubit_op_rdm, seed=0)\nprint(f\"Only execute {len(qwc_map)} circuits, instead of {len(qubit_op_rdm.terms)}.\\n\")\npprint(qwc_map)\n\nOnly execute 5 circuits, instead of 9.\n\n{((0, 'X'), (1, 'X')): 0.25 [X0 X1],\n ((0, 'X'), (1, 'Z')): 0.25 [X0] +\n0.25 [X0 Z1] +\n0.25 [Z1],\n ((0, 'Y'), (1, 'Y')): -0.25 [Y0 Y1],\n ((0, 'Z'), (1, 'X')): 0.25 [Z0] +\n0.25 [Z0 X1] +\n0.25 [X1],\n ((0, 'Z'), (1, 'Z')): 0.25 [Z0 Z1]}\n\n\nEach of the measurement bases here allows us to compute the expectation values of all of the terms it’s mapped to, by running a single quantum circuit. We only need to run 5 circuits on a quantum computer in order to compute everything we need. Let’s put them together quickly: each measurement basis simply adds a few extra “change-of-basis gates”, one per qubit at most, at the end of our fragment quantum circuit.\n\nfrom tangelo.linq import Circuit, Gate\nfrom tangelo.linq.helpers.circuits.measurement_basis import measurement_basis_gates\n\n# Creation of XX, XZ, ZX, ZZ and YY circuits.\n# This is done by appending relevant gates to the quantum circuit representing the quantum state.\nquantum_circuit = dict()\nfor basis in bases_to_measure:\n    quantum_circuit[basis] = fragment_circuit + Circuit(measurement_basis_gates(basis))\n\nprint(quantum_circuit[((0, \"Y\"), (1, \"Y\"))])\n\nCircuit object. Size 24 \n\nX         target : [0]   \nX         target : [1]   \nRX        target : [0]   parameter : 1.5707963267948966\nRZ        target : [0]   parameter : 3.1415958073076995  (variational)\nRX        target : [0]   parameter : -1.5707963267948966\nRX        target : [1]   parameter : 1.5707963267948966\nRZ        target : [1]   parameter : 3.1415958073076995  (variational)\nRX        target : [1]   parameter : -1.5707963267948966\nRX        target : [0]   parameter : 1.5707963267948966\nH         target : [1]   \nCNOT      target : [1]   control : [0]   \nRZ        target : [1]   parameter : 1.658627529909104   (variational)\nCNOT      target : [1]   control : [0]   \nH         target : [1]   \nRX        target : [0]   parameter : -1.5707963267948966\nH         target : [0]   \nRX        target : [1]   parameter : 1.5707963267948966\nCNOT      target : [1]   control : [0]   \nRZ        target : [1]   parameter : 1.658627529909104   (variational)\nCNOT      target : [1]   control : [0]   \nRX        target : [1]   parameter : -1.5707963267948966\nH         target : [0]   \nRX        target : [0]   parameter : 1.5707963267948966\nRX        target : [1]   parameter : 1.5707963267948966\n\n\n\n\n\nPicking the number of measurements \nThe more shots (measurements) we take, the more accurate the depiction of our prepared quantum state, which is then used to compute expectation values. On one hand, we would like to take as many as possible for the sake of accuracy. On the other hand, the number of shots is directly related to cost in time and resources of our experiment, which we need to keep within the acceptable budget for the experiment.\nIt makes sense for expectation values of terms with larger coefficients to be computed with higher accuracy (i.e more shots), as the coefficient may amplify any error committed by the quantum computer during its approximation. Conversely, terms with coefficients that are close to zero may individually contribute less, or even not matter, depending on the desired accuracy of the final results. If the expectation values of several qubit terms can be computed using a single computational basis, it would then make sense to pick the number of shots by looking at the one with the biggest coefficient.\nThe community is actively researching ways to provide good estimates, from simple heuristics to more advanced approaches that take into account the problem’s specifics and underlying principles. We look forward to supporting more of them in this package, hopefully with your help!\nBelow, we show you what the numbers would be for a simple heuristic stating that “when we multiply the number of shots by 100, we gain an extra digit of accuracy”, coming from binomial sampling. We use that heuristic on each of our 5 measurement bases, requesting 2 digits of accuracy. In our case, since all qubit terms have a coefficient with absolute value of 0.25, the number of measurements this method returns is identical for all 5 circuits.\n\nfrom tangelo.toolboxes.measurements.estimate_measurements import get_measurement_estimate\n\nmeasurements = {k: get_measurement_estimate(v, digits=2) for k,v in qwc_map.items()}\npprint(measurements)\n\n{((0, 'X'), (1, 'X')): {((0, 'X'), (1, 'X')): 62500},\n ((0, 'X'), (1, 'Z')): {((0, 'X'),): 62500,\n                        ((0, 'X'), (1, 'Z')): 62500,\n                        ((1, 'Z'),): 62500},\n ((0, 'Y'), (1, 'Y')): {((0, 'Y'), (1, 'Y')): 62500},\n ((0, 'Z'), (1, 'X')): {((0, 'Z'),): 62500,\n                        ((0, 'Z'), (1, 'X')): 62500,\n                        ((1, 'X'),): 62500},\n ((0, 'Z'), (1, 'Z')): {((0, 'Z'), (1, 'Z')): 62500}}\n\n\nWe decided to go with 10,000 shots per circuit, as we deemed it to be within acceptable accuracy and mesurement budget constraints. This further emphasizes the need to come up with approaches that reduce the number of measurements needed, and algorithms that can make the most of each measurement, in terms of information and accuracy.\n\nn_shots = 10000\n\n\n\nCircuit compilation and optimization \nThe gate set we use to express our circuits so far contains widely-used generic gates such as H, CNOT and RX, RY, RZ gates. But these are not necessarily part of the native gate set supported by the quantum device this circuit will run on. That is, our circuits must be first expressed in an equivalent sequence of native gates supported by the device. Furthermore, applying gate identities to these circuits may yield simpler equivalent ones requiring a lower amount of gates (or even qubits), which may lead to better accuracy.\nThis overall process of compilation to a native gate set and further optimization of the circuit is challenging, and is usually handled by hardware manufacturers at runtime. Some document and expose these low-level functionalities through their API. In addition to that, there are several open-source projects that specifically target the issue of compilation and circuit optimization for diverse architectures or gate sets: we look towards supporting some of them in the future."
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html#submitting-an-experiment-to-a-quantum-device",
    "href": "examples/hardware_experiments/overview_endtoend.html#submitting-an-experiment-to-a-quantum-device",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "Submitting an experiment to a quantum device",
    "text": "Submitting an experiment to a quantum device\nThis package offers several ways to submit experiments on quantum devices. Below, a few examples of how it is possible to do so through quantum cloud services, and converting your circuit in the relevant formats.\n\nUsing QEMIST Cloud \nThe simplest way to submit an experiment to any device available in the supported quantum cloud services is through QEMIST Cloud’s client library, allowing users to run quantum hardware experiments using their QEMIST Cloud account credentials and credits. This is possible if you have access to QEMIST Cloud, and have installed qemist-client Python package. For more details about this feature, please don’t hesitate to refer to our dedicated notebook, and reach out to us about QEMIST Cloud.\nBelow, a simple code snippet illustrating how to run 10,000 shots of the YY circuit on IonQ’s hardware, through Amazon’s Braket quantum cloud services:\n# Retrieve both these values from your QEMIST Cloud dashboard\nimport os\nos.environ['QEMIST_PROJECT_ID'] = \"your_project_id_string\"\nos.environ['QEMIST_AUTH_TOKEN'] = \"your_qemist_authentication_token\"\n\n# Estimate, submit and get the results of your job / quantum task through our wrappers\nfrom tangelo.linq.qpu_connection import QEMISTCloudConnection\n\nqcloud_connection = QEMISTCloudConnection()\n\ncircuit_YY = quantum_circuit[((0, \"Y\"), (1, \"Y\"))]\n\nprice_estimates = qcloud_connection.job_estimate(circuit_YY, n_shots=n_shots)\nprint(price_estimates)\n\nbackend = 'arn:aws:braket:::device/qpu/ionq/ionQdevice'\n\n# This two commands would respecfully submit the job to the quantum device and make a blocking call\n# to retrieve the results, through a job ID returned by QEMIST Cloud\njob_id = qcloud_connection.job_submit(circuit_YY, n_shots=n_shots, backend=backend)\nfreqs, raw_data = qcloud_connection.job_results(job_id)\nOutput:\n{'arn:aws:braket:::device/qpu/ionq/ionQdevice': 100.3, 'arn:aws:braket:::device/quantum-simulator/amazon/sv1': 3.8, 'arn:aws:braket:us-west-1::device/qpu/rigetti/Aspen-M-1': 3.8}\n\n\nUsing a cloud API and format conversion \nThe utility functions in tangelo.linq allow us to convert our generic Circuit objects into a variety of formats supported by other open-source packages and services, such as Amazon’s Braket and Microsoft’s Azure Quantum.\nYou can thus convert a Circuit object into the desired format and use the API of those services directly in order to reach a QPU or an online simulator if you wish to do so. The example below shows how to convert a Circuit object into the Braket format. Provided that you have a Braket account, the submission process is pretty straightforward, as demonstrated by the documentation\n\nfrom tangelo.linq.translator import translate_circuit\n\nbraket_circuit = translate_circuit(circuit_YY, target=\"braket\")\nprint(braket_circuit)\n\nT  : |0|   1    |   2    |    3    |   4    |5|   6    |7|    8    |   9    |10|   11   |12|   13    |   14   |\n                                                                                                               \nq0 : -X-Rx(1.57)-Rz(3.14)-Rx(-1.57)-Rx(1.57)-C----------C-Rx(-1.57)-H--------C-----------C--H---------Rx(1.57)-\n                                             |          |                    |           |                     \nq1 : -X-Rx(1.57)-Rz(3.14)-Rx(-1.57)-H--------X-Rz(1.66)-X-H---------Rx(1.57)-X--Rz(1.66)-X--Rx(-1.57)-Rx(1.57)-\n\nT  : |0|   1    |   2    |    3    |   4    |5|   6    |7|    8    |   9    |10|   11   |12|   13    |   14   |\n\n\nLikewise, Azure Quantum supports a number of formats. Our package provides similar “translation” functions allowing us to produce a Circuit object into a Q#, qiskit or a cirq format, for example (see cell below) . Provided we have a working Azure Quantum environment, our circuits can be submitted using their API as detailed in the previous link.\n\nfrom tangelo.linq.translator import translate_circuit\n\ncirq_circuit = translate_circuit(circuit_YY, target=\"cirq\")\nprint(cirq_circuit)\n\n0: ───I───X───Rx(0.5π)───Rz(π)───Rx(-0.5π)───Rx(0.5π)───@────────────────@───Rx(-0.5π)───H──────────@────────────────@───H───────────Rx(0.5π)───\n                                                        │                │                          │                │\n1: ───I───X───Rx(0.5π)───Rz(π)───Rx(-0.5π)───H──────────X───Rz(0.528π)───X───H───────────Rx(0.5π)───X───Rz(0.528π)───X───Rx(-0.5π)───Rx(0.5π)───\n\n\n\n\nEmulation on a noisy backend \nSince many open-source packages support noisy simulation and hardware providers put out some information about their devices, you could be interested in performing the noisy simulation of your quantum circuits. In particular, this could help you get an idea of the performance of your algorithm on a target device or get a sense of the performance a device would require for your algorithm to return an answer within the desired accuracy, without requiring access to a QPU.\nWe provide a general interface giving you access to several simulator backends in order to facilitate the simulation of such circuits. You are free to use the “translate” functions of tangelo in order to use the API provided by your favorite open-source package directly if you’d like, as this offers finer control and maybe more features.\nBelow, an example using our generic NoiseModel object and specifying the backend when calling simulate. Here we show an example applying a depolarization channel to specific gates, each with a given probability.\n\nfrom tangelo.linq import get_backend\nfrom tangelo.linq.noisy_simulation import NoiseModel\n\nnmp = NoiseModel()\nnmp.add_quantum_error(\"CNOT\", \"depol\", 0.01)\nnmp.add_quantum_error(\"RZ\", \"depol\", 0.005)\nnmp.add_quantum_error(\"H\", \"depol\", 0.005)\n\nbackend = get_backend(target=\"cirq\", n_shots=n_shots, noise_model=nmp)\n\n\n# Getting frequencies for each circuits.\nfreq_dict = dict()\nfor term, circuit in quantum_circuit.items():\n    freq_dict[term], _ =  backend.simulate(circuit)\n    \npp.pprint(freq_dict[((0, \"Y\"), (1, \"Y\"))])\n\n{'00': 0.3003, '01': 0.2004, '10': 0.2071, '11': 0.2922}"
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html#post-processing",
    "href": "examples/hardware_experiments/overview_endtoend.html#post-processing",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "Post-processing ",
    "text": "Post-processing \nIn our publication, we used the DMET-VQE approach paired with the Qubit Coupled-Cluster (QCC) ansatz, in order to generate our fragment circuits. Although IonQ have their own automated tools to perform quantum circuit compilation and optimization for their device, they had a very close look with us at these circuits, in an attempt to help the quantum device get results as accurate as possible. For further details, you can have a look at figure 1c in our publication.\nIn particular, the compilation and optimization process in that native gate set allowed us to realize that the circuits corresponding to the XZ and ZX bases were identical, up to a reordering of the qubits. This meant that only one of these two circuits was really necessary to run on the device, in order to derive the frequencies for both bases. This anecdote reinforces the need for our community to develop tools to facilitate gaining such insights, as part of larger workflows and more complex problems.\nFor the purpose of our experiments, we thus executed 4 circuits with 10,000 shots each on the device. Using the results, we derived all other quantities relevant to us. In order to reproduce the results studied in our article, we use in the following the values that were obtained from running the circuits run on the device. We use these values to compute one of the data-points presented in our work.\n\n# DMET-QCC experimental frequencies.\nfreq_dict = {((0, \"Z\"), (1, \"Z\")): {\"00\": 0.0093, \"10\": 0.0000, \"01\": 0.0000, \"11\": 0.9907},\n             ((0, \"X\"), (1, \"Z\")): {\"00\": 0.0047, \"10\": 0.0047, \"01\": 0.4959, \"11\": 0.4947},\n             ((0, \"X\"), (1, \"X\")): {\"00\": 0.2059, \"10\": 0.2940, \"01\": 0.2947, \"11\": 0.2054},\n             ((0, \"Y\"), (1, \"Y\")): {\"00\": 0.2854, \"10\": 0.2114, \"01\": 0.2017, \"11\": 0.3015}}\n\n\n# Derived thanks to observations after compilation and optimization: similar to XZ\nfreq_dict[((0, \"Z\"), (1, \"X\"))] = {\"00\": 0.0047, \"10\": 0.4959, \"01\": 0.0047, \"11\": 0.4947}\n\nWe can then compute the expectation values of the different qubit operators of interest by using these frequencies. For simplicity, we manually compute all 9 of them, from the 5 histograms. Note that because the term grouping based on qubit-wise commutativity is not unique, several of these circuits could be used to compute the output of a different computational basis: in our case, it means that we overall have 20,000 shots worth of data by aggregating the two relevant histograms for certain entries,\nWe provide a Histogram helper class and the aggregate_histogram function to facilitate this kind of operation. This data-structure encapsulates the dictionary of frequencies and the number of shots used to build it, which is used as a \"weight\" when aggregating with other histograms. If we keep track of the number of shots used for each computational basis (with a dictionary for example) then it is pretty straightforward to leverage that helper class. In our case it is even easier: all jobs used the name number of shots.\n\nfrom tangelo.toolboxes.post_processing import Histogram, aggregate_histograms\n\n# Turn dictionary of frequencies into Histogram objects\nfreq_hists = {k: Histogram(freqs, n_shots) for k, freqs in freq_dict.items()}\n\n# Compute the other Histogram objects by aggregating the ones obtained in the experiment\nfreq_hists[((0, 'Z'),)] = aggregate_histograms(freq_hists[((0, 'Z'), (1, 'Z'))], freq_hists[((0, 'Z'), (1, 'X'))])\nfreq_hists[((1, 'Z'),)] = aggregate_histograms(freq_hists[((0, 'Z'), (1, 'Z'))], freq_hists[((0, 'X'), (1, 'Z'))])\nfreq_hists[((0, 'X'),)] = aggregate_histograms(freq_hists[((0, 'X'), (1, 'Z'))], freq_hists[((0, 'X'), (1, 'X'))])\nfreq_hists[((1, 'X'),)] = aggregate_histograms(freq_hists[((0, 'Z'), (1, 'X'))], freq_hists[((0, 'X'), (1, 'X'))])\n\nexpectation_values = {term: hist.get_expectation_value(term) for term, hist in freq_hists.items()}\npprint(expectation_values)\n\n{((0, 'X'),): 0.0011999999999999789,\n ((0, 'X'), (1, 'X')): -0.17740000000000003,\n ((0, 'X'), (1, 'Z')): -0.0012000000000000344,\n ((0, 'Y'), (1, 'Y')): 0.17379999999999998,\n ((0, 'Z'),): -0.9813000000000001,\n ((0, 'Z'), (1, 'X')): -0.0012000000000000344,\n ((0, 'Z'), (1, 'Z')): 1.0,\n ((1, 'X'),): 0.0005000000000001115,\n ((1, 'Z'),): -0.9813000000000001}\n\n\nFor a more systematic approach on larger problem instances, it would however be better to reuse the map used for grouping qubit terms earlier, and “reverse” it: that is, associate each desired basis with the set of bases for which a circuit was actually run. Assuming we kept track of shots for each circuit, we could then use a function to compute all entries of freq_dict as weighted average of the frequencies obtained from the device.\nFrom the expectation values, we can then compute the one- and two-electron reduced density matrices:\n\nimport numpy as np\nimport itertools\n\ndef compute_rdms(fragment, expectation_values):\n    onerdm = np.zeros((fragment.n_active_sos,) * 2, dtype=complex)\n    twordm = np.zeros((fragment.n_active_sos,) * 4, dtype=complex)\n\n    for term in fragment.fermionic_hamiltonian.terms:\n        length = len(term)\n\n        # Fermionic term with a prefactor of 1.0.\n        fermionic_term = FermionOperator(term, 1.0)\n\n        qubit_term = fermion_to_qubit_mapping(fermion_operator=fermionic_term, mapping=\"scBK\",\n                                              n_spinorbitals=fragment.n_active_sos,\n                                              n_electrons=fragment.n_active_electrons,\n                                              up_then_down=True)\n        qubit_term.compress()\n\n        # Loop to go through all qubit terms.\n        eigenvalue = 0.\n        for qubit_term, coeff in qubit_term.terms.items():          \n            if coeff.real != 0:\n                exp_val = expectation_values[qubit_term] if qubit_term else 1.\n                eigenvalue += coeff * exp_val\n\n        # Put the values in np arrays (differentiate 1- and 2-RDM)\n        if length == 2:\n            iele, jele = (int(ele[0]) for ele in tuple(term[0:2]))\n            onerdm[iele, jele] += eigenvalue\n        elif length == 4:\n            iele, jele, kele, lele = (int(ele[0]) for ele in tuple(term[0:4]))\n            twordm[iele, lele, jele, kele] += eigenvalue\n\n        onerdm_spinsum = np.zeros((fragment.n_active_mos,)*2, dtype=complex)\n        twordm_spinsum = np.zeros((fragment.n_active_mos,)*4, dtype=complex)\n\n        # Construct spin-summed 1-RDM.\n        for i, j in itertools.product(range(fragment.n_active_sos), repeat=2):\n            onerdm_spinsum[i//2, j//2] += onerdm[i, j]\n\n        # Construct spin-summed 2-RDM.\n        for i, j, k, l in itertools.product(range(fragment.n_active_sos), repeat=4):\n            twordm_spinsum[i//2, j//2, k//2, l//2] += twordm[i, j, k, l]\n\n    return onerdm, twordm, onerdm_spinsum, twordm_spinsum\n\nonerdm, twordm, onerdm_spinsum, twordm_spinsum = compute_rdms(fragment, expectation_values)\n\nFinally, we compute the fragment energy from the 1- and 2-RDMs:\n\ndef compute_electronic_fragment_energy(fragment, onerdm, twordm):\n    \"\"\"Calculate the fragment energy.\"\"\"\n\n    norb = fragment.t_list[0]\n    mo_coeff = fragment.mean_field.mo_coeff\n    fock = fragment.fock\n    oneint = fragment.one_ele\n    twoint = fragment.two_ele\n    \n    # Calculate the one- and two- RDMs for DMET energy calculation (Transform to AO basis).\n    one_rdm = mo_coeff @ onerdm @ mo_coeff.T\n\n    twordm = np.einsum(\"pi,ijkl-&gt;pjkl\", mo_coeff, twordm)\n    twordm = np.einsum(\"qj,pjkl-&gt;pqkl\", mo_coeff, twordm)\n    twordm = np.einsum(\"rk,pqkl-&gt;pqrl\", mo_coeff, twordm)\n    twordm = np.einsum(\"sl,pqrl-&gt;pqrs\", mo_coeff, twordm)\n\n    # Calculate fragment expectation value.\n    fragment_energy_one_rdm = 0.25 * np.einsum(\"ij,ij-&gt;\", one_rdm[: norb, :], fock[: norb, :] + oneint[: norb, :]) \\\n        + 0.25 * np.einsum(\"ij,ij-&gt;\", one_rdm[:, : norb], fock[:, : norb] + oneint[:, : norb])\n\n    fragment_energy_twordm = 0.125 * np.einsum(\"ijkl,ijkl-&gt;\", twordm[: norb, :, :, :], twoint[: norb, :, :, :]) \\\n        + 0.125 * np.einsum(\"ijkl,ijkl-&gt;\", twordm[:, : norb, :, :], twoint[:, : norb, :, :]) \\\n        + 0.125 * np.einsum(\"ijkl,ijkl-&gt;\", twordm[:, :, : norb, :], twoint[:, :, : norb, :]) \\\n        + 0.125 * np.einsum(\"ijkl,ijkl-&gt;\", twordm[:, :, :, : norb], twoint[:, :, :, : norb])\n\n    fragment_energy = fragment_energy_one_rdm + fragment_energy_twordm\n    \n    return fragment_energy.real\n\n\n# Compute fragment energy as core repulsion fragment energy plus electron-correlation energy\ncore_constant = dmet_solver.orbitals.core_constant_energy / 10\ne_fragment = compute_electronic_fragment_energy(fragment, onerdm_spinsum, twordm_spinsum) + core_constant\nprint(f\" DMET-VQE QCC 1 fragment: {e_fragment:.5f}\\n Difference with FCI: {abs(e_fragment-(fci_energy/10)):E}\")\n\n DMET-VQE QCC 1 fragment: -0.55205\n Difference with FCI: 1.104160E-02\n\n\n\nError mitigation \nThe next step in our post-processing is focused on error mitigation. Due to noise, the hardware produces a mixed state, which reduces the accuracy of our observables. The ultimate tool against noise is error correction. However, employing error correction is prohibitively expensive in terms of the quantum resources required and out of reach of near-term quantum hardware (hence the “Noisy” in NISQ). Although error correction is not currently available, we can still utilize clever ideas and leverage the known symmetries of the input problem to post-process the raw results coming form the hardware to mitigate the noise to some extent. Tangelo aims to provide a collection of noise mitigation techniques.\nAs an error-mitigation strategy in our DMET experiment, we use a density matrix purification technique based on McWeeny’s purification method [Truflandier et al., 2016] to purify our noisy state to the dominant eigenvector. This is an iterative method which imposes the idempotency condition according to:\n\\[ P^{\\text{new}}_{pqrs}=3(P^{\\text{old}}_{pqrs})^{2}-2(P^{\\text{old}}_{pqrs})^{3}\\]\nFor our particular experiment, we can use this method for the 2-RDM since our fragments consist of two electrons – thus the 2-RDM is the full density matrix, and idempotency can be imposed. In general, applying the technique to 2-RDMs of higher electron systems would require the more sophisticated N-representability conditions [Rubin et al., 2018].\n\nfrom tangelo.toolboxes.post_processing.mc_weeny_rdm_purification import mcweeny_purify_2rdm\n\nonerdm_spinsum, twordm_spinsum = mcweeny_purify_2rdm(twordm.real, conv=1e-2)\ne_pure_fragment = compute_electronic_fragment_energy(fragment, onerdm_spinsum, twordm_spinsum) + core_constant\nprint(f\" DMET-VQE QCC 1 fragment: {e_pure_fragment:.5f}\\n Difference with FCI: {abs(e_pure_fragment-(fci_energy/10)):E}\")\n\n DMET-VQE QCC 1 fragment: -0.54020\n Difference with FCI: 8.035695E-04\n\n\n\n\nStatistical analysis of results \nExperimental data requires a measure of its uncertainty. As it is often prohibitively expensive to collect large amount of data on quantum computers for the purpose of estimating uncertainty, we generate statistics from our dataset using an established method called bootstrapping [Efron, B. et al., 1994]. For each histogram obtained from our experiment, we resample with replacement from that distribution to generate new histograms of the same sample size. We then use these histograms to calculate a new set of expectation values, RDMs, and total energies. This process is repeated many times, and from those outcomes we calculate the average energy and standard deviation of our experiment.\nIn our publication, this process was repeated 10,000 times and led to a result of -0.540 ±0.007 Hartree.\n\n# Bootstrap method.\nfragment_energies = list()\n\nfor n in range(1000): # Was 10000 in our publication\n    \n    # Step 1-2: draw random bootstrap sample and construct new histograms.\n    resample_freq = {term: hist.resample(n_shots) for term, hist in freq_hists.items()}\n    \n    # Step 3-4: compute expectation values.\n    expectation_values = {term: hist.get_expectation_value(term) for term, hist in resample_freq.items()}\n    \n    # Step 5: construct 1- and 2-RDMs.\n    onerdm, twordm, _, _ = compute_rdms(fragment, expectation_values)\n    onerdm_spinsum, twordm_spinsum = mcweeny_purify_2rdm(twordm.real, conv=1e-2)\n    \n    # Step 6: calculate the total energy.\n    e_fragment = compute_electronic_fragment_energy(fragment, onerdm_spinsum, twordm_spinsum) + core_constant\n    fragment_energies.append(e_fragment)\n    \n    # Step 7: Repeat steps 1-6.\n    \n# Step 8: calculate the mean and standard deviation.\nmean = np.mean(fragment_energies)\nstdev = np.std(fragment_energies, ddof=1)\nprint(f\" Bootstrap DMET-VQE QCC energy {mean:.4f}±{stdev:.4f}.\")\n\n Bootstrap DMET-VQE QCC energy -0.5394±0.0059.\n\n\nThis is in agreement with the published results [Kawashima et al., 2021], which repeats this overall workflow for various H-H distances and thoroughly analyzes repulsive, equilibrium, attractive and dissociative regimes.\n\n\n\nDMET published H10 results"
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html#closing-words",
    "href": "examples/hardware_experiments/overview_endtoend.html#closing-words",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "Closing words ",
    "text": "Closing words \nThis notebook showed how Tangelo can assist us in implementing end-to-end workflows, which can lead to successful hardware experiments and peer-reviewed publications in the field.\nOn the one hand, it highlights how problem decomposition can make larger molecular systems amenable to NISQ devices, in combination with pre- and post-processing methods aiming at reducing resource requirements or improving accuracy. Such approaches may play an essential role in applying quantum computers to the study of larger, industrially relevant, chemical systems.\nOn the other hand, it illustrates the complexity of such experiments and the necessity for the community to keep developing tools that can be articulated together to cover elaborate end-to-end workflows. From a molecule, we have built a quantum computing experiment which involved numerous steps, some related to quantum chemistry algorithms, some tackling the challenges of practical experiments on quantum computers.\nWe look forward to further developing these tools with the help of the community, in order to both take us a step closer to making quantum computing applicable to real-world problems, but also simply to give you the satisfaction of running a successful experiment yourself soon."
  },
  {
    "objectID": "examples/hardware_experiments/overview_endtoend.html#references",
    "href": "examples/hardware_experiments/overview_endtoend.html#references",
    "title": "End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo",
    "section": "References",
    "text": "References\n\nEfron, B. & Tibshirani, R. J. An Introduction to the Bootstrap (CRC press, 1994))\nKassal, I., Whitfield, J. D., Perdomo-Ortiz, A., Yung, M.-H. & Aspuru-Guzik, A. Simulating Chemistry Using Quantum Computers. Annual Review of Physical Chemistry 62, 185–207 (2011).\nKnizia, G. & Chan, G. K. L. Density matrix embedding: A simple alternative to dynamical mean-field theory. Physical Review Letters 109, 186404–186404 (2012).\nKnizia, G. & Chan, G. K. L. Density matrix embedding: A strong-coupling quantum embedding theory. Journal of Chemical Theory and Computation 9, 1428–1432 (2013).\nPeruzzo, A. et al. A variational eigenvalue solver on a quantum processor. Nature Communications 5, 4213–4213 (2013).\nL. A. Truflandier, R. M. Dianzinga, and D. R. Bowler,Generalized canonical purification for density matrixminimization, J. Chem. Phys. 144, 091102 (2016).\nMcClean, J., Romero, J., Babbush, R. & Aspuru-Guzik, A.. The theory of variational hybrid quantum-classical algorithms. New J. Phys. 18 023023 (2016).\nMcClean, J., Romero, J., Babbush, R. & Aspuru-Guzik, A.. The theory of variational hybrid quantum-classical algorithms. New J. Phys. 18 023023 (2016).\nN. C. Rubin, R. Babbush, and J. McClean, Application of fermionic marginal constraints to hybrid quantum algorithms, New Journal of Physics 20, 053020 (2018).\nCao, Y. et al. Quantum Chemistry in the Age of Quantum Computing. Chemical Reviews 119, 10856–10915 (2019).\nY. Nam, J.-S. Chen, N. C. Pisenti, K. Wright, C. Delaney, D. Maslov, K. R. Brown, S. Allen, J. M. Amini, J. Apisdorf, K. M. Beck, A. Blinov, V. Chaplin, M. Chmielewski, C. Collins, S. Debnath, A. M. Ducore, K. M. Hudek, M. Keesan, S. M. Kreikemeier, J. Mizrahi, P. Solomon, M. Williams, J. D. Wong-Campos, C. Monroe, and J. Kim, Ground-state energy estimation of the water molecule on a trapped ion quantum computer, npj Quantum Information 6, 33 (2019).\nKawashima, Y. et al. Efficient and Accurate Electronic Structure Simulation Demonstrated on a Trapped-Ion Quantum Computer. arXiv:2102.07045 [quant-ph] (2021).\nBharti, K. et al. Noisy intermediate-scale quantum (NISQ) algorithms. arXiv:2101.08448 [quant-ph] (2021)."
  },
  {
    "objectID": "examples/hardware_experiments/berylium_ibm_quantum.html",
    "href": "examples/hardware_experiments/berylium_ibm_quantum.html",
    "title": "Combining Tangelo, QEMIST Cloud and IBM Quantum for quantum experiments",
    "section": "",
    "text": "This notebook demonstrates how problem decomposition from QEMIST Cloud can be combined with Tangelo and IBM’s technology, in order to apply quantum computing to the study of chemical systems. It supported a brief presentation made at IBM Quantum Summit 2022, available on Youtube. We meant to showcase how these different software can be combined, and how experiment on IBM Quantum are streamlined with Tangelo. We do not comment on the numerical results, as they are not the focus.\nThe use case for this study is a single Berylium atom in the cc-PVDZ basis. Tackled head-on with an algorithm such as VQE, this problem would require more than 25 qubits, and deep quantum circuits (thousands of gates for UCCSD). By approaching this problem with a more elaborate approach, it is possible to make this system more tractable for current devices and reduce resource requirements to about 6 qubits and much shallower circuits.\nHere, we implement a workflow combining problem decomposition (MI-FNO), a quantum algorithm (custom QCC ADAPT approach), the IBM Kolkata device, and several post-processing techniques offered by IBM including Zero-Noise Extrapolation (ZNE). We share the experimental results obtained when attempting to compute the energy of a fragment of the system, using different noise-mitigation techniques available on the IBM devices.\nWe refer the reader to various dedicated notebook tutorials about the different techniques mentioned above, and detail some of them in the following sections."
  },
  {
    "objectID": "examples/hardware_experiments/berylium_ibm_quantum.html#setting-up-the-environment",
    "href": "examples/hardware_experiments/berylium_ibm_quantum.html#setting-up-the-environment",
    "title": "Combining Tangelo, QEMIST Cloud and IBM Quantum for quantum experiments",
    "section": "Setting up the environment",
    "text": "Setting up the environment\nThe installation of Tangelo, Qiskit and Qiskit-runtime is required for this notebook.\nIn order to perform problem decomposition in QEMIST Cloud, users need to sign up and install the client library in their environment. For simplicity, this notebook simply loads pre-computed MI-FNO results obtained from a previous run on QEMIST Cloud, and focuses on the quantum side of things.\n\n# Install: Tangelo, here directly from the develop branch on Github\n!pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet\n\n# Install: qiskit, qiskit-runtime\n!pip install qiskit --quiet\n!pip install qiskit-ibm-runtime --quiet\n\n  Preparing metadata (setup.py) ... done\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 240.4/240.4 KB 8.1 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1.1/1.1 MB 42.6 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1.8/1.8 MB 60.4 MB/s eta 0:00:00\n  Preparing metadata (setup.py) ... done\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 577.4/577.4 KB 42.1 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2.0/2.0 MB 46.6 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 120.2/120.2 KB 13.8 MB/s eta 0:00:00\n  Building wheel for tangelo-gc (setup.py) ... done\n  Building wheel for pubchempy (setup.py) ... done\n  Preparing metadata (setup.py) ... done\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 5.1/5.1 MB 45.0 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 12.8/12.8 MB 74.7 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 241.3/241.3 KB 15.5 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 107.0/107.0 KB 11.6 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 54.3/54.3 KB 6.5 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1.9/1.9 MB 81.4 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 50.0/50.0 KB 5.7 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 37.5/37.5 MB 23.6 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 49.6/49.6 KB 5.6 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 4.2/4.2 MB 85.2 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 112.7/112.7 KB 12.2 MB/s eta 0:00:00\n  Building wheel for qiskit (setup.py) ... done\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 190.4/190.4 KB 7.9 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 245.8/245.8 KB 24.7 MB/s eta 0:00:00\n  Installing build dependencies ... done\n  Getting requirements to build wheel ... done\n  Preparing metadata (pyproject.toml) ... done\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 140.6/140.6 KB 14.9 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 62.8/62.8 KB 7.0 MB/s eta 0:00:00\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 50.5/50.5 KB 5.3 MB/s eta 0:00:00\n  Installing build dependencies ... done\n  Getting requirements to build wheel ... done\n  Preparing metadata (pyproject.toml) ... done\n  Building wheel for ibm-platform-services (pyproject.toml) ... done\n  Building wheel for ibm-cloud-sdk-core (pyproject.toml) ... done"
  },
  {
    "objectID": "examples/hardware_experiments/berylium_ibm_quantum.html#define-use-case",
    "href": "examples/hardware_experiments/berylium_ibm_quantum.html#define-use-case",
    "title": "Combining Tangelo, QEMIST Cloud and IBM Quantum for quantum experiments",
    "section": "Define use case",
    "text": "Define use case\nBriefly redefining our molecular system locally: a single berylium atom in the ccPVDZ basis.\n\n# Our molecular system\nBe_coordinates = \"\"\"\n    Be    0.0000   0.0000   0.0000\n\"\"\"\nbasis = \"cc-pVDZ\"\ncharge = 0 \nspin = 0\n\n#1. Importing QEMIST Cloud fragments into Tangelo\nThe Method of Increment with Frozen Natural Orbital (MI-FNO) was previously run with QEMIST Cloud, for our system of interest: a single atom of berylium in the ccPVDZ basis. The Heat-Bath CI (HBCI) classisal solver was used to solve individual fragments resulting from the MI-FNO decomposition.\nDedicated notebooks cover these steps. We load the pre-computed fragment information and references values. This system is small, and yields two one-body fragments and a single two-body fragment. The MIFNOHelper class enables us to load fragment data, and see how each of them contributes to the total energy of the system.\n\n# Load pre-computed MI-FNO data, obtained with QEMIST Cloud\n!unzip -qq ./data/Be_iso_VS1.zip\n\n\nfrom tangelo.problem_decomposition import MIFNOHelper\n\nfno_fragments = MIFNOHelper(mi_json_file=\"./Be_iso_VS1/16435123521074770.json\", fno_json_folder=\"./Be_iso_VS1/frags\")\nprint(fno_fragments)\n\nfno_fragments.retrieve_mo_coeff(\"./Be_iso_VS1/frags\")\n\n(All the energy values are in hartree)\nTotal MI-FNO energy = -14.60874953362714\nCorrelation energy = -0.03641190267375371\nMean-field energy = -14.572337630953388\n         epsilon     problem_handle  energy_correlation  correction  \\\n(0,)   -0.000226  67697585423398483           -0.000226   -0.000161   \n(1,)   -0.031890  24334728019588691           -0.031890   -0.017285   \n(0, 1) -0.004297   2147133126882914           -0.036412   -0.019480   \n\n        energy_total  \n(0,)      -14.572563  \n(1,)      -14.604227  \n(0, 1)    -14.608750"
  },
  {
    "objectID": "examples/hardware_experiments/berylium_ibm_quantum.html#visualization-of-results",
    "href": "examples/hardware_experiments/berylium_ibm_quantum.html#visualization-of-results",
    "title": "Combining Tangelo, QEMIST Cloud and IBM Quantum for quantum experiments",
    "section": "5. Visualization of results",
    "text": "5. Visualization of results\nWe cleaned up and tested this notebook several weeks after running our experiment on Kolkata (Oct 2022), and the values from the cells above were obtained on other backends, for convenience. When we ran those calculations on Kolkata, we obtained the numerical results below. We plug them into the final cell, which illustrates how we built the final visualization of the results with matplotlib.\nAs you can see, the roem3 datapoint shows that in our experiment the additional CNOTs definitely amplified the noise and degraded the results of the calculation: the outcome was even worse than raw results.\n\n# Data obtained with Kolkata in October 2022, for the final plot\ndata_raw      = (-14.57206231, 0.00009134)\ndata_roem     = (-14.58389566, 0.00009584)\ndata_roem3    = (-14.58061396, 0.00010080)\ndata_roem_zne = (-14.58553651, 0.00015234)\n\nLet’s plot these results. The dashed line shows the mean-field energy, the continuous line the exact MI-FNO energy, and the gray band what is within chemical accuracy.\n\nimport matplotlib.pyplot as plt\n\ne_ref_frag = fno_fragments[frag][\"energy_total\"] - fno_fragments[frag][\"correction\"]\ne_hf_frag = mol.mf_energy\nchem_acc_error = 1.59e-3\n\nfig,ax   = plt.subplots(1,1,figsize=(6,8))\nfig.subplots_adjust(hspace=0.0,wspace=0.0,bottom=0.25,left=0.2,top=0.7)\n\nax.axhline(e_hf_frag,ls='--',color='gray')\nax.axhline(e_ref_frag,ls='-',color='black')\nax.axhspan(e_ref_frag - chem_acc_error, e_ref_frag + chem_acc_error, color='gray',alpha=0.2)\n\nax.errorbar([0],data_raw[0],yerr=data_raw[1], marker='o', capsize=12,ms=10,mew=2,mec='b')\nax.errorbar([1],data_roem[0],yerr=data_roem[1],marker='D',capsize=12,ms=10,mew=2,mec='r')\nax.errorbar([2],data_roem_zne[0],yerr=data_roem_zne[1],marker='s',capsize=12,ms=10,mew=2,mec='g')\n\nax.set_ylabel('E [Hartree]');\nax.set_xticks([0,1,2]); ax.set_xticklabels(['RAW','ROEM','ROEM+ZNE'],rotation=15,ha='right',fontsize=10);\n\nprint(f\"Energy difference between exact value and ZNE results: {abs(e_ref_frag - data_roem_zne[0]):.3e}\\n\")\n\nEnergy difference between exact value and ZNE results: 1.406e-03"
  },
  {
    "objectID": "examples/chemistry/excited_states.html",
    "href": "examples/chemistry/excited_states.html",
    "title": "Excited States in Tangelo",
    "section": "",
    "text": "Open In Colab"
  },
  {
    "objectID": "examples/chemistry/excited_states.html#introduction",
    "href": "examples/chemistry/excited_states.html#introduction",
    "title": "Excited States in Tangelo",
    "section": "Introduction",
    "text": "Introduction\nOne impactful application of quantum chemistry, in both academia and industry, is the study of the interaction of light with matter. Absorption (resp. emission) of a photon by a molecule can promote (resp. demote) an electron from a lower (resp. higher) electronic state to a higher (resp. lower) energy electronic state. The photon wavelength (i.e. energy) required for these transitions to occur is determined by the difference between the two respective electronic states. Therefore, it is imperative to be able to calculate accurate energies for both ground and excited states to study light/matter interations. These energy differences play a central role in many technologies such as solar panels, light-emitting diodes (LED), displays, and colorants.\nTo be more concrete, a colorant must emit light in a narrow region in the visible spectrum to be appropriate for the purpose, that is to say it must exhibit a specific wavelength. Another example is solar panels, where the absorption spectrum of a molecule is tuned via chemical functionalization to fit the solar emission spectrum to optimize the energy output efficiency. Here we show an example of a spectrum for the BODIPY molecule, a molecule widely used for fluorescent dyes. BODIPY absorbs light at a lower wavelength (higher energy) and emits light at a higher wavelength (lower energy). To compute this spectrum, one needs to calculate the ground and excited state energies and calculate their intensities. The absorption spectrum for the simplest BODIPY is shown below. Different absorption and emission wavelengths can be targeted by substituting the hydrogen atoms with different functional groups J. Chem. Phys. 155, 244102 (2021).\n\n\n\nBODIPY\n\n\nAs there are a very large number of compounds to be considered, predicting absorption/emission UV-visible spectra would be a valuable asset to the scientific community.\nTo achieve complete understanding of light interaction with a molecule, the quantum chemistry community has worked on several algorithms. In general, one must compute the relevant molecular electronic structures for the prediction of UV light absorption/emission. This notebook shows how Tangelo enables excited states calculations by implementing a few existing quantum algorithms. These are broadly grouped into variational optimization algorithms and algorithms that rely on Hamiltonian simulation. Along the way, we keep track of the quantum computational resources required by each of these approaches, and summarize this information at the end of the notebook. The use case here is Li \\(_2\\) for expediency but many of these quantum algorithms can, in principle, be extended to much larger systems such as the BODIPY molecule above.\nIt is worth noting that even with all the computed excited states, non-trivial effects can happen (solvation effect, geometry change, etc.) in which all modify the shape of a spectrum. In this notebook, we do not discuss how these effects are accounted for, but the calculations presented here are the necessary first steps towards computing excited states."
  },
  {
    "objectID": "examples/chemistry/excited_states.html#installation-background",
    "href": "examples/chemistry/excited_states.html#installation-background",
    "title": "Excited States in Tangelo",
    "section": "Installation & Background",
    "text": "Installation & Background\nIn order to successfully run this notebook, you need to install Tangelo. It is also important to be somewhat familiar with the variational quantum eigensolver (VQE). Information about VQE can be found in our VQE with Tangelo notebook. Information about each algorithm can be found by following the references linked when each method is introduced. The cell below installs Tangelo in your environment, if it has not been done already.\n\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet\n\n# Download the data folder at https://github.com/goodchemistryco/Tangelo-Examples/tree/main/examples/chemistry/data\nimport os\nif not os.path.isdir(\"data\"):\n    !sudo apt install subversion\n    !svn checkout https://github.com/goodchemistryco/Tangelo-Examples/branches/main/examples/chemistry/data"
  },
  {
    "objectID": "examples/chemistry/excited_states.html#table-of-contents",
    "href": "examples/chemistry/excited_states.html#table-of-contents",
    "title": "Excited States in Tangelo",
    "section": "Table of Contents",
    "text": "Table of Contents\n\n1. Obtaining excited state energies classically\n2. Variational optimization algorithms\n\n2.1 VQE for lowest singlet and triplet state\n2.2 VQE Deflation\n2.3 Quantum Subspace Expansion\n2.4 State-Averaged VQE\n2.5 Multi-state contracted VQE (MC-VQE)\n2.6 State-Averaged VQE with deflation\n2.7 State-Averaged Orbital-Optimized VQE\n\n3. Hamiltonian Simulation algorithms\n\n3.1 Multi-Reference Selected Quantum Krylov\n3.2 Rodeo Algorithm\n\n4. Closing words\n\nThe molecular system we use to illustrate a number of excited state algorithms in this notebook is Li \\(_2\\) near its equilibrium geometry. The full calculation of the Li \\(_2\\) energies would be non-trivial and very computationally expensive; we therefore restrict ourselves to an active space of 2 electrons in 2 orbitals which involve 4 qubits when mapped to a qubit Hamiltonian using the Jordan-Wigner mapping. However, there are still non-trivial effects that occur with this small problem, made particularly evident in section 2.7. We define two molecule objects:\n\nmol_li2 defined as the ground state configuration with 2 electrons in the HOMO.\nmol_li2_t defined as the triplet configuration with an alpha electron in each of the HOMO and LUMO.\n\n\nfrom tangelo import SecondQuantizedMolecule as SQMol\nli2=  \"\"\"Li 0.  0. 0.\n         Li 3.0 0. 0. \"\"\"\n\n# 2 electrons in 2 orbitals\nfo = [0,1]+[i for i in range(4,28)]\n\n# Runs RHF calculation\nmol_Li2 = SQMol(li2, q=0, spin=0, basis='6-31g(d,p)', frozen_orbitals=fo, symmetry=True)\n\n# Runs ROHF calculation\nmol_Li2_t = SQMol(li2, q=0, spin=2, basis=\"6-31g(d,p)\", frozen_orbitals=fo, symmetry=True)\n\nSince we set symmetry=True in the initialization, the symmetry labels of all the orbitals have been populated in mol_li2.mo_symm_labels.\n\n# Symmetry labels and occupations for frozen core and active orbitals\nprint(\"  #  Energy  Symm Occ\")\nfor i in range(4):\n    print(f\"{i+1:3d}{mol_Li2.mo_energies[i]: 9.4f}  {mol_Li2.mo_symm_labels[i]}   {int(mol_Li2.mo_occ[i])}\")\n\n# Active electrons, Active orbitals\nprint(f\"Number of active electrons: {mol_Li2.n_active_electrons}\")\nprint(f\"Number of active orbtials: {mol_Li2.n_active_mos}\")\n\n  #  Energy  Symm Occ\n  1  -2.4478  A1g   2\n  2  -2.4478  A1u   2\n  3  -0.1716  A1g   2\n  4   0.0129  A1u   0\nNumber of active electrons: 2\nNumber of active orbtials: 2\n\n\nWe can examine the molecular orbitals by exporting them as cube files. These can then be read in by your favourite orbital viewer.\nfrom pyscf.tools import cubegen\n# Output cube files for active orbitals\nfor i in [2, 3]:\n    cubegen.orbital(mol_Li2.to_pyscf(basis = mol_Li2.basis), f'li2_{i+1}.cube', mol_Li2.mean_field.mo_coeff[:, i])"
  },
  {
    "objectID": "examples/chemistry/excited_states.html#obtaining-excited-state-energies-classically",
    "href": "examples/chemistry/excited_states.html#obtaining-excited-state-energies-classically",
    "title": "Excited States in Tangelo",
    "section": "1. Obtaining excited state energies classically ",
    "text": "1. Obtaining excited state energies classically \nIn order to compare the various quantum algorithms, it is useful to have the classically calculated values. Below we will calculate the two A1g and A2g states using PySCF CASCI implementation (https://pyscf.org/user/mcscf.html).\n\nfrom pyscf import mcscf\n\nmyhf = mol_Li2.mean_field\nncore = {\"A1g\": 1, \"A1u\": 1}\nncas = {\"A1g\": 1, \"A1u\": 1}\n\nprint(\"Calculation for A1g symmetry\")\nmc = mcscf.CASCI(myhf, 2, (1, 1))\nmo = mc.sort_mo_by_irrep(cas_irrep_nocc=ncas, cas_irrep_ncore=ncore)\nmc.fcisolver.wfnsym = \"A1g\"\nmc.fcisolver.nroots = 2\nemc_A1g = mc.casci(mo)[0]\n\nprint(\"\\n Calculation for A1u symmetry\")\nmc = mcscf.CASCI(myhf, 2, (1, 1))\nmc.fcisolver.wfnsym = \"A1u\"\nmc.fcisolver.nroots = 2\nemc_A1u = mc.casci(mo)[0] \n\nCalculation for A1g symmetry\n\nWARN: Mulitple states found in CASCI solver. First state is used to compute the Fock matrix and natural orbitals in active space.\n\nCASCI state 0  E = -14.8696203037798  E(CI) = -0.575225247721381  S^2 = 0.0000000\nCASCI state 1  E = -14.6801959955889  E(CI) = -0.385800939530508  S^2 = 0.0000000\n\n Calculation for A1u symmetry\n\nWARN: Mulitple states found in CASCI solver. First state is used to compute the Fock matrix and natural orbitals in active space.\n\nCASCI state 0  E = -14.8387663453888  E(CI) = -0.544371289330403  S^2 = 2.0000000\nCASCI state 1  E = -14.7840383314395  E(CI) = -0.489643275381141  S^2 = 0.0000000"
  },
  {
    "objectID": "examples/chemistry/excited_states.html#variational-algorithms",
    "href": "examples/chemistry/excited_states.html#variational-algorithms",
    "title": "Excited States in Tangelo",
    "section": "2. Variational algorithms",
    "text": "2. Variational algorithms\nWe start by showing how different approaches based on VQE can be used to obtain excited states. For more information about VQE and the VQESolver class, feel free to have a look at our dedicated tutorials.\n\n2.1 VQE for lowest singlet and triplet states \nBoth the lowest singlet (ground state) and lowest triplet (first excited state) can be computed using VQESolver. The FCISolver class can be used to produce a classically-computed reference value, to get a sense of the accuracy of VQE in this situation. Along the way, we capture the quantum computational resources required for each algorithm in the dictionary algorithm_resources.\n\nfrom tangelo.algorithms.variational import VQESolver, BuiltInAnsatze\nfrom tangelo.algorithms.classical import FCISolver\n\n# Dictionary of resources for each algorithm\nalgorithm_resources = dict()\n\n# Ground state energy calculation with VQE, reference values with FCI\nvqe_options = {\"molecule\": mol_Li2, \"ansatz\": BuiltInAnsatze.UCCSD}\nvqe_solver = VQESolver(vqe_options)\nvqe_solver.build()\nvqe_energy = vqe_solver.simulate()\nprint(\"\\n Ground Singlet state\")\nprint(f\"VQE energy = {vqe_energy}\")\nprint(f\"CASCI energy = {FCISolver(mol_Li2).simulate()}\")\nalgorithm_resources[\"vqe_ground_state\"] = vqe_solver.get_resources()\n\n# First excited state energy calculation with VQE, reference values with FCI\nvqe_options = {\"molecule\": mol_Li2_t, \"ansatz\": BuiltInAnsatze.UpCCGSD}\nvqe_solver_t = VQESolver(vqe_options)\nvqe_solver_t.build()\nvqe_energy_t = vqe_solver_t.simulate()\nprint(\"\\n Lowest Triplet state\")\nprint(f\"VQE energy = {vqe_energy_t}\")\nprint(f\"CASCI energy = {FCISolver(mol_Li2_t).simulate()}\")\nalgorithm_resources[\"vqe_triplet_state\"] = vqe_solver_t.get_resources()\n\n\n Ground Singlet state\nVQE energy = -14.869620302757237\nCASCI energy = -14.869620303779788\n\n Lowest Triplet state\nVQE energy = -14.853462489026848\nCASCI energy = -14.853462489027107\n\n\n\n\n2.2 VQE Deflation \nDeflation can be used to gradually obtain higher and higher excited states, by applying an orthogonality penalty against all previous VQE calculations. This idea was introduced in arXiv:2205.09203.\nThis approach can be implented by using the deflation options built in the VQESolver class:\n\nThe keyword \"deflation_circuits\" allows the user to provide a list of circuits to use in the deflation process.\nAdditionally, the keyword \"deflation_coeff\" allows a user to specify the weight in front of the penalty term. This coefficient must be larger than the difference in energy between the ground and the target excited state.\n\n\n# Add initial VQE optimal circuit to the deflation circuits list\ndeflation_circuits = [vqe_solver.optimal_circuit.copy()]\n\n# Calculate first and second excited states by adding optimal circuits to deflation_circuits\nfor i in range(2):\n    vqe_options = {\"molecule\": mol_Li2, \"ansatz\": BuiltInAnsatze.UpCCGSD, \n                   \"deflation_circuits\": deflation_circuits, \"deflation_coeff\": 0.4}\n    vqe_solver = VQESolver(vqe_options)\n    vqe_solver.build()\n    vqe_energy = vqe_solver.simulate()\n    print(f\"Excited state #{i+1} \\t VQE energy = {vqe_energy}\")\n    algorithm_resources[f\"vqe_deflation_state_{i+1}\"] = vqe_solver.get_resources()\n\n    deflation_circuits.append(vqe_solver.optimal_circuit.copy())\n\nExcited state #1     VQE energy = -14.784037073785134\nExcited state #2     VQE energy = -14.680196061799991\n\n\nThe deflation above generated the singlet states. Sometimes it is useful to use a different reference state. In the next example of deflation, we use a reference state with 2 alpha electrons and 0 beta electrons to calculate the triplet state. The reference state is defined by alternating up then down ordering, which yields {\"ref_state\": [1, 0, 1, 0]} for 2 alpha electrons in 2 orbitals for this situation.\n\nvqe_options = {\"molecule\": mol_Li2, \"ansatz\": BuiltInAnsatze.UpCCGSD, \n               \"deflation_circuits\": deflation_circuits,\n               \"deflation_coeff\": 0.4, \"ref_state\": [1, 0, 1, 0]}\nvqe_solver_triplet = VQESolver(vqe_options)\nvqe_solver_triplet.build()\nvqe_energy = vqe_solver_triplet.simulate()\nprint(f\"VQE energy = {vqe_energy}\")\nalgorithm_resources[f\"vqe_deflation_state_{3}\"] = vqe_solver_triplet.get_resources()\n\nVQE energy = -14.838766345424574\n\n\nThis value is a great match for the triplet CASCI reference values we obtained earlier. We calculated all the excited states calculated using CASCI using deflation by running VQESolver 4 times.\nThe deflation_circuits option is also available for the SA-VQE solver shown in another section of this notebook (SA_VQESolver), as well as ADAPT (ADAPTSolver).\n\n\n2.3 Quantum Subspace Expansion \nAnother way to obtain excited states is to define a pool of operators providing a good approximation to the excitations needed to represent the excited states from the ground state calculations produced by VQESolver. This idea was presented in arXiv:1603.05681.\nFor this example, we choose a pool of operators of the form \\(O_p=a_i^{\\dagger}a_j\\).\nWe then have to solve \\(FU = SUE\\), where \\(F_{pq}=\\left&lt;\\psi\\right|O_p^* H O_q\\left|\\psi\\right&gt;\\) and \\(S_{pq}=\\left&lt;\\psi\\right|O_p^* O_q\\left|\\psi\\right&gt;\\).\nFor simplicity here, we keep all wavefunction symmetry excitations. However, the matrix we need to diagonalize can be made smaller by only keeping excitations that respect the desired wavefunction symmetry of the excited state.\n\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom openfermion.utils import hermitian_conjugated as hc\n\nfrom tangelo.toolboxes.operators import FermionOperator\nfrom tangelo.toolboxes.qubit_mappings.mapping_transform import fermion_to_qubit_mapping as f2q_mapping\n\n# Generate all single excitations as qubit operators\nop_list = list()\nfor i in range(2):\n    for j in range(i+1, 2):\n        op_list += [f2q_mapping(FermionOperator(((2*i, 1), (2*j, 0))), \"jw\")] #spin-up transition\n        op_list += [f2q_mapping(FermionOperator(((2*i+1, 1), (2*j+1, 0))), \"jw\")] #spin-down transition\n        op_list += [f2q_mapping(FermionOperator(((2*i+1, 1), (2*j, 0))), \"jw\")] #spin-up to spin-down\n        op_list += [f2q_mapping(FermionOperator(((2*i, 1), (2*j+1, 0))), \"jw\")] #spin-down to spin-up\n\n# Compute F and S matrices.\nsize_mat = len(op_list)\nh = np.zeros((size_mat, size_mat))\ns = np.zeros((size_mat, size_mat))\nstate_circuit = vqe_solver.optimal_circuit\nfor i, op1 in enumerate(op_list):\n    for j, op2 in enumerate(op_list):\n        h[i, j] = np.real(vqe_solver.backend.get_expectation_value(hc(op1)*vqe_solver.qubit_hamiltonian*op2, state_circuit))\n        s[i, j] = np.real(vqe_solver.backend.get_expectation_value(hc(op1)*op2, state_circuit))\n\nlabel = \"quantum_subspace_expansion\"\nalgorithm_resources[label] = vqe_solver.get_resources()\nalgorithm_resources[label][\"n_post_terms\"] = len(op_list)**2*algorithm_resources[label][\"qubit_hamiltonian_terms\"]\n\nAfter generating the matrices on the quantum computer. We need to perform the classical post-processing to obtain the energies by solving the \\(FU = SUE\\) eigenvalue problem.\n\n# Solve FU = SUE\ne, v = eigh(h,s)\nprint(f\"Quantum Subspace Expansion energies: \\n {e}\")\n\nQuantum Subspace Expansion energies: \n [-14.83876635 -14.83876635 -14.83876635 -14.7840384 ]\n\n\nWe can see that we have obtained the correct energies for CASCI state A1g state 1, and A2 state 0 and 1. A1g state 1 was not recovered. We would therefore need to measure more excitations in \\(F\\).\n\n\n2.4 State-Averaged VQE \nAnother method to obtain excited states is to use the State-Averaged VQE Solver (SA-VQE). SA-VQE minimizes the average energy of multiple orthogonal reference states using the same ansatz circuit. As the reference states are orthogonal, using the same circuit transformation (a unitary), results in final states that are also orthogonal. This idea can be found in arXiv:2009.11417.\nHere, we target singlet states only. This can be accomplished by adding a penalty term with \"penalty_terms\": {\"S^2\": [2, 0]}. This means that the target Hamiltonian to be minimized is \\(H = H_0 + 2 (\\hat{S}^2 - 0)^2\\), where \\(H_0\\) is the original molecular Hamiltonian.\n\nfrom tangelo.algorithms.variational import SA_VQESolver\n\nvqe_options = {\"molecule\": mol_Li2, \"ref_states\": [[1,1,0,0], [1,0,0,1], [0,0,1,1]],\n               \"weights\": [1, 1, 1], \"penalty_terms\": {\"S^2\": [2, 0]},\n               \"qubit_mapping\": \"jw\", \"ansatz\": BuiltInAnsatze.UpCCGSD,\n               }\nvqe_solver = SA_VQESolver(vqe_options)\nvqe_solver.build()\nenernew = vqe_solver.simulate()\nfor i, energy in enumerate(vqe_solver.state_energies):\n    print(f\"Singlet State {i} has energy {energy}\")\n\nalgorithm_resources[\"sa_vqe\"] = vqe_solver.get_resources()\n\nSinglet State 0 has energy -14.742180682021289\nSinglet State 1 has energy -14.812125666941942\nSinglet State 2 has energy -14.7795400653701\n\n\nThe energies above are inaccurate, as the calculated states are restricted to linear combinations of the three lowest singlet states. We can use MC-VQE to generate the exact eigenvectors, as shown in the next section.\nHowever, the cell below shows the \\(\\hat{S}^2\\) expectation value is nearly zero for all states, so they are all singlet as expected when using the penalty term.\n\nfrom tangelo.toolboxes.ansatz_generator.fermionic_operators import spin2_operator\n\ns2op = f2q_mapping(spin2_operator(2), \"jw\")\nfor i in range(3):\n    print(f\"State {i} has S^2 = {vqe_solver.backend.get_expectation_value(s2op, vqe_solver.reference_circuits[i]+vqe_solver.optimal_circuit)}\")\n\nState 0 has S^2 = 3.529243208788557e-08\nState 1 has S^2 = 2.0223862616242094e-06\nState 2 has S^2 = 7.838201587784255e-09\n\n\n\n\n2.5 Multistate, contracted VQE (MC-VQE) \nTo obtain the energies of the individual states, we can use multistate contracted VQE (MC-VQE), as introduced in arXiv:1901.01234. This process defines a small matrix by measuring the Hamiltonian expectation values of \\((\\left|\\theta_i\\right&gt;+\\left|\\theta_j\\right&gt;)/\\sqrt{2}\\) and \\((\\left|\\theta_i\\right&gt;-\\left|\\theta_j\\right&gt;)/\\sqrt{2}\\) for all combinations of our final states (\\(\\left|\\theta_i\\right&gt;\\)) resulting from the SA-VQE procedure.\nIn general, the reference states are simple occupations so generating \\((\\left|\\theta_i\\right&gt;+\\left|\\theta_j\\right&gt;)/\\sqrt{2}\\) and \\((\\left|\\theta_i\\right&gt;-\\left|\\theta_j\\right&gt;)/\\sqrt{2}\\) by hand should be “fairly straightforward”. In this notebook, we use Tangelo to obtain these statevectors and then generate the expectation values.\n\n# Generate individual statevectors\nref_svs = list()\nfor circuit in vqe_solver.reference_circuits:\n    _, sv = vqe_solver.backend.simulate(circuit, return_statevector=True)\n    ref_svs.append(sv)\n\n# Generate Equation (2) using equation (4) and (5) of arXiv:1901.01234\nh_theta_theta = np.zeros((3,3))\nfor i, sv1 in enumerate(ref_svs):\n    for j, sv2 in enumerate(ref_svs):\n        if i != j:\n            sv_plus = (sv1 + sv2)/np.sqrt(2)\n            sv_minus = (sv1 - sv2)/np.sqrt(2)\n            exp_plus = vqe_solver.backend.get_expectation_value(vqe_solver.qubit_hamiltonian, vqe_solver.optimal_circuit, initial_statevector=sv_plus)\n            exp_minus = vqe_solver.backend.get_expectation_value(vqe_solver.qubit_hamiltonian, vqe_solver.optimal_circuit, initial_statevector=sv_minus)\n            h_theta_theta[i, j] = (exp_plus-exp_minus)/2\n        else:\n            h_theta_theta[i, j] = vqe_solver.state_energies[i]\n\nAccurate energies can be recovered by solving the resulting eigenproblem classically:\n\ne, _ = np.linalg.eigh(h_theta_theta)\nfor i, energy in enumerate(e):\n    print(f\"Singlet State {i} \\t MC-VQE energy = {energy}\")\n\nSinglet State 0      MC-VQE energy = -14.869616815256682\nSinglet State 1      MC-VQE energy = -14.784034669938677\nSinglet State 2      MC-VQE energy = -14.68019492913796\n\n\nWe can see that these singlet energies are all close to the exact answer.\n\nUsing StateVector for MC-VQE\nThe code below can be used obtain the same MC-VQE result by using StateVector to automatically generate circuits for \\((\\left|\\theta_i\\right&gt;+\\left|\\theta_j\\right&gt;)/\\sqrt{2}\\) and \\((\\left|\\theta_i\\right&gt;-\\left|\\theta_j\\right&gt;)/\\sqrt{2}\\). However, the circuits created by StateVector are generally inefficient and one should try to create the circuits that generate these states by hand if running on a real quantum device.\n\nfrom tangelo.linq.helpers import StateVector\n\n# Generate individual statevectors\nref_svs = list()\nfor state in vqe_solver.ref_states:\n    sv = np.zeros(2**4)\n    # Generate bitstring representation of each ref_state and populate that position in the statevector\n    bitstring = \"\".join([str(i) for i in reversed(state)])\n    sv[int(bitstring, base=2)] = 1\n    ref_svs.append(sv)\n\n# Generate Equation (2) using equation (4) and (5) of arXiv:1901.01234\nh_theta_theta = np.zeros((len(ref_svs), len(ref_svs)))\nfor i, sv1 in enumerate(ref_svs):\n    for j, sv2 in enumerate(ref_svs):\n        if i != j:\n            sv_plus = (sv1 + sv2)/np.sqrt(2)\n            sv_plus = StateVector(sv_plus)\n            ref_circ_plus = sv_plus.initializing_circuit()\n            exp_plus = vqe_solver.backend.get_expectation_value(vqe_solver.qubit_hamiltonian, ref_circ_plus + vqe_solver.optimal_circuit)\n\n            sv_minus = (sv1 - sv2)/np.sqrt(2)\n            sv_minus = StateVector(sv_minus)\n            ref_circ_minus = sv_minus.initializing_circuit()\n            exp_minus = vqe_solver.backend.get_expectation_value(vqe_solver.qubit_hamiltonian, ref_circ_minus + vqe_solver.optimal_circuit)\n\n            h_theta_theta[i, j] = (exp_plus-exp_minus)/2\n        else:\n            h_theta_theta[i, j] = vqe_solver.state_energies[i]\n\nalgorithm_resources[\"mc_vqe\"] = vqe_solver.get_resources()\nalgorithm_resources[\"mc_vqe\"][\"n_post_terms\"] = len(ref_svs)**2*algorithm_resources[\"mc_vqe\"][\"qubit_hamiltonian_terms\"]\n\n\ne, _ = np.linalg.eigh(h_theta_theta)\nfor i, energy in enumerate(e):\n    print(f\"Singlet State {i} \\t MC-VQE energy = {energy}\")\n\nSinglet State 0      MC-VQE energy = -14.869616815256672\nSinglet State 1      MC-VQE energy = -14.784034669938706\nSinglet State 2      MC-VQE energy = -14.680194929137963\n\n\n\n\n\n2.6 State-Averaged VQE with deflation \nWe can obtain the final excited state by using deflation for the three singlet states above and removing the penalty term. We define a reference state with \"ref_states\": [[1, 0, 1, 0]] that better targets the remaining triplet state. We can revert back to the UCCSD ansatz for this state as we do not need as expressive an ansatz anymore.\n\nvqe_options = {\"molecule\": mol_Li2, \"ref_states\": [[1, 0, 1, 0]],\n               \"weights\": [1], \"deflation_circuits\": [vqe_solver.reference_circuits[i]+vqe_solver.optimal_circuit for i in range(3)],\n               \"qubit_mapping\": \"jw\", \"ansatz\": BuiltInAnsatze.UCCSD,\n               }\nvqe_solver_deflate = SA_VQESolver(vqe_options)\nvqe_solver_deflate.build()\nenernew = vqe_solver_deflate.simulate()\n\nfor i, energy in enumerate(vqe_solver_deflate.state_energies):\n    print(f\"Triplet State {i} has energy {energy}\")\n\nalgorithm_resources[f\"sa_vqe_deflation\"] = vqe_solver_deflate.get_resources()\n\nTriplet State 0 has energy -14.83876634542472\n\n\nThis is the correct triplet state energy.\n\n\n2.7 State-Averaged Orbital-Optimized VQE \nThis performs the equivalent of a CASSCF calculation using a quantum computer. This approach runs multiple iterations comprised of the two following steps:\n\nSA-VQE calculation\norbital optimization\n\nThese iterations are called by using the iterate() call. The simulate() method from SA_OO_Solver only performs a State-Averated VQE simulation. The reference for this method is arXiv:2009.11417.\n\nfrom tangelo.algorithms.variational import SA_OO_Solver\n\nmol_Li2_nosym = SQMol(li2, q=0, spin=0, basis='6-31g(d,p)',\n                      frozen_orbitals=fo, symmetry=False)\nvqe_options = {\"molecule\": mol_Li2_nosym, \"ref_states\": [[1,1,0,0], [1,0,1,0]],\n               \"weights\": [1, 1],\n               \"qubit_mapping\": \"jw\", \"ansatz\": BuiltInAnsatze.UpCCGSD, \"ansatz_options\": {\"k\": 2}\n               }\nvqe_solver = SA_OO_Solver(vqe_options)\nvqe_solver.build()\nenernew = vqe_solver.iterate()\nfor i, energy in enumerate(vqe_solver.state_energies):\n    print(f\"State {i} has energy {energy}\")\n\nalgorithm_resources[\"sa_oo_vqe\"] = vqe_solver.get_resources()\n\nState 0 has energy -14.87559934824753\nState 1 has energy -14.85178914846094\n\n\nComparing the SA_OO_VQE solution to CASSCF calculations from a library such as pyscf shows similar results.\n\nmol_Li2_no_sym_copy = SQMol(li2, q=0, spin=0, basis='6-31g(d,p)',\n                            frozen_orbitals=fo, symmetry=False)\nmc = mcscf.CASSCF(mol_Li2_no_sym_copy.mean_field, 2, 2).state_average([0.5, 0.5])\nenergy = mc.kernel()\n\nCASSCF energy = -14.8636942982906\nCASCI E = -14.8636942982906  E(CI) = -0.569133524449606  S^2 = 1.0000000\nCASCI state-averaged energy = -14.8636942982906\nCASCI energy for each state\n  State 0 weight 0.5  E = -14.8756048775827 S^2 = 0.0000000\n  State 1 weight 0.5  E = -14.8517837189985 S^2 = 2.0000000\n\n\nSA_OO_Solver has optimized the orbitals in mol_Li2_nosym to minimize the average energy of the states above. We can then use the code below to output the optimized molecular orbitals as cube files and compare to the unoptimized orbitals from the top of the notebook.\nfrom pyscf.tools import cubegen\n# loop over active orbitals i.e. 2, 3\nfor i in [2, 3]:\n   cubegen.orbital(mol_Li2_nosym.to_pyscf(basis = mol_Li2_nosym.basis), f'li2_{i+1}_opt.cube', mol_Li2_nosym.mean_field.mo_coeff[:, i])\nUsing Avogadro to generate the two figures below with the .cube files outputted above, we see that the original fourth molecular orbital and the optimized fourth molecular orbital look very different:\n\n\n\n\n Original molecular orbital \n\n\n Optimized molecular orbital\n\n\n\n\n\n\n\n\n\n\n\n\nLi \\({_2}\\) is a molecule that requires CASSCF type optimization to exihibit the correct qualitative behavior when using a small active space. Below, we run SA_OO_VQE for multiple different bond lengths and compare to CASCI. This calculation can take more than one minute, depending on your computer.\n\nsa_oo_eners = list()\ncasci_eners = list()\nxvals = np.array([2, 2.2, 2.5, 3., 3.5, 4., 4.5, 5., 6., 7., 9.])\n\nfor r in xvals:\n    print(f\"Computing state-averaged orbital-optimized VQE energy for r={r}\")\n    li2_xyz = [('Li', (0, 0, 0)),('Li', (r, 0, 0))]\n    \n    mol_Li2_nosym_copy = SQMol(li2_xyz, q=0, spin=0, basis='6-31g(d,p)',\n                               frozen_orbitals=fo, symmetry=False)\n    mc = mcscf.CASCI(mol_Li2_nosym_copy.mean_field, 2, 2)\n    mc.fcisolver.nroots = 2\n    mc.verbose = 0\n    e = mc.kernel()\n    casci_eners.append(e[0])\n\n    # Compute SA-OO-VQE energy\n    mol_Li2_nosym = SQMol(li2_xyz, q=0, spin=0, basis='6-31g(d,p)',\n                          frozen_orbitals=fo, symmetry=False)\n    vqe_options = {\"molecule\": mol_Li2_nosym, \"ref_states\": [[1, 1, 0, 0], [1, 0, 1, 0]], \"tol\": 1.e-3,\n                   \"ansatz\": BuiltInAnsatze.UCCGD, \"weights\": [1, 1], \"n_oo_per_iter\": 1}\n    vqe_solver = SA_OO_Solver(vqe_options)\n    vqe_solver.build()\n    enernew = vqe_solver.iterate()\n    sa_oo_eners.append(vqe_solver.state_energies)\n\nComputing state-averaged orbital-optimized VQE energy for r=2.0\nComputing state-averaged orbital-optimized VQE energy for r=2.2\nComputing state-averaged orbital-optimized VQE energy for r=2.5\nComputing state-averaged orbital-optimized VQE energy for r=3.0\nComputing state-averaged orbital-optimized VQE energy for r=3.5\nComputing state-averaged orbital-optimized VQE energy for r=4.0\nComputing state-averaged orbital-optimized VQE energy for r=4.5\nComputing state-averaged orbital-optimized VQE energy for r=5.0\nComputing state-averaged orbital-optimized VQE energy for r=6.0\nComputing state-averaged orbital-optimized VQE energy for r=7.0\nComputing state-averaged orbital-optimized VQE energy for r=9.0\n\n\nThe plot below shows the resulting potential energy curves, and illustrates the impact of orbital optimization for our use case:\n\nimport matplotlib.pyplot as plt\n\nsa_oo_eners=np.array(sa_oo_eners)\ncasci_eners= np.array(casci_eners)\n\nfig, ax = plt.subplots()\nax.plot(xvals, sa_oo_eners[:, 0], label=\"SA_OO State 0\")\nax.plot(xvals, sa_oo_eners[:, 1], label=\"SA_OO State 1\")\nax.plot(xvals, casci_eners[:, 0], label=\"CASCI State 0\")\nax.plot(xvals, casci_eners[:, 1], label=\"CASCI State 1\")\nax.set_xlabel('r (Angstrom)')\nax.set_ylabel('Energy (Hartree)')\nax.legend()\n\n&lt;matplotlib.legend.Legend at 0x7ff05d0df310&gt;"
  },
  {
    "objectID": "examples/chemistry/excited_states.html#hamiltonian-simulation-algorithms",
    "href": "examples/chemistry/excited_states.html#hamiltonian-simulation-algorithms",
    "title": "Excited States in Tangelo",
    "section": "3. Hamiltonian Simulation algorithms ",
    "text": "3. Hamiltonian Simulation algorithms \nWe now illustrate a few other approches based on time-evolution of the Hamiltonian. Although these algorithms are not NISQ-friendly, they do not require non-linear optimization of parameters like the variational methods encountered in the previous sections. They may be a better choice for future fault-tolerant architectures.\n\n3.1 Multi-Reference Selected Quantum Krylov (MRSQK) \nThe multi-reference selected Quantum Krylov algorithm as outlined in arXiv:1911.05163 uses multiple reference states and performs multiple time evolutions \\(U = e^{-iH\\tau}\\) for time \\(\\tau\\), to generate a Krylov representation of the system. The method relies on building two matrices \\({\\cal{H}}\\) and \\(S\\), whose elements are defined by \\({\\cal{H}_{ia,jb}} = \\left&lt;\\phi_a\\right|U^i H U^j\\left|\\phi_b\\right&gt;\\) and \\(S_{ia,jb} = \\left&lt;\\phi_a\\right|U^i U^j\\left|\\phi_b\\right&gt;\\), where \\(\\phi_a, \\phi_b\\) denote different reference configurations. The matrix elements are measured using the procedure outlined in arXiv:1911.05163 and the energies obtained through solving \\({\\cal{H}}V = SVE\\).\nIn arXiv:2109.06868, it was further noticed that one can use any function of \\(\\cal{H}\\) to obtain the eigenvalues. For example, one could use \\(f({\\cal{H}})=e^{-iH\\tau}=U\\). The same procedure results in the matrix elements \\(f({\\cal{H}})_{ia,jb} = \\left&lt;\\phi_a\\right|U^i U U^j\\left|\\phi_b\\right&gt;, S_{ia,jb} = \\left&lt;\\phi_a\\right|U^i U^j\\left|\\phi_b\\right&gt;\\) for the eigenvalue problem \\(f({\\cal{H}})V=SVf(E)\\). As \\(E\\) is a diagonal matrix, the correct energies can be obtained by calculating the phase of the eigenvalues (\\(f(E)=e^{-iE\\tau}\\)) and dividing by \\(\\tau\\). (i.e. \\(\\arctan \\left[\\Im(f(E))/\\Re(f(E)) \\right]/\\tau\\)). The resulting circuit is slightly longer but much fewer measurements are required. It is worth mentioning that qubitization, which natively implements \\(e^{i \\arccos(H\\tau)}\\), can be used without issue. Qubitization is currently one of the most efficient algorithms that implements time-evolution.\n\nfrom itertools import product\nfrom scipy.linalg import eigh, eigvals\n\nfrom tangelo.linq import get_backend, Circuit, Gate\nfrom tangelo.toolboxes.operators import QubitOperator, count_qubits\nfrom tangelo.toolboxes.qubit_mappings.statevector_mapping import vector_to_circuit\nfrom tangelo.toolboxes.ansatz_generator.ansatz_utils import controlled_pauliwords, trotterize\n\n\n# Number of Krylov vectors\nn_krylov = 4\n# Simulation time for each unitary\ntau = 0.04\n# Qubit Mapping\nmapping = \"jw\"\n\nbackend = get_backend()\n\n# Qubit operator for Li2\nqu_op =  f2q_mapping(mol_Li2.fermionic_hamiltonian, mapping, mol_Li2.n_active_sos,\n                     mol_Li2.n_active_electrons, up_then_down=False, spin=mol_Li2.spin)\n\n# control qubit\nc_q = count_qubits(qu_op)\n\n# Operator that measures off-diagonal matrix elements i.e. 2|0&gt;&lt;1|\nzeroone = (QubitOperator(f\"X{c_q}\", 1) + QubitOperator(f\"Y{c_q}\", 1j))\n\n# Controlled unitaries for each term in qu_op\nc_qu = controlled_pauliwords(qubit_op=qu_op, control=c_q, n_qubits=5)\n\n# Controlled time-evolution of qu_op\nc_trott = trotterize(qu_op, time=tau, n_trotter_steps=1, trotter_order=1, control=4)\n\n# Generate multiple controlled-reference states.\nreference_states = list()\nreference_vecs = [[1, 1, 0, 0], [1, 0, 0, 1]]\nfor vec in reference_vecs:\n    circ = vector_to_circuit(vec)\n    gates = [Gate(\"C\"+gate.name, target=gate.target, control=4) for gate in circ]\n    reference_states += [Circuit(gates)]\n\n# Calculate MRSQK\nsab = np.zeros((n_krylov, n_krylov), dtype=complex)\nhab = np.zeros((n_krylov, n_krylov), dtype=complex)\nfhab = np.zeros((n_krylov, n_krylov), dtype=complex)\n\nfor a, b in product(range(n_krylov), range(n_krylov)):\n    # Generate Ua and Ub unitaries\n    ua = reference_states[a%2] + c_trott * (a//2) if a &gt; 1 else reference_states[a%2]\n    ub = reference_states[b%2] + c_trott * (b//2) if b &gt; 1 else reference_states[b%2]\n    \n    # Build circuit from Figure 2 for off-diagonal overlap\n    hab_circuit = Circuit([Gate(\"H\", c_q)]) + ua + Circuit([Gate(\"X\", c_q)]) + ub\n    sab[a, b] = backend.get_expectation_value(zeroone, hab_circuit) / 2\n    sab[b, a] = sab[a, b].conj()\n\n    # Hamiltonian matrix element for f(H) = e^{-i H \\tau}\n    fhab[a, b] = backend.get_expectation_value(zeroone, hab_circuit+c_trott.inverse())/2\n\n    # Return statevector for faster calculation of Hamiltonian matrix elements\n    _ , initial_state = backend.simulate(hab_circuit, return_statevector=True)\n    for i, (term, coeff) in enumerate(qu_op.terms.items()):\n\n        # From calculated statevector append controlled-pauliword for each term in Hamiltonian and measure zeroone\n        expect = coeff*backend.get_expectation_value(zeroone, c_qu[i], initial_statevector=initial_state) / 2\n\n        # Add term to sum\n        hab[a, b] += expect\n\ne, v = eigh(hab, sab)\nprint(f\"The HV=SVE energies are {e}\")\ne = eigvals(fhab, sab)\nprint(f\"The f(H)V=SVf(E) energies are {np.arctan2(np.imag(e), np.real(e))/tau}\")\n\nalgorithm_resources[\"mrsqk\"] = dict()\nalgorithm_resources[\"mrsqk\"][\"qubit_hamiltonian_terms\"] = 0\nalgorithm_resources[\"mrsqk\"][\"circuit_2qubit_gates\"] = hab_circuit.counts.get(\"CNOT\", 0)\nalgorithm_resources[\"mrsqk\"][\"n_post_terms\"] = n_krylov**2\n\nThe HV=SVE energies are [-14.8696203  -14.83876634 -14.78403833 -14.680196  ]\nThe f(H)V=SVf(E) energies are [-14.86962029 -14.680196   -14.83876634 -14.78403833]\n\n\nThe calculated energies are very close to the exact energies calculated at the top of the notebook.\n\n\n3.2 Rodeo Algorithm \nAnother method based on Hamiltonian simulation that can be used to obtain energies is the Rodeo Algorithm. This simulates the Hamiltonian for many random lengths of time with different input energies. The probability of the ancilla qubit being 0 for a given energy \\(E\\) is \\(P_0(E) = \\frac{1 + e^{-\\sigma^2 (E_i - E)^2/2}}{2}\\) where \\(E_i\\) is one of the eigenvalues of the Hamiltonian. The algorithm is outlined in arXiv:2110.07747. When the energy \\(E\\) is close to an eigenvalue \\(E_i\\), the probability is maximized. Therefore, one would observe peaks in success probability when the input energy \\(E\\) is an eigenvalue.\nThe cell illustrates this process over 10 iterations for each energy, for simplicity. We however show a plot resulting from 1,000 iterations afterwards. To reduce the computational complexity, we also use the symmetry-conserving Bravyi-Kitaev mapping to reduce the number of qubits to 2 by remove qubits corresponding to spin and electron number. This means we can only obtain the singlet state energies. A separate calculation would be needed to calculate the triplet energy.\n\n# One rodeo cycle as defined in Fig.1 of arXiv.2110.07747\ndef rodeo_cycle(hobj, energy, t, i):\n    circuit = Circuit([Gate(\"H\", i)])\n    circuit += trotterize(hobj, time=t, control=i, trotter_order=2, n_trotter_steps=40)\n    circuit += Circuit([Gate(\"PHASE\", i, parameter=energy*t), Gate(\"H\", i)])\n    return circuit\n\n\nfrom tangelo.toolboxes.qubit_mappings.statevector_mapping import do_scbk_transform\n\nh_obj =  f2q_mapping(mol_Li2.fermionic_hamiltonian, \"scbk\", mol_Li2.n_active_sos,\n                     mol_Li2.n_active_electrons, up_then_down=True, spin=mol_Li2.spin)\n\nn_qubits = count_qubits(h_obj)\n\n# Stretch factor of 300 to make eigenvalue gap larger. Therefore, time evolution needs to be shorter.\nh_obj = 300*(h_obj - QubitOperator((), -14.85))\n\nsim = get_backend()\n\nsigma = 0.4\n\n# We will use multiple reference states as probability depends on overlap with starting state.\nref_states = [vector_to_circuit(do_scbk_transform([1, 1, 0, 0], 4)),\n              vector_to_circuit(do_scbk_transform([1, 0, 1, 0], 4)),\n              vector_to_circuit(do_scbk_transform([0, 0, 1, 1], 4))]\n\n# Equivalent to energies from -14.9 -&gt; 14.75 for 10 iterations.\nenergies = [-0.05*300 +300*0.005*i for i in range(30)]\nsuccess_prob = list()\nfor energy in energies:\n    success=0\n    for sample in range(10):\n        t = np.random.normal(0, sigma, 1)\n        circuit = np.random.choice(ref_states)\n        for i, tk in enumerate(t):\n            circuit += rodeo_cycle(h_obj, energy, tk, i+n_qubits)\n        f, _ = sim.simulate(circuit)\n        for key, v in f.items():\n            if key[2:] == \"0\":\n                success += v\n    success_prob.append(success/10)\n\nalgorithm_resources[\"rodeo\"] = dict()\nalgorithm_resources[\"rodeo\"][\"qubit_hamiltonian_terms\"] = 0\nalgorithm_resources[\"rodeo\"][\"circuit_2qubit_gates\"] = circuit.counts.get(\"CNOT\", 0)\nalgorithm_resources[\"rodeo\"][\"n_post_terms\"] = 30\n\n\nfig, ax = plt.subplots()\nfig.patch.set_facecolor('w')\nax.set_facecolor('w')\nevals = [-14.8696203,  -14.83876635, -14.78403833]\nfor e in evals:\n    ax.axvline(x=e, color='r',ls='--')\nax.plot(np.array(energies)/300-14.85, success_prob)\nax.set_xlabel('Energy (Hartree)')\nax.set_ylabel('Success Probability')\n\nText(0, 0.5, 'Success Probability')\n\n\n\n\n\nThe above plot shows promise that the correct energies indeed align with peaks in the success probability, despite our small number of iterations. To save time, below is the result after running the above code for 1000 iterations. The peaks are centered on the exact energies, represented by the vertical red dashed lines."
  },
  {
    "objectID": "examples/chemistry/excited_states.html#closing-words",
    "href": "examples/chemistry/excited_states.html#closing-words",
    "title": "Excited States in Tangelo",
    "section": "4. Closing words ",
    "text": "4. Closing words \nWe have shown a few of the many different algorithms that can be used to calculate excited states using Tangelo. Unlike ground states, the use of variational methods requires either penalizing against previously calculated states or the optimization of a collection of orthogonal states. Outside of variational methods, we have shown a few Hamiltonian simulation based algorithms to calculate excited states.\nBut quantum resource requirements are an important aspect of quantum algorithm design: let’s have a look at the resources required for each algorithm we tried on our use case. In particular, the following metrics:\n\n# measurements basis is the number of distinct measurements for each function evaluation in the variational optimization process.\n# CNOT gates is the number of CNOT gates in each circuit.\n# post measurements basis is the number of measurements needed to successfully post-process the output of the algorithm.\n\nWe note that # CNOT gates for each variational algorithm could be improved greatly if an algorithm such as ADAPT-VQE was used to create an ansatz. Similarly, # CNOT gates could be reduced for the time-evolution algorithms with more advanced approaches such as qubitization.\n\nformat = \"{:&lt;40} {:&lt;20} {:&lt;20} {:&lt;20}\"\nprint(format.format(\"Algorithm\", \"# measurements\", \"# CNOT gates\", \"# post measurements\"))\nfor method, resources in algorithm_resources.items():\n  print(format.format(method, resources[\"qubit_hamiltonian_terms\"], resources[\"circuit_2qubit_gates\"], resources.get(\"n_post_terms\", 0)))\n\nAlgorithm                                # measurements       # CNOT gates         # post measurements \nvqe_ground_state                         15                   64                   0                   \nvqe_triplet_state                        15                   128                  0                   \nvqe_deflation_state_1                    16                   192                  0                   \nvqe_deflation_state_2                    17                   192                  0                   \nvqe_deflation_state_3                    18                   192                  0                   \nquantum_subspace_expansion               18                   192                  288                 \nsa_vqe                                   60                   128                  0                   \nmc_vqe                                   60                   128                  540                 \nsa_vqe_deflation                         18                   192                  0                   \nsa_oo_vqe                                30                   128                  0                   \nmrsqk                                    0                    72                   16                  \nrodeo                                    0                    320                  30                  \n\n\nThese are the resource requirements that came out from calculations on our small Li\\(_2\\) use case in minimal basis set, featuring two 2 electrons in 2 orbitals.\nBut what of BODIPY ?\n\nbodipy = SQMol(\"data/bodipy.xyz\", q=0, spin=0, basis=\"sto-3g\")\nprint(f\"Active electrons = {bodipy.n_active_mos}\")\nprint(f\"Active orbitals = {bodipy.n_active_electrons}\")\n\nActive electrons = 63\nActive orbitals = 70\n\n\nWhereas we did calculations with 2 electrons in 2 orbitals, the full calculation of BODIPY in the minimal STO-3G basis would entail 63 electrons in 70 orbitals, with the core electrons frozen. The number of qubits needed to represent this would be 140 for the Jordan-Wigner mapping, compared to the 4 (+1 ansatz for the Hamiltonian simulation algorithms) qubits used in this notebook. J. Chem. Theory. Comput. 2015, 11, 6 showed reasonable results using CASSCF with 12 electrons in 11 orbitals, which would be a 22-qubit problem using the Jordan-Wigner mapping. Another issue is the number of CNOT gates, which would be much larger for the full 22-qubit problem than shown in the table for our use case.\nThis system is orders or magnitude harder, and emphasize how it is crucial that we design and choose approaches that require as little quantum computational resources as possible to make such use cases tractable in the future.\nThere is still much work to be done to efficiently calculate excited states using quantum computers, and allow us to tackle more industrially-relevant use cases.\nWhat will you do with Tangelo?"
  },
  {
    "objectID": "examples/chemistry/qchem_modelling_basics.html",
    "href": "examples/chemistry/qchem_modelling_basics.html",
    "title": "Quantum Chemistry: Modelling Basics",
    "section": "",
    "text": "The aim of this notebook is to provide the basic quantum chemistry knowledge to help solve a chemistry problem with quantum computers. Many parameters can be tweaked, and some have higher impact on the accuracy and the quantum resources (number of qubits, quantum circuit depth and number of measurements) than others. This set of parameters includes the choice of initial state, choice of basis set, and the freezing of molecular orbitals. Some references are provided when needed.\nThe Tangelo python package is necessary to run the code cells in this notebook, and it can be installed in your environment by executing the code cell below.\ntry:\n    import tangelo\nexcept ImportError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git --quiet"
  },
  {
    "objectID": "examples/chemistry/qchem_modelling_basics.html#table-of-contents",
    "href": "examples/chemistry/qchem_modelling_basics.html#table-of-contents",
    "title": "Quantum Chemistry: Modelling Basics",
    "section": "Table of Contents",
    "text": "Table of Contents\n\nIntroduction\nComputation of the Mean-Field\n\nMolecular Information\nRestricted vs Unrestricted Hartree-Fock (RHF/ROHF vs UHF)\nChoice of the Basis Set\n\nConsideration of Correlation Energy - Potential of Quantum Computing\nResource Reduction\n\nActive Space Selection\nConsidering Symmetries\n\nAdvanced Usage of PySCF\n\nExtracting Mean-Field Quantities\nOutputting Cube Files\n\nClosing Words\nReferences"
  },
  {
    "objectID": "examples/chemistry/qchem_modelling_basics.html#introduction",
    "href": "examples/chemistry/qchem_modelling_basics.html#introduction",
    "title": "Quantum Chemistry: Modelling Basics",
    "section": "Introduction",
    "text": "Introduction\nQuantum chemistry aims to solve the Schrödinger equation for many-electron molecules. As stated in the postulates of quantum mechanics, the wavefunction \\(\\Psi\\) encodes all the information of the system. One who knows the electronic wavefunction of a molecular system can therefore predict measurement outcomes of an experiment. This is a highly valuable asset for academia and industrial purposes, to help develop new drugs or functional materials.\nThe analysis of natural products is an efficient way of quickly getting inspiration for the design of new materials, while taking into account the million years of evolution that nature had to optimize a biochemical process. For instance, one difficult thing to do in the laboratory is to change the spin state of a compound during a chemical reaction. Nature circumvents this problem by leveraging transition metals to achieve this challenging task: the oxygen fixation process is achieved by the heme biomolecule, where a Fe(II) atom is involved in the spin state change mechanism (see figure below) [10.1074/jbc.M314007200].\n\n\n\nFeIIPorImO2 system\n\n\nFully understanding the mechanism of oxygen fixation, that is to say knowing the rate constants for all elementary reactions, would lead to valuable insights for the design of chemical catalysts. Achieving this goal would take us one step closer to making the world cleaner, healthier, and more sustainable. This is one of the main applications of quantum chemistry. However, the Schrödinger equation shown below cannot be solved exactly for systems beyond one electron, i.e. all relevant chemical systems for industrial applications.\n\\[\n\\hat{H} \\Psi = E \\Psi\n\\]\nHere, the electronic Hamiltonian \\(\\hat{H}\\) for \\(N\\) electrons is expressed in the first quantization form,\n\\[\n\\hat{H} = -\\frac{\\hbar^2}{2 m_e} \\sum_i \\nabla_i^2 -\\frac{e^2}{4 \\pi \\epsilon_0} \\sum_i \\sum_A \\frac{Z_A}{r_{iA}} + \\frac{e^2}{4 \\pi \\epsilon_0} \\sum_i \\sum_{j&gt;i} \\frac{1}{r_{ij}}\n\\]\nWhere \\(m_e\\), \\(\\nabla^2\\), \\(e\\), the relative nucleus charge, \\(Z_A\\), \\(r_{iA}\\) and \\(r_{ij}\\) are respectively the electron mass, the Laplacian, the elementary charge, the distance between the nucleus and the electron \\(i\\) and the distance between electron \\(i\\) and \\(j\\). In the second quantization form, the electronic Hamiltonian is expressed as\n\\[\nH = \\sum_{pq}h_{pq} a_p^{\\dagger}a_q + \\frac{1}{2}\\sum_{pqrs}h_{pqrs}a_p^{\\dagger}a_r^{\\dagger}a_s a_q\n\\]\nWhere \\(h_{pq}\\) and \\(h_{pqrs}\\) refer respectively to the one-body and two-body integrals. For more information about the state-of-the-art theories and methods in quantum chemistry, the reader is invited to read the references at the end of this notebook. The scope of this notebook is to provide clues on how to choose input parameters for modelling molecules on quantum computers with Tangelo. As quantum resources are still scarce, the definition of the problem is a crucial step in an end-to-end quantum chemistry experiment on quantum hardware. To keep a reasonable runtime for this notebook, we work with a simple example, the dioxygen molecule.\n\no2_xyz = [(\"O\", (0., 0., 0.)), (\"O\", (0., 0., 1.21))]"
  },
  {
    "objectID": "examples/chemistry/qchem_modelling_basics.html#computation-of-the-mean-field",
    "href": "examples/chemistry/qchem_modelling_basics.html#computation-of-the-mean-field",
    "title": "Quantum Chemistry: Modelling Basics",
    "section": "Computation of the Mean-Field",
    "text": "Computation of the Mean-Field\nThe computation of the mean-field is usually the first step of all post Hartree-Fock approaches, which we describe in a section below. The mean-field approaches solve the Schrödinger equation by averaging the electron-electron repulsion term in a self-consistent way. In other words, each electron does not explicitely interact with other electrons. Depending on the molecular information, discussed shortly, different flavours of mean-field solutions can be computed.\n\nMolecular Information\nThe chemical information is encapsulated in the SecondQuantizedMolecule object. As the name suggests, the formalism used in Tangelo is second quantization; however, the package is not restricted to it and data structures could be implemented in other formalisms (like first quantization).\nWhen defining a molecule, one must specify molecular properties. One of them is the total charge of the system, i.e. the difference between the number of electrons and the total nuclear charge (default value is 0). This is an important property when dealing with oxydo-reduction reactions where cations (deficit in electrons) and anions (surplus in electrons) are involved. Another important quantity to specify is the spin, defined by the difference between the number of alpha and beta electrons (default value is 0). This allows radical systems to be modelled: a spin of 0 characterizes a restricted-shell molecule while a spin different from 0 defines an open-shell system.\nIn the next cell, the dioxygen molecule data structure is constructed. The ground state of the dioxygen molecule is neutral and is a triplet state (q=0 and spin=2).\n\nfrom tangelo import SecondQuantizedMolecule\no2_sto3g = SecondQuantizedMolecule(o2_xyz, q=0, spin=2)\nprint(f\"{o2_sto3g.n_active_mos} active molecular orbitals\")\nprint(f\"{o2_sto3g.n_active_electrons} active electrons\")\n\n8 active molecular orbitals\n12 active electrons\n\n\nIn the above output, there are missing orbitals and electrons. The default implementation of Tangelo freezes the core orbitals; for the O\\(_2\\) molecule, two orbitals, corresponding to the 1p atomic orbitals, are frozen. The next sections elaborate on the impact of the basis sets and frozen orbitals.\n\n\nRestricted vs Unrestricted Hartree-Fock (RHF/ROHF vs UHF)\nThe mean-field solution is automatically computed when the SecondQuantizedMolecule object is created. With the provided spin, it computes the relevant mean-field, that is to say the Restricted or Restricted Open-Shell Hatree-Fock solution (RHF or ROHF). Using those methods, the spin-orbitals are treated as pairs, so each molecular orbital can accept up to two electrons. The unrestricted Hartree-Fock (UHF) mean-field calculation, where the spin-orbitals are considered individually, usually results in more accurate energies for open-shell systems. At the time of writing, the UHF approach has not yet been implemented in Tangelo. Further details about the RHF, ROHF and UHF methods can be found in Szabo & Ostlund.\n\n\nChoice of the Basis Set\nThe many-electron Schrödinger equation is typically solved in a basis of molecular orbitals which are expressed as a linear combination of atomic orbitals (LCAO). LCAO coefficients, used to construct molecular orbitals, are obtained through the minimization of the total energy, according to the variational principle. For convenience, the basis is usually represented by atom-centered functions for molecular systems, or plane-wave functions in solid-state physics.\nIn early quantum chemistry, basis sets were constructed with decreasing exponential functions (\\(e^{-\\alpha r}\\)). This strategy was referred to as Slater Type Orbitals (STOs). With the increase of computational resources, the use of Gaussian functions (\\(e^{-\\alpha r^2}\\)) was popularized. Computing the numerous overlap integrals, needed in quantum chemistry, is much more efficient to do using Gaussian functions than with STOs. This is the main point of using a Gaussian Type Orbitals (GTOs) wavefunction.\nState-of-the-art basis sets are constructed from many Gaussian primitives. The Pople notation is one of the most explicit notations for basis sets: - The hyphen symbol (-) separates the reference to core and valence orbitals; - The digits represent the number of Gaussian primitives in a function; - There are as many digits as there are functions for each atomic orbital (zeta \\(\\zeta\\)); - The letter G refers to the use of Gaussian functions.\nAs an example, the 3-21G double zeta basis set uses three Gaussian primitives for each core orbital and a set of two plus one Gaussian primitives for the valence orbitals. More information, examples and discussions about the GTOs can be found in this link.\nBelow are popular basis set examples used in quantum chemistry.\n\nbasis_sets = [\n    \"STO-3G\",       # Simple zeta, minimal basis.\n    \"3-21G\",        # Double zeta.\n    \"6-31G\",        # Double zeta with more Gaussian primitives.\n    \"6-31G(d,p)\",   # Polarization functions (+ 5 d-orbitals for all atoms except H, +3 p-orbitals for H atoms) added.\n    \"6-311G(d,p)\",  # Triple zeta with polarization functions.\n    \"6-311+G(d,p)\", # Triple zeta with polarization functions and diffuse functions.\n    \"cc-pvqz\",      # Quadruple zeta.\n    \"cc-pv5z\"       # Quintuple zeta.\n]\n\nThe wavefunction for a molecule is an approximation when using a finite basis set,\n\\[\n\\Phi_{\\text{approx}} = \\sum_{i=0}^N c_i |i \\rangle\n\\]\nAccording to the variational principle, considering \\(\\Phi_{\\text{approx}}\\) is normalized, the approximated energy is greater or equals to the true ground-state energy.\n\\[\n\\langle \\Phi_{\\text{approx}} | \\hat{H} | \\Phi_{\\text{approx}} \\rangle = \\epsilon_{\\text{approx}} \\geq  \\epsilon_{\\text{true}}\n\\]\nWith an infinite basis set, the approximation should be close to the real wavefunction.\n\\[\n\\Phi_{\\text{approx}} = \\sum_{i=0}^{\\infty} c_i |i \\rangle \\approx \\Psi_{\\text{true}}\n\\]\nHowever, increasing the basis set size has the effect of increasing the number of parameters to optimize, therefore extending the required computational resources in space (amount of memory) and in time (number of operations). As we shall see shortly, it is often a good idea to balance the basis set size to optimize the time to solution versus the target accuracy (\\(|\\epsilon_{\\text{approx}} - \\epsilon_{\\text{true}}|\\)), as the increase in the basis set complexity yields diminishing returns in accuracy gain.\nA full list of available basis sets supported in PySCF (therefore also in Tangelo) is available at this link. Also, the Basis Set Exchange initiative hosts a collection of bases for every atom in the periodic table. With this constantly increasing number of bases available to the community, choosing a basis set can be a challenging task. The theory states that an infinite basis is the way of getting the true wavefunction. However, it is not possible most of the time and one may prefer a tailored approach to their use case. Here are some tips and tricks for the basis set choice depending on the modelled system: - As a rule of thumb, a double zeta (e.g. 6-31G or cc-pvdz) is the minimum basis size required to get semi-quantitative energies. - For molecules with a high electronegativity difference between atoms, adding polarization functions (e.g. 6-31G** or 6-31G(d,p)) is recommended. - Diffuse functions (e.g. 6-31G+(d,p)) should be included when dealing with anions. Diffuse functions are functions with small coefficients (small \\(\\alpha\\) in \\(e^{-\\alpha r^2}\\)) that can fit the electronic density far from the nucleus. - Effective Core Potential (ECP) basis sets are needed when dealing with heavier atoms with relativistic and non-trivial effects (for example, the iodine atom is often modelled in the LANDL2DZ basis).\nIn the next cell, we demonstrate the effect of the basis on the total energy calculations and time to solution.\n\nimport time\nimport matplotlib.pyplot as plt\n\nmf_energies = list()\nmf_times = list()\n\n# Perform a Mean-Field calculation for each basis set.\nfor bs in basis_sets:\n    \n    # Measure execution time.\n    start = time.time()\n    scan_basis_mol = SecondQuantizedMolecule(o2_xyz, q=0, spin=2, basis=bs)\n    end = time.time()\n    \n    mf_energies.append(scan_basis_mol.mf_energy)\n    mf_times.append(end-start)\n\n# Create the matplotlib figure.\nfig, ax = plt.subplots(figsize=(8,5))\n\n# Plot the energies.\nax.set_xticks(range(len(basis_sets)), basis_sets, rotation=45)\nax.set_xlabel(\"Basis set\")\nax.set_ylabel(\"Energy / Hartree\", color=\"b\")\nax.scatter(range(len(basis_sets)), mf_energies, marker=\"o\", s=50, color=\"b\")\n\n# Plot the time to solution.\nax_time = ax.twinx()\nax_time.scatter(range(len(basis_sets)), mf_times, marker=\"s\", s=50, color=\"r\")\nax_time.set_ylabel(\"Time to solution / s\", color=\"r\", rotation=270, va=\"bottom\")\n\n# Show the graph.\nplt.tick_params(axis=\"both\", direction=\"in\")\nplt.show()\n\n\n\n\nWe see in the previous graph that increasing the basis complexity brings the energy eigenvalue closer to the true Hartree-Fock energy. This trend can be generalized to other methods as well, like CCSD, MP2, FCI, (…) although the time to solution would be greater for those post Hatree-Fock approaches. The takeaway is that even if an infite basis is required to converge to the true energy, there are diminishing returns at some point, especially when considering the time required for the calculation. In our case, 6-311G(d,p) appears as a good choice in term of accuracy and compute time."
  },
  {
    "objectID": "examples/chemistry/qchem_modelling_basics.html#consideration-of-correlation-energy---potential-of-quantum-computing",
    "href": "examples/chemistry/qchem_modelling_basics.html#consideration-of-correlation-energy---potential-of-quantum-computing",
    "title": "Quantum Chemistry: Modelling Basics",
    "section": "Consideration of Correlation Energy - Potential of Quantum Computing",
    "text": "Consideration of Correlation Energy - Potential of Quantum Computing\n\nPost Hatree-Fock methods are meant to consider the electronic correlation energy. The correlation energy is defined as\n\\[\n\\epsilon_{\\text{corr}} = \\epsilon - \\epsilon_{\\text{HF}}\n\\]\nWhere \\(\\epsilon\\) and \\(\\epsilon_{\\text{HF}}\\) are the computed energy and the Hartree-Fock energy, respectively. This correlation energy can be split into two categories: static and dynamical correlation. To consider the former, one should use multi-configuration approaches. The latter can be tackled with post Hartree-Fock methods with a single reference state, like Configuration Interaction (CI), Coupled-Cluster (CC) or perturbative methods (MP2, MP3, …). Going beyond this explanation is out of scope for this notebook, therefore we encourage the user to read on the subject in Szabo & Ostlund.\nWe saw in the previous section that the 6-311G(d,p) is a good compromise to compute the O\\(_2\\) ground state. In this basis, the dioxygen molecule is described by 72 bases (spin orbitals) and 16 electrons. To get the highest fidelity versus the true wavefunction with the current best method (Full Configuration Interaction), one would need \\({72 \\choose 16} \\approx 3 \\times 10^{13}\\) configurations. Even if we somehow managed to represent each configuration as a single byte of data, 4.11 petabytes would still be needed to store the full wavefunction of the dioxygen molecule. This effect is amplified when dealing with relevant industrial molecules like organometallic complexes or proteins. Going through the classical formalism of quantum chemistry is therefore not a viable solution.\nWith the occupation transformation (Jordan-Wigner [Zeitschrift für Physik, 47, p. 631–651 (1928)]), this problem vanishes. By leveraging the quantum superposition principle in a straightforward way, it is possible to map this O\\(_2\\) triplet ground state to 72 qubits (empty and filled spin orbitals are mapped to the \\(|0\\rangle\\) and \\(|1\\rangle\\) states, respectively). This fact is behind the emerging enthusiasm of the quantum computing community for chemistry applications. We should note that even if the space limitation is mitigated, no consensus is established for the time complexity, correlated to the number of gates and measurement required to approximate the molecular wavefunction [arXiv:2009.12472]."
  },
  {
    "objectID": "examples/chemistry/qchem_modelling_basics.html#resource-reduction",
    "href": "examples/chemistry/qchem_modelling_basics.html#resource-reduction",
    "title": "Quantum Chemistry: Modelling Basics",
    "section": "Resource Reduction",
    "text": "Resource Reduction\nResource reduction refers to lowering the computational requirements to run an algorithm. This applies to both classical and quantum computing. In conventional computing, this translates to less bits required to store information and less operations to do on these bits. For quantum computing, this translates to reducing the number of qubits and the number of gates in quantum circuits.\nOur starting point is the O\\(_2\\) molecule in the 6-311G(d,p) basis. We focus on reducing resource requirements before choosing an algorithm to compute the ground state. For approaches relying on choosing a different ansatz or fragmenting a molecule into smaller subproblems (problem decomposition), the user can refer to the relevant notebooks in the Tangelo/examples folder.\n\no2_6311gdp = SecondQuantizedMolecule(o2_xyz, q=0, spin=2, \n                                     basis=\"6-311G(d,p)\", frozen_orbitals=None)\nprint(f\"{o2_6311gdp.n_active_mos} active molecular orbitals\")\nprint(f\"{o2_6311gdp.n_active_electrons} active electrons\")\n\n36 active molecular orbitals\n16 active electrons\n\n\nThe O\\(_2\\) molecule in the 6-311G(d,p) basis would require 72 qubits and inherently a quantum circuit that is considered too deep for current architectures (NISQ devices) at the time of writing. Decreasing the number of qubits required to encode the problem provides the first indirect way to reduce those requirements. The two methods discussed below are the reduction of the active space and the consideration of molecular symmetries.\n\nActive Space Selection\nActive space selection is a trivial way to reduce the number of qubits by ignoring some molecular orbitals in the post-Hartree-Fock calculation. Applying this method is trivial, but choosing which molecular orbitals to freeze is not. While there is no general algorithm to perform that operation, one can evaluate which orbitals to freeze by first printing the molecular orbital occupancies.\n\no2_6311gdp.mo_occ\n\nNPArrayWithTag([2., 2., 2., 2., 2., 2., 2., 1., 1., 0., 0., 0., 0., 0.,\n                0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n                0., 0., 0., 0., 0., 0., 0., 0.])\n\n\nOne way of picturing this is to only consider frontier orbitals and their neighbors. The correlation lost on the total energy when only considering a subset of the full active space might be small. For example, freezing low-lying occupied molecular orbitals is known as the frozen-core approximation, and can be applied because core orbitals do not mix with valence orbitals. Also, there are algorithms to freeze virtual orbitals, like the Frozen Natural Orbitals (FNO) truncation method [Collect. Czech. Chem. Commun. 2005, 70, 837-850 and J. Chem. Phys. 2008, 128, 164101]. Despite the fact that choosing a suitable active space can be tailored a problem, it can help reducing quantum resources a priori.\nThe code cell below results in the consideration of molecular orbitals near the HOMO-LUMO level. The get_orbitals_excluding_homo_lumo function helps users to get the labels of these orbitals. In our case, the active space is defined from the HOMO-3 to LUMO+3.\n\nfrom tangelo.toolboxes.molecular_computation.frozen_orbitals import get_orbitals_excluding_homo_lumo\n\n# Selecting HOMO-3 to LUMO+3 orbitals.\nfrozen = get_orbitals_excluding_homo_lumo(o2_6311gdp, homo_minus_n=3, lumo_plus_n=3)\n\no2_6311gdp_frozen = SecondQuantizedMolecule(o2_xyz, q=0, spin=2, basis=\"6-311G(d,p)\", \n                                            frozen_orbitals=frozen)\nprint(f\"{o2_6311gdp_frozen.n_active_mos} active molecular orbitals\")\nprint(f\"{o2_6311gdp_frozen.n_active_electrons} active electrons\")\n\n8 active molecular orbitals\n6 active electrons\n\n\nWe decrease the number of considered orbitals from 36 to 8! With conventional fermion-to-qubit mappings, the number of qubits can be reduced from 72 to 16. This is an impressive reduction, but it comes at a significant cost. Configurations involving orbitals below HOMO-4 and above LUMO+4 are not considered here. This results in an energy further away from the true energy as there is nothing telling us that those configurations are irrelevant a priori. In the next code cell, we consider the CCSD calculation of O\\(_2\\) with and without those orbitals.\n\nfrom tangelo.algorithms.classical import CCSDSolver\n\n# CCSD energy with all the orbitals.\ne_o2_6311gdp = CCSDSolver(o2_6311gdp).simulate()\n\n# CCSD energy with HOMO-3 to LUMO+3 orbitals.\ne_o2_6311gdp_frozen = CCSDSolver(o2_6311gdp_frozen).simulate()\n\nprint(f\"Energy difference: {abs(e_o2_6311gdp-e_o2_6311gdp_frozen)*627.5} kcal/mol.\")\n\nEnergy difference: 226.51013348418326 kcal/mol.\n\n\nConsidering the chemical accuracy (1 kcal/mol), the difference is indeed significant: 226 kcal/mol. Therefore, the lower bound with the reduced active space is higher than the CCSD ground state. The takeaway is to be careful when choosing an active space for a molecule.\n\n\nConsidering Symmetries\nMolecular symmetries are reflected in the Hamiltonian structure. The number of electrons in the molecule should be consistent before and after the ansatz has been applied onto the initial state. Electronic configurations not respecting this symmetry can therefore be neglected without loss of accuracy. For our purpose in quantum chemistry, it leads to a smaller number of qubits.\nThe code cell below shows an example of Z2-symmetries qubit tapering with Tangelo.\n\nfrom tangelo.toolboxes.qubit_mappings.mapping_transform import fermion_to_qubit_mapping\nfrom tangelo.toolboxes.operators import count_qubits\nfrom tangelo.toolboxes.operators.taper_qubits import QubitTapering\n\nhamiltonian = fermion_to_qubit_mapping(o2_6311gdp_frozen.fermionic_hamiltonian, \"JW\")\nn_qubits = count_qubits(hamiltonian)\ntaper = QubitTapering(hamiltonian, n_qubits, \n                      n_electrons=o2_6311gdp_frozen.n_active_electrons)\nhamiltonian_taper = taper.z2_tapered_op\nn_qubits_tapered = count_qubits(hamiltonian_taper)\n\nprint(f\"Number of qubits: {n_qubits}\")\nprint(f\"Number of qubits after tapering: {n_qubits_tapered}\")\nprint(f\"{n_qubits - n_qubits_tapered} Z2 symmetries detected\")\n\nNumber of qubits: 16\nNumber of qubits after tapering: 12\n4 Z2 symmetries detected"
  },
  {
    "objectID": "examples/chemistry/qchem_modelling_basics.html#advanced-usage-of-pyscf",
    "href": "examples/chemistry/qchem_modelling_basics.html#advanced-usage-of-pyscf",
    "title": "Quantum Chemistry: Modelling Basics",
    "section": "Advanced Usage of PySCF",
    "text": "Advanced Usage of PySCF\nTangelo currently relies on PySCF. Advanced usage of this open-source quantum chemistry package enables the use of many analysis tools. We show a couple of examples where advanced users can extract more information from a PySCF calculation.\nA SecondQuantizedMolecule object can be exported as a pyscf.gto.Mole object. From that point, anything implemented in PySCF can be applied to this data structure. The next line shows how to do this operation.\npyscf_mol = sec_mol.to_pyscf(sec_mol.basis)\n\nExtracting Mean-Field Quantities\nThe first trick is the extraction of the molecular orbital eigenvalues and coefficients. This can be done with the analyze method, and it can be called from the mean-field object to print relevant molecular properties. The output features many sections, described in the table below.\n\n\n\n\n\n\n\nSection\nDecription\n\n\n\n\nSCF Summaries\nSelf-consistent field energy contributions\n\n\nMO energy\nMolecular orbital eigenvalues\n\n\nMO coefficients\nLinear Combination of Atomic Orbitals (LCAO) coefficients\n\n\nMulliken pop\nMulliken electron population\n\n\nMulliken atomic charges\nPartial charges on each atom and dipole moment\n\n\n\n\no2_sto3g.mean_field.analyze(verbose=5);\n\n**** SCF Summaries ****\nTotal Energy =                        -147.632274661317865\nNuclear Repulsion Energy =              27.989538428826449\nOne-electron Energy =                 -260.148728081504885\nTwo-electron Energy =                   84.526914991360584\n**** MO energy ****\n                Roothaan           | alpha              | beta\nMO #1   energy= -20.4249798600401  | -20.4400185052847  | -20.4099412147954  occ= 2\nMO #2   energy= -20.424364897337   | -20.4389300606557  | -20.4097997340182  occ= 2\nMO #3   energy= -1.55251062929102  | -1.61345571756454  | -1.49156554101749  occ= 2\nMO #4   energy= -0.993242469558959 | -1.09010934627351  | -0.896375592844403 occ= 2\nMO #5   energy= -0.581544505580074 | -0.616775236948374 | -0.546313774211774 occ= 2\nMO #6   energy= -0.579365900007762 | -0.714071611414284 | -0.444660188601237 occ= 2\nMO #7   energy= -0.579365900007761 | -0.714071611414284 | -0.444660188601237 occ= 2\nMO #8   energy= -0.0715888741311829 | -0.412074886861292 | 0.268897138598928  occ= 1\nMO #9   energy= -0.0715888741311817 | -0.412074886861291 | 0.268897138598927  occ= 1\nMO #10  energy= 0.73033550676964   | 0.689507257614018  | 0.77116375592526   occ= 0\n ** MO coefficients (expansion on meta-Lowdin AOs) **\n               #1        #2        #3        #4        #5       \n  0 O 1s      -0.70708   0.70711  -0.00060  -0.00323  -0.00005\n  0 O 2s      -0.00483   0.00057   0.65237   0.65105   0.27278\n  0 O 2px      0.00000   0.00000   0.00000  -0.00000  -0.00000\n  0 O 2py      0.00000   0.00000   0.00000  -0.00000  -0.00000\n  0 O 2pz     -0.00311   0.00019   0.27278  -0.27591  -0.65237\n  1 O 1s       0.70708   0.70711  -0.00060   0.00323  -0.00005\n  1 O 2s       0.00483   0.00057   0.65237  -0.65105   0.27278\n  1 O 2px      0.00000   0.00000   0.00000  -0.00000  -0.00000\n  1 O 2py      0.00000   0.00000   0.00000  -0.00000  -0.00000\n  1 O 2pz     -0.00311  -0.00019  -0.27278  -0.27591   0.65237\n               #6        #7        #8        #9        #10      \n  0 O 1s      -0.00000  -0.00000  -0.00000  -0.00000  -0.00475\n  0 O 2s       0.00000   0.00000   0.00000   0.00000   0.27589\n  0 O 2px     -0.10974   0.69854  -0.11637   0.69747  -0.00000\n  0 O 2py      0.69854   0.10974   0.69747   0.11637  -0.00000\n  0 O 2pz     -0.00000  -0.00000   0.00000  -0.00000   0.65105\n  1 O 1s       0.00000  -0.00000  -0.00000  -0.00000   0.00475\n  1 O 2s       0.00000   0.00000  -0.00000  -0.00000  -0.27589\n  1 O 2px     -0.10974   0.69854   0.11637  -0.69747   0.00000\n  1 O 2py      0.69854   0.10974  -0.69747  -0.11637   0.00000\n  1 O 2pz      0.00000   0.00000  -0.00000   0.00000   0.65105\n ** Mulliken pop on meta-lowdin orthogonal AOs  **\n ** Mulliken pop  **\npop of  0 O 1s        1.99995\npop of  0 O 2s        1.84777\npop of  0 O 2px       1.50000\npop of  0 O 2py       1.50000\npop of  0 O 2pz       1.15227\npop of  1 O 1s        1.99995\npop of  1 O 2s        1.84777\npop of  1 O 2px       1.50000\npop of  1 O 2py       1.50000\npop of  1 O 2pz       1.15227\n ** Mulliken atomic charges  **\ncharge of  0O =      0.00000\ncharge of  1O =     -0.00000\nDipole moment(X, Y, Z, Debye): -0.00000,  0.00000, -0.00000\n\n\n\n\nOutputting Cube Files\nVisualization of molecular orbitals is useful for analysis purposes or making figures. Those few lines create a cube file, compatible with many chemical visualization softwares (GaussView, avogadro, VMD, …), for the MO #10.\nfrom pyscf import tools\ntools.cubegen.orbital(pyscf_mol, f\"MO10.cube\", sec_mol.mean_field.mo_coeff[:,9]) # Python indices start with 0."
  },
  {
    "objectID": "examples/chemistry/qchem_modelling_basics.html#closing-words",
    "href": "examples/chemistry/qchem_modelling_basics.html#closing-words",
    "title": "Quantum Chemistry: Modelling Basics",
    "section": "Closing Words",
    "text": "Closing Words\nThis notebook glanced over the first steps of modelling a chemical system for quantum computing exploration. One of the challenges of quantum chemistry is the ever-present trade-off between computational resources requirements and accuracy of calculations. We emphasized how the choice of a basis set and frozen orbitals can greatly affect this trade-off.\nQuantum computing is a nascent technology, and the capabilities of current devices are limited. Efficient modelling of the system can be therefore crucial to sucessfully design experiments on quantum computers, and even simulators.\nIn our VQE notebook, we show how the modelling choices can greatly impact the quantum computational resources required by this quantum algorithm, and how the algorithm options themselves can further affect both resource requirements and accuracy."
  },
  {
    "objectID": "examples/chemistry/qchem_modelling_basics.html#references",
    "href": "examples/chemistry/qchem_modelling_basics.html#references",
    "title": "Quantum Chemistry: Modelling Basics",
    "section": "References",
    "text": "References\n\nMcQuarrie, D. A. Quantum Chemistry, University Science Books 2nd ed. (2007)\nEngel, T. Quantum chemistry & spectroscopy. Pearson 3rd ed. (2012)\nSzabo, A. & Ostlund, N. S. Modern quantum chemistry: Introduction to advanced electronic structure theory. Mineola, Dover Publications 1st ed. (1996).\nComputational_Quantum_Chemistry, Chemistry LibreTexts, visited on Aug 17, 2022."
  },
  {
    "objectID": "examples/workflow_basics/3.noisy_simulation.html",
    "href": "examples/workflow_basics/3.noisy_simulation.html",
    "title": "Linq: noisy simulation",
    "section": "",
    "text": "Open In Colab\nThis notebook assumes that you are familiar with the basics of this package (Gate, Circuit, Translator, Simulator), and focuses on how users can perform noisy simulation on simulators such as cirq, qiskit or qulacs, using a common interface. Users are free to pick between different compute backends, favoring the one with the best performance of most adequate features, and switch between them with minimal changes to their code.\nIn particular, we also take the time here to briefly introduce the various quantum error channels supported for the sake of clarity, occasionally sprinkling some (gentle) mathematical equations on top.\nFinally, the last section of this notebook delves a bit deeper into the strengths and weaknesses of the different backends supported, in order to give users some insight about what simulator may work best for their experiments, and yield the best performance."
  },
  {
    "objectID": "examples/workflow_basics/3.noisy_simulation.html#table-of-contents",
    "href": "examples/workflow_basics/3.noisy_simulation.html#table-of-contents",
    "title": "Linq: noisy simulation",
    "section": "Table of contents",
    "text": "Table of contents\n\n1. NoiseModel class\n2. Noisy Simulation\n2.1 Pauli error\n2.2 Depolarization error\n3. About the supported backends"
  },
  {
    "objectID": "examples/workflow_basics/3.noisy_simulation.html#requirements",
    "href": "examples/workflow_basics/3.noisy_simulation.html#requirements",
    "title": "Linq: noisy simulation",
    "section": "Requirements",
    "text": "Requirements\nIn order to run the contents of this notebook, I simply recommend that you install tangelo as per the installation instructions, as well as one or several backends supporting noisy simulation (cirq, qiskit, qulacs…). You can install them with pip. Executing the cell below provides a quick way of installing Tangelo, as well as the minimal set of backends to execute code cells in this notebook.\n\n# Installation of tangelo if not already installed.\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop  --quiet\n    !pip install qiskit qulacs amazon-braket-sdk --quiet"
  },
  {
    "objectID": "examples/workflow_basics/3.noisy_simulation.html#noisemodel-class",
    "href": "examples/workflow_basics/3.noisy_simulation.html#noisemodel-class",
    "title": "Linq: noisy simulation",
    "section": "1. NoiseModel class ",
    "text": "1. NoiseModel class \nThe noisy_simulation module is home to the NoiseModel class, which provides a generic way to define a noise model that can later on be passed to the Simulator to perform the noisy simulation of a Circuit object on backends supporting that feature.\nA NoiseModel object contains a dictionary that maps abstract gates to a list of noises and their parameters, which are usually probabilities. The type of noise currently available can be reached using the SUPPORTED_NOISE_MODELS variable, and the documentation of the NoiseModel class explains what parameters are valid for each of them. The noisy_gates method allows users to quickly check the set of gates included in the noise model.\nThis representation tells the simulation backend that whenever one of the gates listed in this dictionary is encountered at runtime, the corresponding additional noise(s) should be applied to the quantum state afterwards.\nBelow, we show the available noise models as well as how users can instantiate a NoiseModel object and then specify noise for any gate relevant to them (here, a Pauli noise with uniform probability distribution over X, Y and Z) using the add_quantum_error method.\n\nfrom tangelo.linq.noisy_simulation import NoiseModel, SUPPORTED_NOISE_MODELS\n\nprint(f'Supported noise models: {SUPPORTED_NOISE_MODELS}\\n')\n\nnmp = NoiseModel()\nnmp.add_quantum_error(\"X\", 'pauli', [1/3, 1/3, 1/3])\nnmp.add_quantum_error(\"CNOT\", 'pauli', [1/3, 1/3, 1/3])\n\nprint(f'Noisy gates: {nmp.noisy_gates}\\n{nmp}')\n\nSupported noise models: {'pauli', 'depol'}\n\nNoisy gates: {'CNOT', 'X'}\n{'X': [('pauli', [0.3333333333333333, 0.3333333333333333, 0.3333333333333333])], 'CNOT': [('pauli', [0.3333333333333333, 0.3333333333333333, 0.3333333333333333])]}\n\n\nAs you can see above, attempting to print a NoiseModel object prints the underlying dictionary. Each noisy gate is associated with a list of 2-tuples, corresponding to the noise model and its parameters.\nUsing add_quantum_error several times on the same gate allows users to specify potentially complex noise models, cumulating different types of error channels. Combined with variables spanning sets of gates and the Python syntax, we can quickly express rather complete noise models, such as the arbitrary one below:\n\nfrom tangelo.linq import ONE_QUBIT_GATES, TWO_QUBIT_GATES\n\nnm = NoiseModel()\n\nfor g in ONE_QUBIT_GATES:\n    nm.add_quantum_error(g, 'pauli', [1/4]*3)\nnm.add_quantum_error('CNOT', 'pauli', [1., 0., 0.])\nnm.add_quantum_error('CNOT', 'depol', 0.72)\nprint(nm)\n\n{'PHASE': [('pauli', [0.25, 0.25, 0.25])], 'T': [('pauli', [0.25, 0.25, 0.25])], 'RX': [('pauli', [0.25, 0.25, 0.25])], 'S': [('pauli', [0.25, 0.25, 0.25])], 'Z': [('pauli', [0.25, 0.25, 0.25])], 'Y': [('pauli', [0.25, 0.25, 0.25])], 'RY': [('pauli', [0.25, 0.25, 0.25])], 'H': [('pauli', [0.25, 0.25, 0.25])], 'X': [('pauli', [0.25, 0.25, 0.25])], 'RZ': [('pauli', [0.25, 0.25, 0.25])], 'CNOT': [('pauli', [1.0, 0.0, 0.0]), ('depol', 0.72)]}\n\n\nNote: You can directly access the underlying dictionary of the NoiseModel object through its private member _quantum_errors if you wish to perform some “surgery” on it directly, in order to modify an existing object. We however recommend to use the add_quantum_error whenever possible to avoid bad surprises and subtle bugs.\nNote: Attempting to cumulate quantum error channels of same type (ex: two depol error channels) will return an error."
  },
  {
    "objectID": "examples/workflow_basics/3.noisy_simulation.html#noisy-simulation",
    "href": "examples/workflow_basics/3.noisy_simulation.html#noisy-simulation",
    "title": "Linq: noisy simulation",
    "section": "2. Noisy Simulation ",
    "text": "2. Noisy Simulation \nOnce a noise model has been created, it can be passed to a simulator (preferably at instantiation). Not all simulators can perform noisy simulation: check out the backend_info dictionary to see which targets shows noisy_simulation set to True. Qiskit and qulacs should be among the available options.\n\nfrom tangelo.linq import backend_info\nfrom pprint import pprint \n\npprint(backend_info)\n\n{'cirq': {'noisy_simulation': True,\n          'statevector_available': True,\n          'statevector_order': 'lsq_first'},\n 'qdk': {'noisy_simulation': False,\n         'statevector_available': False,\n         'statevector_order': None},\n 'qiskit': {'noisy_simulation': True,\n            'statevector_available': True,\n            'statevector_order': 'msq_first'},\n 'qulacs': {'noisy_simulation': True,\n            'statevector_available': True,\n            'statevector_order': 'msq_first'}}\n\n\nYou can then instantiate a Simulator object for the target of your choice, and provide both the number of shots and noise model required. We recommend to set these parameters at instantiation and avoid modifying them later.\nAssuming you have defined an abstract circuit (e.g an object of the Circuit class), the simulate method can then be used to perform the noisy simulation for the desired target and number of shots. It returns a 2-tuple whose second entry is None, which we will disregard as a noisy simulation does not return a statevector.\n\nfrom tangelo.linq import get_backend, Gate, Circuit\n\n# Define a noise model\nnmp = NoiseModel()\nnmp.add_quantum_error(\"X\", 'pauli', [1/3, 1/3, 1/3])\n\n# Instantiate a simulator supporting noisy simulation\ns_nmp = get_backend(target='qulacs', n_shots=10**6, noise_model=nmp)\n\n# Define a Circuit\nc1 = Circuit([Gate(\"X\",0)])\n\n# Simulate and look at the results\nres_pauli1, _ = s_nmp.simulate(c1)\nprint(res_pauli1)\n\n{'0': 0.665706, '1': 0.334294}\n\n\n\n2.1 Pauli error \nA Pauli error channel can be defined by an arbitrary probability distribution \\([p_X, p_Y, p_Z]\\) over the 3 Pauli operators. This channel randomly applies one of the X, Y, Z Pauli operators after a noisy gate has been encountered, by sampling from this probability distribution. Implicitly, the identity is applied with probability \\(1- (p_X + p_Y + p_Z)\\), and no noise is added in that case.\nIn the example above, our circuit merely consists of a single X gate applied to a single qubit, initially in state \\(|0\\rangle\\). Our noise model always randomly applies, with equal probability, an extra X, Y or Z gate to the resulting quantum state.\nAs the number of shots grows, the results of the above should converge towards \\(|1\\rangle\\) (resp \\(|0\\rangle\\)) observed with probability \\(1/3\\) (resp \\(2/3\\)). The theoretical verification is pretty straightforward:\n\nAfter X has been applied to our qubit, our system is in state \\(|1\\rangle\\)\nWith probability \\(2/3\\), an extra X or Y gate is applied, and our system is sure to be measured in state \\(|0\\rangle\\)\nWith probability \\(1/3\\), an extra Z gate is applied, and our system is sure to be measured in state \\(|1\\rangle\\)\n\n\n\n2.2 Depolarization error \nDepolarizing quantum error channels are also available. The channel can be defined as:\n\\[E_{\\lambda, n}(\\rho) = (1 - \\lambda)\\rho + \\lambda Tr[\\rho] \\frac{I}{2^{n}}\\]\nwhere:\n\n\\(n\\) is the number of qubits in the system\n\\(\\rho\\) is the density matrix representing the quantum state of the system\n\\(\\lambda\\) is the parameter of the depolarizing channel, and is such that \\(0 \\le \\lambda \\le \\frac{4^n}{4^n-1}\\)\n\nIn particular:\n\nIf \\(\\lambda=0\\), \\(E\\) is the identity channel (no noise)\nIf \\(\\lambda=1\\), \\(E(\\rho)=\\frac{I}{2^{n}}\\)\nIf \\(\\lambda=\\frac{4^n}{4^n-1}\\), \\(E\\) is a uniform Pauli error channel\n\nThe cell below shows that calculations for our “X-gate circuit” align with this formula. In particular, the case where \\(\\lambda=\\frac{4}{3}\\) yields the same error channel than the Pauli error channel introduced in the previous section.\n\nfor l in [0., 1., 4/3]:\n    nmd = NoiseModel()\n    nmd.add_quantum_error(\"X\", 'depol', l)\n    s_nmd = get_backend(target='qulacs', n_shots=10**6, noise_model=nmd)\n    res_depol1, _ = s_nmd.simulate(c1) # This circuit only contains a single X gate\n    print(f'lambda = {l:.2f} :: {res_depol1}')\n\nlambda = 0.00 :: {'1': 1.0}\nlambda = 1.00 :: {'0': 0.500183, '1': 0.499817}\nlambda = 1.33 :: {'0': 0.666488, '1': 0.333512}\n\n\nSimilarly, we verify that in the example below, the results coincide with the mathematical formula above, and yield \\(\\frac{1}{2}\\rho + \\frac{1}{8}I\\), \\(\\rho\\) being the density matrix of the system, still left in state \\(|00\\rangle\\) after the CNOT gate has been applied.\n\n# A circuit with a single CNOT gate\nc2 = Circuit([Gate(\"CNOT\", target=1, control=0)])\n\nnmd = NoiseModel()\nnmd.add_quantum_error(\"CNOT\", 'depol', 0.5)\ns_nmd = get_backend(target='qulacs', n_shots=10**6, noise_model=nmd)\nres_depol1, _ = s_nmd.simulate(c2)\nprint(res_depol1)\n\n{'11': 0.124993, '00': 0.624951, '01': 0.125071, '10': 0.124985}"
  },
  {
    "objectID": "examples/workflow_basics/3.noisy_simulation.html#about-the-supported-backends",
    "href": "examples/workflow_basics/3.noisy_simulation.html#about-the-supported-backends",
    "title": "Linq: noisy simulation",
    "section": "3. About the supported backends ",
    "text": "3. About the supported backends \nget_backend provides a uniform interface to several noisy simulators, such as qiskit and qulacs, hiding the complexity of the noisy simulation process from the user. The inner workings are a bit different depending on the simulator selected, and the simulators themselves have their own strengths and weaknesses, which we gloss over in order to provide you with some insight about what tool may help you the most in your developments.\n\nQiskit [This section is outdated and needs to be updated]\nqiskit already has their own NoiseModel class. Our package simply translates our NoiseModel object into the qiskit one at runtime, which is then passed to their shot-based QASM simulator, in charge of transpiling and applying this noise model to the circuit. The package exposes this function as get_qiskit_noise_model, but you should ideally let the backend object take care of it. I recommend you import qiskit’s NoiseModel as QiskitNoiseModel to avoid insidious bugs, if you ever need both in the same script.\nNote: The rest of this subsection may not hold for long, as a pull-request introducing support for rx, ry and rz gates has been merged into the Qiskit repository, and may be avilable through the pip package soon (Oct 2020?)\nQiskit can be restrictive, as it enforces transpilation of your circuit into the gate set supported by their qasm simulator. For instance, the qasm simulator gate set does not include the rx,ry,rz rotation gates, but instead converts them at runtime into u1,u2 oru3 gates (reference), which are IBM’s gates. This has several implications:\n\nUsers may not “get what they ask for”: there is a loss of transparency due to what’s going on under the hood, with the transpiling step.\nIn particular all rotations gates may map into u3 gates ar runtime, since it can apply any single-qubit unitary with the right parameters. This means that specifying different noise channel for the different rotation gates (which may make sense according to some researchers) is ill-defined: what noise should then be applied to u3 ? Our package limits cumulating quantum error channels of different natures only to avoid stacking redundant noise to mitigate the issue, but it is better to probably switch to another backend to stay true to your research.\n\n\nfrom tangelo.linq.noisy_simulation import get_qiskit_noise_model\n\nnm = NoiseModel()\nnm.add_quantum_error('RX', 'depol', 4/3)\nnm.add_quantum_error('RX', 'pauli', [1.,0.,0.])\nqnm = get_qiskit_noise_model(nm)\n\n# Any rotation gate will have its quantum error channel applied to u1, u2, u3 as we do not know\n# which one the transpiler will generate and need to apply noise to. \n# Qiskit always shows a warning when several noise channels are composed onto the same basis gate\nprint(qnm)\n\nWARNING: all-qubit error already exists for instruction \"u1\", composing with additional error.\nWARNING: all-qubit error already exists for instruction \"u2\", composing with additional error.\nWARNING: all-qubit error already exists for instruction \"u3\", composing with additional error.\n\n\nNoiseModel:\n  Basis gates: ['cx', 'id', 'rz', 'sx', 'u1', 'u2', 'u3']\n  Instructions with noise: ['u2', 'u1', 'u3']\n  All-qubits errors: ['u1', 'u2', 'u3']\n\n\n\n\nQulacs\nqulacs does not have built-in noise model objects, but has noisy gates instead, which means users can build their own noisy circuit by adding these noisy gates when relevant. That noisy circuit is then simulated by the qulacs C++ engine. This very flexible approach, coupled to the fact the qulacs simulator does not enforce any specific basis gate set (it even supports the IBM u gates), lets you do pretty much whatever you want when it comes to noise.\nThe translate_circuit function, taking in an abstract circuit and returning a qulacs circuit thus supports an extra arguments compared to the other one: it can take in a NoiseModel object, and will return the noisy circuit. The Simulator is tasked with calling this translation function with the noise model, under the hood. The noisy circuit is however of limited interest to the user to have access to this circuit, as the noisy gates show up as “generic gates” and very little information is available through Python (the underlying qulacs code being written in C++): all you know is basically where noisy gates have been added.\nIf you’d like to know more about what these noisy gates are, please have a look at the following: - Brief look at Probabilistic gates - Code listing: Noise functions\n\n\ncirq\nMuch like qulacs, cirq does not have built-in noise model objects, but has noisy gates instead, which means users can build their own noisy circuit by adding these noisy gates when relevant. That noisy circuit is then simulated by cirq. The translate_circuit function takes a NoiseModel object to implement this approach, returning the noisy circuit.\nOne further note, the DensityMatrixSimulator is used for cirq simulation of noisy or mixed state circuits.\nIf you’d like to know more about what these noisy gates are, please have a look at the following: - Guide: Noise - Code listing: All Gates\n\n\nPerformance\nWhen it comes to noisy simulation, we noticed that the performance of the different backends we support was not as we expected from publicly available benchmarks, which usually focus on noiseless simulation. This may be explained by both the difference in the approaches taken by these backends, as well as the quality of our wrappers. Performance also depends on:\n\nthe size of your circuit (number of qubits, depth)\nyour hardware and your environment (OS, number of OpenMP threads, virtual machine or not…)\n\nWe recommend proceeding on a case-by-case basis. Below, a quick example on our both of them perform on a circuit repeating CNOT ladders a few times. Feel free to change some parameters.\nNote: Jupyter notebooks may be considerably slower than running Python scripts directly, depending on your environment. They may not be the most reliable when it comes to making a choice. In the future, there may be a benchmark folder available in this package, which could help you figure out quickly what is best in your environment and how fast things can go.\n\nimport time\nimport numpy as np\n\ntheta = 2.1\nn_qubits = 5\nn_repetitions = 3\n\ndef ladder_gates(n_qubits, theta, n_repetitions):\n    gates = [Gate(\"H\", i) for i in range(n_qubits)]\n    gates += [Gate(\"CNOT\", target=i+1, control=i) for i in range (n_qubits-1)]\n    gates += [Gate(\"RY\", n_qubits-1, parameter=theta)]\n    gates += [Gate(\"CNOT\", target=i+1, control=i) for i in range (n_qubits-1)][::-1]\n    return gates * n_repetitions\n\n# CNOT ladder circuit, a common pattern in quantum chemistry ansatz circuits\nc_base = Circuit(ladder_gates(n_qubits, theta, n_repetitions))\nprint(c_base)\n\n# Define noise model\nnmb = NoiseModel()\nnmb.add_quantum_error('RY', 'pauli', [.5, 0.5, 0.])\nnmb.add_quantum_error('CNOT', 'depol', 0.2)\nprint(nmb,'\\n')\n\n# Elapsed time may differ greatly depending on your machine and development environment\nfor backend in {'qulacs', 'qiskit', 'cirq'}:\n    sim = get_backend(backend, n_shots=10**6, noise_model=nmb)\n    tstart = time.time()\n    res, _ = sim.simulate(c_base)\n    print(f'{backend}:: {res} \\t (elapsed: {time.time()-tstart:.1f} s)\\n')\n\nCircuit object. Size 42 \n\nH         target : [0]   \nH         target : [1]   \nH         target : [2]   \nH         target : [3]   \nH         target : [4]   \nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nCNOT      target : [4]   control : [3]   \nRY        target : [4]   parameter : 2.1\nCNOT      target : [4]   control : [3]   \nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \nH         target : [0]   \nH         target : [1]   \nH         target : [2]   \nH         target : [3]   \nH         target : [4]   \nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nCNOT      target : [4]   control : [3]   \nRY        target : [4]   parameter : 2.1\nCNOT      target : [4]   control : [3]   \nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \nH         target : [0]   \nH         target : [1]   \nH         target : [2]   \nH         target : [3]   \nH         target : [4]   \nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [3]   control : [2]   \nCNOT      target : [4]   control : [3]   \nRY        target : [4]   parameter : 2.1\nCNOT      target : [4]   control : [3]   \nCNOT      target : [3]   control : [2]   \nCNOT      target : [2]   control : [1]   \nCNOT      target : [1]   control : [0]   \n\n{'RY': [('pauli', [0.5, 0.5, 0.0])], 'CNOT': [('depol', 0.2)]} \n\ncirq:: {'10110': 0.031467, '11001': 0.03113, '00000': 0.031401, '01100': 0.031785, '10100': 0.031793, '11111': 0.030839, '01111': 0.031061, '10101': 0.03082, '00001': 0.031185, '11100': 0.03136, '11010': 0.031607, '01010': 0.031367, '01001': 0.031188, '00011': 0.030849, '00101': 0.03113, '11110': 0.031378, '00010': 0.031566, '10000': 0.03142, '11000': 0.031563, '00111': 0.030893, '10001': 0.031271, '00100': 0.031254, '01101': 0.030801, '11011': 0.03114, '01011': 0.03132, '01000': 0.031301, '10011': 0.031099, '10111': 0.031005, '01110': 0.031418, '11101': 0.030834, '10010': 0.031388, '00110': 0.031367}     (elapsed: 5.5 s)\n\nqiskit:: {'10111': 0.029946, '01100': 0.030131, '00000': 0.030416, '11110': 0.030231, '01011': 0.032338, '10000': 0.032232, '11000': 0.030366, '01001': 0.030344, '11010': 0.032555, '10011': 0.032224, '00001': 0.031977, '10101': 0.032195, '10100': 0.030172, '11001': 0.032078, '01110': 0.032224, '00011': 0.030167, '10110': 0.032283, '11101': 0.030029, '00111': 0.032251, '01010': 0.030193, '01101': 0.032227, '11111': 0.032376, '01000': 0.032486, '11011': 0.030211, '10010': 0.030649, '00100': 0.032344, '00110': 0.030454, '10001': 0.030305, '00010': 0.032109, '01111': 0.03028, '00101': 0.030018, '11100': 0.032189}     (elapsed: 2.1 s)\n\nqulacs:: {'10110': 0.031455, '00100': 0.031153, '11111': 0.030975, '10001': 0.031072, '11100': 0.031301, '01110': 0.03146, '00111': 0.031039, '01001': 0.030899, '01011': 0.030996, '11101': 0.03128, '11010': 0.03132, '00110': 0.031647, '11110': 0.031263, '10010': 0.03098, '10101': 0.031471, '01010': 0.031262, '11011': 0.031197, '11000': 0.031448, '00011': 0.03094, '10011': 0.031287, '00010': 0.031363, '01111': 0.031272, '00001': 0.03129, '10100': 0.03135, '01100': 0.031506, '01101': 0.031216, '01000': 0.031404, '00101': 0.030979, '00000': 0.031368, '10111': 0.03109, '11001': 0.031172, '10000': 0.031545}    (elapsed: 7.5 s)\n\n\n\n\nValentin Senicourt"
  },
  {
    "objectID": "examples/workflow_basics/2.qpu_connection.html",
    "href": "examples/workflow_basics/2.qpu_connection.html",
    "title": "Connecting to quantum services with Tangelo",
    "section": "",
    "text": "Tangelo provides convenient ways to help you run experiments on quantum hardware. The tangelo.linq module integrates the API provided by some hardware providers (IonQ, Honeywell…) or broader quantum cloud services providers such as Azure Quantum (Microsoft) or Braket (AWS). Here’s what Tangelo provides to support you:\nRegardless of what you pick: you are responsible for configuring the environment allowing you to submit jobs, and entering your own credentials. You are billed directly by the target quantum cloud service(s), Tangelo is simply here as a helpful, transparent middleman.\nThis approach is an alternative to using QEMIST Cloud, which we intend to make a single and convenient entry point to reach many different platforms. What’s pretty cool with this other option is that users do not have to set up the environment required by the quantum cloud(s) of their choice or even an account with those services. A QEMIST Cloud account provides a single entry point enabling you to reach all of them, and pay with your QEMIST Cloud credits."
  },
  {
    "objectID": "examples/workflow_basics/2.qpu_connection.html#table-of-contents",
    "href": "examples/workflow_basics/2.qpu_connection.html#table-of-contents",
    "title": "Connecting to quantum services with Tangelo",
    "section": "Table of contents",
    "text": "Table of contents\n\nMethod 1: Fine control (translation functions)\nMethod 2: Convenience (Connection classes)\n\n2.1. Braket example\n\n\n2.2. IBM example\n\n\n2.3. IonQ example\n\n\n2.4. Azure Quantum"
  },
  {
    "objectID": "examples/workflow_basics/2.qpu_connection.html#requirements",
    "href": "examples/workflow_basics/2.qpu_connection.html#requirements",
    "title": "Connecting to quantum services with Tangelo",
    "section": "Requirements",
    "text": "Requirements\n\nTangelo needs to be installed in your environment. The cell below does this installation for you if it is not found.\nThe requirements specific to the target quantum services are detailed below, in the corresponding section. It’s usually about setting up your environment and obtaining valid credentials.\n\n\n# Installation of tangelo if not already installed.\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop  --quiet"
  },
  {
    "objectID": "examples/workflow_basics/2.qpu_connection.html#method-1-fine-control-translation-functions",
    "href": "examples/workflow_basics/2.qpu_connection.html#method-1-fine-control-translation-functions",
    "title": "Connecting to quantum services with Tangelo",
    "section": "Method 1: Fine control (Translation functions) ",
    "text": "Method 1: Fine control (Translation functions) \nIn order to submit an experiment through some quantum services, you need to provide objects such as quantum circuits or qubit operators in one of the formats they support. For example, IBM may support formats such as OpenQASM and Qiskit, Amazon supports Braket, and your favorite hardware provider may support their own specific format using native gates not supported anywhere else.\nTangelo expresses quantum circuits and operators in its own generic format, in order to keep the library compatible with various technologies, and ready to accomodate the quantum platforms of tomorrow. The linq module contains a collection of translation functions to convert from the Tangelo format to popular formats (and sometimes the other way around). If you haven’t, check out this notebook for examples.\nHere is a simple example with IonQ, but there are various different formats supported in Tangelo. IonQ’s hardware is available through several cloud services, but they also have their own cloud portal. The following shows how to translate a Tangelo circuit into the json IonQ format detailed in their documentation.\n\nfrom tangelo.linq import Circuit, Gate, translate_circuit\n\ncirc1 = Circuit([Gate(\"H\", 0), Gate(\"X\", 1)])\njson_circ1 = translate_circuit(circ1, target=\"ionq\")\nprint(json_circ1)\n\n{'qubits': 2, 'circuit': [{'gate': 'h', 'targets': [0]}, {'gate': 'x', 'targets': [1]}]}\n\n\nYou now have a quantum circuit in a very specific format, supported by IonQ’s platforms. You can interact directly with their cloud API, and are in full control of all the steps: connecting to their quantum services, submitting and managing quantum jobs, etc.\n\nPros: Fine control, can leverage latest features / changes from a hardware provider.\nCons: You need to learn how to interact with the target platform (e.g their API), and are responsible for everything from there on to run the hardware experiment."
  },
  {
    "objectID": "examples/workflow_basics/2.qpu_connection.html#method-2-convenience-connection-classes",
    "href": "examples/workflow_basics/2.qpu_connection.html#method-2-convenience-connection-classes",
    "title": "Connecting to quantum services with Tangelo",
    "section": "Method 2: Convenience (Connection classes) ",
    "text": "Method 2: Convenience (Connection classes) \nConnection classes are here for convenience, to provide a simple, more generic way to connect to various platforms and manage experiments programmatically. We recommend that you do not hesitate to leverage whatever graphic interface / dashboard the target quantum service provider offers, as it is usually a more comfortable way to access and visualize a lot of information about the systems available or your jobs.\nThe connection classes spare you a number of lines of code and having to figure out a bunch of APIs, but you still have to install whatever your environment needs and provide your own valid credentials to the target services. Not all quantum services offer the same functionalities, or handle authentication similarly: we recommend you have a look at the classes themselves (the develop branch may have additional features) to see what they have to offer or how they accomplish it.\nHere’s how it typically works:\n\n\n\n\n\n\n\nStep\nDescription\n\n\n\n\nPre-requisites\nInstall the required packages, acquire valid credentials for the target quantum service (check out their documentation)\n\n\nCreate connection objects\nInstantiate relevant connection object (e.g IBMConnection, BraketConnection, …). This usually requires you to provide your credentials either as parameters or through environment variables.\n\n\nSubmit a job\nUse the job_submit method. It takes your Tangelo objects as input and some options. It returns and logs job IDs\n\n\nManage your job\nUse job_status or job_cancel methods on jobs you’ve already submitted, through their job ID.\n\n\nRetrieve your results\nUse the job_result method to retrieve your job results in a generic Tangelo format (bitstrings with qubit 0 on the left, read left-to-right), but also in raw format with all the metadata provided by the target service.\n\n\n\nDepending on the service, additional methods and features may be available (listing all devices visible on the service, obtaining information about their noise, cost estimate …). Let’s see a few examples."
  },
  {
    "objectID": "examples/workflow_basics/2.qpu_connection.html#braketconnection-example",
    "href": "examples/workflow_basics/2.qpu_connection.html#braketconnection-example",
    "title": "Connecting to quantum services with Tangelo",
    "section": "1. BraketConnection example ",
    "text": "1. BraketConnection example \n\n1.1 Pre-requisites\nInstall the Braket python SDK provided by Amazon (pip install amazon-braket-sdk). You also need to install the AWS CLI, and assumes you have an IAM user with proper permissions (Braket, S3 buckets). The Braket services can also be accessed through your web browser, which gives you access to managed python notebooks. These actions may require assistance from whoever manages cloud access in your organization.\nBefore you are able to use the service, some environment variables should be set. Depending on how you use Braket (managed notebooks, etc), you may or may have not to set all of these variables yourself. The following should be enough, replace the dots by the appropriate strings. Some of these information may be in your ~/.aws/credentials file.\n\n# Set up credentials [clear before pushing to public repo]\nos.environ[\"AWS_REGION\"] = \"...\"\nos.environ[\"AWS_ACCESS_KEY_ID\"] = \"...\"\nos.environ[\"AWS_SECRET_ACCESS_KEY\"] = \"...\"\nos.environ[\"AWS_SESSION_TOKEN\"] = \"...\"\n\nIn order to submit experiments through Braket or retrieve results, you need to provide the name of a S3 bucket your account has access to, as well as a folder for the results. We recommend you ensure that is set up before proceeding.\n\n\n1.2 Instantiate the connection object\nAs long as the Braket python package is found in your environment, instantiation will be successful. Your environment variables or S3 bucket / folder come into play later, as you attempt to make requests to the service. You can set up your S3 bucket name and folder during instantiation (or change their value manually later using the s3_bucket and folder attributes).\n\nfrom tangelo.linq.qpu_connection.braket_connection import BraketConnection\n\nconn = BraketConnection(s3_bucket=\"your_bucket_name\", folder=\"your_folder_name\")\n\n\n\n1.3 Submit and manage jobs, additional features.\nThe fastest way to see things in action may be to check out our tests. It’s pretty straightforward.\nThis connection object supports batch submission of quantum circuits, which means you could provide a list of circuits and submit them all at once, otherwise your jobs may not run in similar conditions (quantum devices exhibit noise drift and are recalibrated regularly). To see all what the interface has to offer, the best way is to check out the implementation."
  },
  {
    "objectID": "examples/workflow_basics/2.qpu_connection.html#ibmconnection-example",
    "href": "examples/workflow_basics/2.qpu_connection.html#ibmconnection-example",
    "title": "Connecting to quantum services with Tangelo",
    "section": "2. IBMConnection example ",
    "text": "2. IBMConnection example \nWe have run an experiment on IBM devices for the IBM Quantum Summit of 2022, and it is probably the easiest way to see it in action. Section 4 of this notebook details the submission of the experiment itself using IBM Quantum, which involves Zero-Noise Extrapolation and plotting with error bars. You can find our implementation details here.\nThe gist of it:\n\nyou need to install qiskit and qiskit-runtime, and provide your IBM_TOKEN before instantiating the connection.\nthe interface is generic (job_submit, job_cancel, job_results, …). job_submit can use the sampler or estimator services, which respectively return histograms of quasi-frequencies, or expectation values.\nthe interface supports a number of options for batch submission, optimization and noise-mitigation.\n\nIt’s pretty easy to create an account on IBM Quantum, and even get access to some quantum computers for free."
  },
  {
    "objectID": "examples/workflow_basics/2.qpu_connection.html#ionqconnection-example",
    "href": "examples/workflow_basics/2.qpu_connection.html#ionqconnection-example",
    "title": "Connecting to quantum services with Tangelo",
    "section": "3. IonQConnection example ",
    "text": "3. IonQConnection example \n\n3.1 Pre-requisites\nIonQ does not require any package in particular to be installed. As long as you can interact with their REST API, all is well. At the moment of writing, users allowed to use the IonQ API should have an ID token, e.g a string of alphanumeric characters and dashes, which can be obtained through the IonQ dashboard. Users need to set their IONQ_APIKEY environment variable to this value; here are two ways to do it:\n\nin your terminal (export IONQ_APIKEY=&lt;value&gt;)\nor, in your Python script (os.environ['IONQ_APIKEY'] = &lt;value&gt;)\n\nHere’s an example of what it could look like for you (make sure you use a valid key, or you’ll get an “unauthorized” error :) )\n\nimport os\nos.environ[\"IONQ_APIKEY\"] = '2T14z1YQEzMLCwuYM110oXPDT2h850E4'\n\n\n\n3.2 Instantiate the connection object\nThe IonQConnection class encapsulates a collection of wrappers to the IonQ REST API. Internally, it stores information about the endpoint and the authorization header, containing your identification token. This class only is instantiated succesfully if your ID token has been set properly, otherwise you’ll get an error.\nMore generally speaking, all calls to the REST API are checked for errors, and would return the IonQ error message corresponding to the unsuccessful request.\n\nfrom tangelo.linq.qpu_connection import IonQConnection\n\nionq_connection = IonQConnection()\n\n\n\n\n\n\n3.3 Submit and manage jobs, and additional features\nHere we detail a number of features available using the IonQ portal.\n\nBackend info\nThe get_backend_info method returns some information about all the devices listed on IonQ’s platform. Tangelo currently returns this info inside a pandas.DataFrame object, to help with visualization.\n\nres = ionq_connection.get_backend_info()\nres # to display the dataframe neatly in this notebook\n\n\n\n\n\n\n\n\nbackend\nqubits\nstatus\nlast updated\naverage queue time\ncharacterization_url\n\n\n\n\n0\nqpu.harmony\n11\navailable\n2022-07-29 06:16:04\n735\nNone\n\n\n1\nsimulator\n19\navailable\n2022-07-29 06:16:04\n0\nNone\n\n\n2\nqpu.s11\n11\navailable\n2022-07-29 06:16:04\n735\n/characterizations/e8d7ac98-b7c2-443c-9eb8-105...\n\n\n\n\n\n\n\nThis information can help users to filter or sort devices according to their needs. For example, filtering out devices who do not have enough qubits for the target experiment, as well as the unavailable devices.\nWe can also retrieve “characterizations”: a snapshot of the IonQ platform’s performance at a moment in time. We can use the get_characterization method with either a backend string (ex: qpu.harmony or simulator) or a characterization url, if available (see dataframe above).\n\ncharac_dict = ionq_connection.get_characterization('qpu.s11')\nprint(charac_dict['fidelity'])\nprint(charac_dict['timing'])\n\n{'1q': {'mean': 0.9979}, '2q': {'mean': 0.961}, 'spam': {'mean': 0.99752}}\n{'t1': 10000, 't2': 0.2, '1q': 1e-05, '2q': 0.0002, 'readout': 0.00013, 'reset': 2e-05}\n\n\nThis information can help users having a better understanding of the capabilities of a device, and anticipate its performance on their usecases. Please check IonQ’s documentation to confirm what these quantities mean, and the units in which they are expressed in.\n\n\nJob submission\nSubmit a job with the job_submit method. It returns a job ID if submission was successful.\nAt the time of writing, this method takes input arguments that need to be provided by the user:\n\nthe target backend (strings provided by IonQ to refer to their simulators or QPUs)\nthe quantum circuit (in Tangelo format)\nthe number of shots required\na name for your job\nany other option as key arguments (see source code and IonQ documentation)\n\nAssuming a valid API key, we here submit a simple job targeting their statevector simulator. The status of the job may be in various states (queued, ready, running …).\n\njob_id = ionq_connection.job_submit('simulator', circ1, 100, 'test_json_job')\n\nJob submission  ID :: dfb38687-8c70-4b40-833d-c6166a902efe   status :: ready\n\n\n\n\nJob history and job info\nUsers can access their job history and info through the job_get_history and job_status methods, shown as below. But IonQ also provides an online dashboard, which may be more convenient to you.\nDepending on the timing of your REST requests, the job info may differ widely, from a failed job to a completed job with results included.\n\njob_status = ionq_connection.job_status(job_id)\nprint(job_status)\n\nJob info    ID:: dfb38687-8c70-4b40-833d-c6166a902efe    status :: completed \n{'status': 'completed', 'name': 'test_json_job', 'target': 'simulator', 'predicted_execution_time': 4, 'execution_time': 19, 'id': 'dfb38687-8c70-4b40-833d-c6166a902efe', 'qubits': 2, 'type': 'circuit', 'request': 1659075527, 'start': 1659075529, 'response': 1659075529, 'gate_counts': {'1q': 2}, 'data': {'histogram': {'2': 0.5, '3': 0.5}, 'registers': None}}\n\n\nThe output of job_get_history should at least feature the job we just submitted, and can also show a number of previous jobs run under your account. The output is a pandas dataframe, in order to facilitate parsing of information:\n\njob_history = ionq_connection.job_get_history()\njob_history[:5] # Here we only display info of the last 5 jobs run\n\n\n\n\n\n\n\n\nid\nstatus\ntarget\n\n\n\n\n0\ndfb38687-8c70-4b40-833d-c6166a902efe\ncompleted\nsimulator\n\n\n1\nb486e66a-2ae2-4275-8c9e-015a751dcbbe\ncompleted\nsimulator\n\n\n2\n5dea41e0-ce02-4193-8e50-e48fc0cd0c22\ncanceled\nqpu.harmony\n\n\n3\n34cc2763-f617-427a-8b3a-621086946a3b\ncompleted\nqpu.harmony\n\n\n4\n777237b4-79e8-44d0-8ac6-762f24864e7a\ncompleted\nsimulator\n\n\n\n\n\n\n\n\n\nJob results\nThe method job_results provides a wrapper to a blocking call, querying for the state of the target job at regular intervals, attempting to retrieve the results. If the job has successfully completed, this method returns a dictionary with bitstring keys (ex: 01, 11…)\nIonQ raw results use a “most-significant qubit first” representation, encoded as an integer, but Tangelo returns them as a bitstring in least-significant order (e.g we read left-to-right), to stay consistant with its own format and what is common across other cloud services.\nFor our example circuit, IonQ’s raw results would return {'2': 0.5, '3': 0.5} with an exact simulator. - 2 is ‘10’ in binary, indicating \\(q_0\\) mesured in state \\(|0\\rangle\\), and \\(q_1\\) in state \\(|1\\rangle\\) - 3 is ‘11’ in binary, indicating \\(q_0\\) mesured in state \\(|1\\rangle\\), and \\(q_1\\) in state \\(|1\\rangle\\)\nTangelo returns {'01': 0.5, '11': 0.5}.\n\nresults = ionq_connection.job_results(job_id)\nprint(results)\n\nJob info    ID:: dfb38687-8c70-4b40-833d-c6166a902efe    status :: completed \n{'01': 0.5, '11': 0.5}\n\n\n\n\nJob cancel / delete\nA wrapper called job_cancel provides a method to cancel before execution (if the job hasn’t run yet), or delete a job from the history. The cell below cancels / deletes the previously-submitted job: it therefore should not appear in the history anymore.\n\nionq_connection.job_cancel(job_id)\njob_history = ionq_connection.job_get_history()\njob_history\n\nJob cancel  ID :: dfb38687-8c70-4b40-833d-c6166a902efe   status :: deleted \n\n\n\n\n\n\n\n\n\nid\nstatus\ntarget\n\n\n\n\n0\nb486e66a-2ae2-4275-8c9e-015a751dcbbe\ncompleted\nsimulator\n\n\n1\n5dea41e0-ce02-4193-8e50-e48fc0cd0c22\ncanceled\nqpu.harmony\n\n\n2\n34cc2763-f617-427a-8b3a-621086946a3b\ncompleted\nqpu.harmony\n\n\n3\n777237b4-79e8-44d0-8ac6-762f24864e7a\ncompleted\nsimulator\n\n\n4\n9da8401b-5334-4358-ab3f-ddcd3e2f1ff4\ncompleted\nsimulator\n\n\n5\n9dd67d5f-aa29-46fb-a707-1858d022aacc\ncompleted\nsimulator\n\n\n6\n45e33c7e-33bd-43d6-aef3-87b78e7bdd77\ncompleted\nsimulator\n\n\n7\nbe130388-8daf-49dd-8e17-5b4c5274d69f\ncompleted\nsimulator\n\n\n8\n2c3526c0-44d4-4573-9bc1-c39a5c0135ae\ncompleted\nsimulator\n\n\n9\n373f3175-e7be-48cd-bf47-ac5e331a0eb0\ncompleted\nsimulator\n\n\n10\nb567e71c-fa20-4fb9-9ce9-62521de7a1ec\ncompleted\nsimulator\n\n\n11\nb1743e6d-359c-4175-bf56-99b8662fdcaf\ncompleted\nsimulator\n\n\n12\nf9865e17-25d8-4d84-b8f8-dc31e07a8fae\ncompleted\nsimulator\n\n\n13\ne54a5d12-65e4-4fef-8774-68584ccad94c\ncompleted\nsimulator\n\n\n14\nbe0c8bc7-5539-4e4f-b12c-5370a525076d\ncompleted\nsimulator"
  },
  {
    "objectID": "examples/workflow_basics/2.qpu_connection.html#azure-quantum",
    "href": "examples/workflow_basics/2.qpu_connection.html#azure-quantum",
    "title": "Connecting to quantum services with Tangelo",
    "section": "4. Azure Quantum ",
    "text": "4. Azure Quantum \nA work in progress ! Though this package does not currently provide a way to directly submit jobs through Microsoft’s Azure Quantum cloud services, the tangelo.linq module can parse an abstract circuit and generate Q# code that can be written to file, or other of the formats supported by Azure Quantum (cirq, qiskit, IonQ…). Check out their documentation for the most reliable information.\nSome users have successfully submitted experiments to Azure Quantum by simply translating their Tangelo circuit into the desired format and adding measurement gates at the end of their circuit.\nOur generated Q# code is compatible with both the local QDK simulator (good for testing before submitting to an actual QPU) or by Azure Quantum. Submission through Azure Quantum will require the user to have an account on Azure, install the local CLI and Python dependencies. For an example of how one can use this package to first generate circuits, and then submit jobs through Azure quantum, please look into the example/qsharp folder of this package.\nIn the future, we intend to provide a connection object for Azure Quantum as well. Let us know if you would like us to prioritize this feature, or even help us implement it faster by contributing."
  },
  {
    "objectID": "examples/workflow_basics/1.the_basics.html",
    "href": "examples/workflow_basics/1.the_basics.html",
    "title": "Linq: the basics",
    "section": "",
    "text": "Open In Colab\nlinq is a submodule of tangelo that helps you connect to and leverage the features of various backends, may they be simulators or QPUs. This notebook talks about the abstract format used in Tangelo to represent a quantum circuit, and how we can then convert it to other formats or objects used in popular packages such as Braket, Qulacs, Qiskit, Cirq (…) and leverage the different features and performance these platforms offer.\nWrite code once, run it on various platforms with minimal effort: no need to rewrite everything in order to port your project to a different hardware, or generate what you need for a publication. It also means that whatever new method or code you develop can just run on all the compute backends available."
  },
  {
    "objectID": "examples/workflow_basics/1.the_basics.html#table-of-contents",
    "href": "examples/workflow_basics/1.the_basics.html#table-of-contents",
    "title": "Linq: the basics",
    "section": "Table of contents",
    "text": "Table of contents\n\n1. Abstract gate class\n2. Abstract circuit class\n3. Translator module\n4. Backends\n5. Beyond that\n\nThe scope of this submodule goes beyond this, but this notebook only focuses on the basics: the abstract gate and circuit classes, as well as the translator and simulator modules. This should get you started with simulating a variety of quantum circuits, as well as computing expectation values of operators."
  },
  {
    "objectID": "examples/workflow_basics/1.the_basics.html#requirements",
    "href": "examples/workflow_basics/1.the_basics.html#requirements",
    "title": "Linq: the basics",
    "section": "Requirements",
    "text": "Requirements\nIn order to run the contents of this notebook, you need to have tangelo installed in your python environment. Some cells may require that a specific backend (such as qiskit, qulacs…) is installed to run. Please have a look at their installation instructions, if needed. Executing the cell below provides a quick way of installing the requirements of this notebook.\n\n# Installation of tangelo if not already installed.\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop  --quiet\n    !pip install qiskit qulacs amazon-braket-sdk --quiet"
  },
  {
    "objectID": "examples/workflow_basics/1.the_basics.html#abstract-gate-class",
    "href": "examples/workflow_basics/1.the_basics.html#abstract-gate-class",
    "title": "Linq: the basics",
    "section": "1. Abstract gate class ",
    "text": "1. Abstract gate class \nThe linq submodule aims at providing users a straightforward and transparent way to represent a quantum gate operation, and by extension a quantum circuit. It represents a quantum gate operation acting on qubits as a simple python object. An abstract gate has:\n\nA name\ntarget qubit(s) (only one qubit supported at the moment)\ncontrol qubit(s) (only one supported at the moment)\nparameter(s) (only one supported at the moment)\na tag saying whether or not it is “variational”, to keep track of gates with variational parameters\n\nAn abstract gate is pretty much just a dictionary, with the fields above. Some gates do not need all these fields to be populated in order to be clearly defined: not all of them require control qubits or parameters for instance.\nLet’s have a look at how someone can define a gate and print it. You can see below that at instantiation, you can skip some fields or omit their name if the call is non-ambiguous. We always start with the name and the index of the target qubit, as all gates have them.\nNote: qubit indexing starts at 0.\n\nfrom tangelo.linq import Gate\n\n# Create a Hadamard gate acting on qubit 2\nH_gate = Gate(\"H\", 2)\n# Create a CNOT gate with control qubit 0 and target qubit 1\nCNOT_gate = Gate(\"CNOT\", target=1, control=0)\n# Create a parameterized rotation on qubit 1 with angle 2 radians\nRX_gate = Gate(\"RX\", 1, parameter=2.)\n# Create a parameterized rotation on qubit 1 , with an undefined angle, that will be tagged as variational\nRZ_gate = Gate(\"RZ\", 1, parameter=\"an expression\", is_variational=True)\n# Create a potato gate, acting on qubit 3.\nPOTATO_gate = Gate(\"POTATO\", 3)\n\nfor gate in [H_gate, CNOT_gate, RX_gate, RZ_gate, POTATO_gate]:\n    print(gate)\n\nH         target : [2]   \nCNOT      target : [1]   control : [0]   \nRX        target : [1]   parameter : 2.0\nRZ        target : [1]   parameter : an expression   (variational)\nPOTATO    target : [3]   \n\n\nWhat’s that, you don’t know about the POTATO gate?! Oof. Your imposter syndrom must be in full swing right now. It’s ok. No one has noticed yet. Smile. Take another sip of that coffee. Keep reading.\nThis abstract gate data structure simply stores information, and does not need to fully specify a valid gate operation that corresponds to, let’s say, a very well-defined matrix representation of the operator. As you can see, the parameter for our Rz gate can be anything, and the actual existence of the POTATO gate is questionable. The gate set supported, the conventions on phases and parameters, are all backend-dependent. Therefore, the fields of your abstract gate only really need to make sense later on, once you have picked a target backend (qiskit, qulacs…).\nNote: The controlled gates, such as CNOT, expect that you first pass the target qubits and then the control ones, which may be counter-intuitive and trip you up."
  },
  {
    "objectID": "examples/workflow_basics/1.the_basics.html#abstract-circuit-class",
    "href": "examples/workflow_basics/1.the_basics.html#abstract-circuit-class",
    "title": "Linq: the basics",
    "section": "2. Abstract circuit class ",
    "text": "2. Abstract circuit class \nAn abstract circuit can be simply seen as a list of abstract gates. This class has a few methods to help users know at a glance how many gates or qubits are in a quantum circuit, or if it contains gates tagged as variational for example. Other convenience methods to compute the depth of the circuit, identify unentangled registers or qubits that can be simulated separately, etc, are available.\nUsers can instantiate abstract circuits by directly passing a list of gates, or using the add_gate method on an existing abstract circuit object. It is also possible to concatenate abstract circuits in a pythonic way using the \\(+\\) or \\(*\\) operators: useful to build more complex circuits using simpler ones as building blocks. Circuits are iterable objects, which means that you can traverse them in order to traverse the underlying list of gates they’re made of.\nNote: It is more efficient to build circuits by using list comprehension and other python syntaxes to efficiently build a list of Gate objects, and then passing it to the Circuit class; rather than use add_gate or concatenate a lot of small Circuit objects with +.\nThe number of qubits required by your circuit is automatically computed, based on the highest qubit index appearing in your gates. It is however possible to enforce a fixed-sized for your quantum circuit, that goes beyond this number.\nWe’re all grown-ups, and technically you could perform surgery on your quantum circuit, to directly modify the fields of some of its gates. This can be useful for instance, to change the parameters used in “variational gates” (i.e gates tagged as variational) in the context of variational algorithms. Use responsibly.\n\nfrom tangelo.linq import Circuit\n\n# Here's a list of abstract gates\nmygates = [Gate(\"H\", 2), Gate(\"CNOT\", 1, control=0), Gate(\"CNOT\", target=2, control=1),\n           Gate(\"Y\", 0), Gate(\"RX\", 1, parameter=2.)]\n\n# Users can create empty circuit objects and use add_gate later on\ncircuit1 = Circuit()\nfor gate in mygates:\n    circuit1.add_gate(gate)\n    \n# Users can also directly instantiate a circuit with a list of gates (preferred)\ncircuit2 = Circuit(mygates)\n\n# It is possible to concatenate abstract circuit objects\ncircuit3 = Circuit(mygates) + Circuit([Gate(\"RZ\", 4, parameter=\"some angle\", is_variational=True)])\n\n# Printing a circuit prints gate list\nprint(circuit3)\n\n# It is possible to examine properties of an abstract circuit directly\nprint(f\"The number of gates contained in circuit3 is {circuit3.size}\")\nprint(f\"The number of qubits in circuit3 is {circuit3.width}\")\nprint(f\"Does circuit have gates tagged as variational? {circuit3.is_variational}\")\n\n# Even to have an overview of the type of gates it contains, and how many of them\nprint(f\"Gate counts: {circuit3.counts}\")\n\n# Dark magic: update the parameters of the first variational gate in the circuit\ncircuit3._variational_gates[0].parameter = 777.\nprint(f\"\\n{circuit3}\")\n\nCircuit object. Size 6 \n\nH         target : [2]   \nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nY         target : [0]   \nRX        target : [1]   parameter : 2.0\nRZ        target : [4]   parameter : some angle  (variational)\n\nThe number of gates contained in circuit3 is 6\nThe number of qubits in circuit3 is 5\nDoes circuit have gates tagged as variational? True\nGate counts: {'H': 1, 'CNOT': 2, 'Y': 1, 'RX': 1, 'RZ': 1}\n\nCircuit object. Size 6 \n\nH         target : [2]   \nCNOT      target : [1]   control : [0]   \nCNOT      target : [2]   control : [1]   \nY         target : [0]   \nRX        target : [1]   parameter : 2.0\nRZ        target : [4]   parameter : 777.0   (variational)\n\n\n\nThe abstract circuit can therefore be thought as a list of abstract gates, with some self-awareness: it knows what gate objects it contains, yet does not know what operation they actually implement on a quantum state. The latter is deferred to the translation step, which is different for each backend.\nIn the future, we may provide other features to optimize or analyze abstract circuits. The advantage of doing so means that whatever benefit come out of it, it will carry to any of the target backends.\nNote: It is implied that qubits are measured in the computational basis at the end of the circuit. Users should NOT explicitly perform final measurements using the MEASURE instruction, which is designed to handle mid-circuit measurements, indicating that we intend to simulate a mixed state. As mixed states cannot be represented by statevectors, they are simulated differently and require to draw shots / samples, which may increase simulation time considerably.\n\nHelper functions to build circuits\nThis package provides helper functions allowing users to put together more general circuits easily, without the need to reinvent the wheel when it comes to common patterns. In the future, users could contribute functions generating useful for benchmarking reasons, building blocks to form larger circuits, or well-known quantum circuits such as the QFT, for instance. These could be contributed as helper functions, or available in a separate folder aiming to gather a collection a circuits for different purposes. If you need to do something that seems fairly common, take a quick look around: you may have all the pieces already (or have the opportunity to design and contribute the pieces you need!).\nNote: Most functions do not yield a Circuit object, but a list of gates (see the convention used at the end of the function name). For performance reasons, it is better to concatenate a list of gates and then turn it into a Circuit, than to turn smaller lists of gates into Circuit objects and then use the + operator to concatenate them. This will not be an issue unless you are for example running an algorithm that requires a circuit to be rebuilt frequently and requiring many Circuit objects to be concatenated.\nBelow, an example of how we can design a function to easily produce Circuit objects implementing a parameter sweep, working for any pauli measurement basis, which is not uncommon in hardware experiments: just a combination of loops and helper functions.\nThe measurement basis is assumed to be passed as a list of 2-tuples of the form (i, K) where i is an integer denoting the qubit index and K a letter (string) that can take the value ‘I’, ‘X’, ‘Y’, or ‘Z’; which also happens to be the format encountered while traversing a QubitOperator object in Openfermion.\n\nfrom tangelo.linq.helpers.circuits import measurement_basis_gates, pauli_string_to_of\n\ndef theta_sweep(theta, m_basis):\n    \"\"\" A single-parameter circuit, with change of basis at the end if needed \"\"\"\n    my_gates = [Gate('CNOT', target=0, control=1), \n                Gate('RX', target=1, parameter=theta), \n                Gate('CNOT', target=0, control=1)]\n    my_gates += measurement_basis_gates(pauli_string_to_of(m_basis))\n    return Circuit(my_gates)\n\n# It is easy with linq to move between string or Openfermion-style representations for Pauli words\nfor theta, m_basis in [(0.1, 'ZZ'), (0.2, 'ZZ'), (0.3, 'XY')]:\n    c = theta_sweep(theta, m_basis)\n    print(f\"{c}\\n\")\n\nCircuit object. Size 3 \n\nCNOT      target : [0]   control : [1]   \nRX        target : [1]   parameter : 0.1\nCNOT      target : [0]   control : [1]   \n\n\nCircuit object. Size 3 \n\nCNOT      target : [0]   control : [1]   \nRX        target : [1]   parameter : 0.2\nCNOT      target : [0]   control : [1]   \n\n\nCircuit object. Size 5 \n\nCNOT      target : [0]   control : [1]   \nRX        target : [1]   parameter : 0.3\nCNOT      target : [0]   control : [1]   \nRY        target : [0]   parameter : -1.5707963267948966\nRX        target : [1]   parameter : 1.5707963267948966"
  },
  {
    "objectID": "examples/workflow_basics/1.the_basics.html#translator-module",
    "href": "examples/workflow_basics/1.the_basics.html#translator-module",
    "title": "Linq: the basics",
    "section": "3. Translator module ",
    "text": "3. Translator module \nIn order to make use of the various compute backends available, the translator module provides users with functions that can translate from, and sometimes to, the abstract circuit format. Users can therefore import or export their quantum circuits to work with their favorite framework, using the umbrella function translate_circuit with the desired target and source parameters.\nA translate_operator function is also available, for doing the equivalent with qubit / Pauli operators.\nThe translator module defines how the content of your abstract gates should be parsed, what gates are supported, the convention used, and is subject to error-checking: the contents must make sense for the target backend, otherwise you will get errors. At that point, your gates must be supported and their parameters correct.\nYou can find in the translator module the dictionaries telling you what backends are supported, and what gates they currently support. As you can see, the exceptional POTATO gate is not yet supported by any available backend. You’d most certainly get an error if you tried to translate an abstract circuit containing such a gate into a given backend’s format, unless a major breakthrough in toaster-oven technology happens and we integrate this disruptive compute platform.\n\nfrom tangelo.linq import get_supported_gates\n\nfor backend, gates in get_supported_gates().items():\n    print(f'{backend} : {gates}')\n\nprojectq : ['CNOT', 'H', 'MEASURE', 'PHASE', 'RX', 'RY', 'RZ', 'S', 'T', 'X', 'Y', 'Z']\nionq : ['CNOT', 'CPHASE', 'CRX', 'CRY', 'CRZ', 'CX', 'CY', 'CZ', 'H', 'PHASE', 'RX', 'RY', 'RZ', 'S', 'SWAP', 'T', 'X', 'XX', 'Y', 'Z']\nqdk : ['CH', 'CNOT', 'CPHASE', 'CRX', 'CRY', 'CRZ', 'CS', 'CSWAP', 'CT', 'CX', 'CY', 'CZ', 'H', 'MEASURE', 'PHASE', 'RX', 'RY', 'RZ', 'S', 'SWAP', 'T', 'X', 'Y', 'Z']\nopenqasm : ['CNOT', 'CPHASE', 'CRZ', 'CSWAP', 'CY', 'CZ', 'H', 'MEASURE', 'PHASE', 'RX', 'RY', 'RZ', 'S', 'SWAP', 'T', 'X', 'Y', 'Z']\nqulacs : ['CH', 'CNOT', 'CPHASE', 'CRX', 'CRY', 'CRZ', 'CSWAP', 'CX', 'CY', 'CZ', 'H', 'MEASURE', 'PHASE', 'RX', 'RY', 'RZ', 'S', 'SWAP', 'T', 'X', 'XX', 'Y', 'Z']\nqiskit : ['CH', 'CNOT', 'CPHASE', 'CRX', 'CRY', 'CRZ', 'CSWAP', 'CX', 'CY', 'CZ', 'H', 'MEASURE', 'PHASE', 'RX', 'RY', 'RZ', 'S', 'SWAP', 'T', 'X', 'XX', 'Y', 'Z']\ncirq : ['CH', 'CNOT', 'CPHASE', 'CRX', 'CRY', 'CRZ', 'CSWAP', 'CX', 'CY', 'CZ', 'H', 'MEASURE', 'PHASE', 'RX', 'RY', 'RZ', 'S', 'SWAP', 'T', 'X', 'XX', 'Y', 'Z']\nbraket : ['CNOT', 'CPHASE', 'CRZ', 'CSWAP', 'CX', 'CY', 'CZ', 'H', 'PHASE', 'RX', 'RY', 'RZ', 'S', 'SWAP', 'T', 'X', 'XX', 'Y', 'Z']\n\n\nThe result of the translation step is specific to the given backend: some will return a quantum circuit object, some will return a string of instructions in their specific syntax & language, some a serialized JSON object…\nNote: Do not use the MEASURE Gate in your noiseless/shotless simulations, unless your circuit requires a mid-circuit measurement. This gate is intended for the simulation of mixed states.\nNote: Backends often have different conventions, operations may differ up to a phase or sign convention for parametrized gates for instance. Since the outcome of your simulation should not depend on the target backend, the translation step enforces a given convention, detailed in the documentation. In particular, this implies that the native circuit written for a given backend may not be equivalent to the same one written in abstract format, and then translated to this backend. Be mindful of that as you try to take some code written for a given backend, to port it to tangelo.\nBelow, we show how translate_circuit returns backend-specific objects, all with their usual built-in functionalities. See how the print function behaves differently for each of them for instance, and remember that you can use their built-in methods to accomplish many things (ex: after translating your circuit into a Qiskit.QuantumCircuit object, you can use the draw method to export it in a nice format: https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.draw.html).\nHere are a few examples. Some cells may fail depending on what packages you have installed.\n\nfrom tangelo.linq import translate_circuit\n\n# Using the Tangelo format as an intermediate, many combinations of source and target\n# formats are available. \ncirc3_projectq = translate_circuit(circuit3, target=\"projectq\", source=\"tangelo\")\nprint(f\"{circ3_projectq}\\n\")\n\n# We now use the shorthand for translating a circuit \n# implicitly from tangelo format, to something else.\ncirc3_projectq = translate_circuit(circuit3, \"ionq\")\nprint(f\"{circ3_projectq}\\n\")\n\ncirc3_projectq = translate_circuit(circuit3, \"qdk\")\nprint(f\"{circ3_projectq}\\n\")\n\nAllocate | Qureg[0]\nAllocate | Qureg[1]\nAllocate | Qureg[2]\nAllocate | Qureg[3]\nAllocate | Qureg[4]\nH | Qureg[2]\nCX | ( Qureg[0], Qureg[1] )\nCX | ( Qureg[1], Qureg[2] )\nY | Qureg[0]\nRx(2.0) | Qureg[1]\nRz(777.0) | Qureg[4]\n\n\n{'qubits': 5, 'circuit': [{'gate': 'h', 'targets': [2]}, {'gate': 'x', 'targets': [1], 'controls': [0]}, {'gate': 'x', 'targets': [2], 'controls': [1]}, {'gate': 'y', 'targets': [0]}, {'gate': 'rx', 'targets': [1], 'rotation': 2.0}, {'gate': 'rz', 'targets': [4], 'rotation': 777.0}]}\n\nnamespace MyNamespace\n{\n    open Microsoft.Quantum.Intrinsic;\n    open Microsoft.Quantum.Canon;\n    open Microsoft.Quantum.Arrays;\n    open Microsoft.Quantum.Extensions.Convert;\n    open Microsoft.Quantum.Characterization;\n    open Microsoft.Quantum.Measurement;\n\n\n    /// # Summary:\n    ///         Returns the estimated probabilities associated to the different measurements\n    ///         after applying the state-preparation provided by the user at runtime to the quantum state\n    operation EstimateFrequencies(nQubits : Int, nShots : Int) : Double[]\n    {\n        mutable frequencies = new Double[2^nQubits];\n\n        for (iShot in 1..nShots)\n        {\n            // Apply Q# operation (state preparation to measurements) to qubit register of size nQubits\n            mutable results = MyQsharpOperation();\n\n            // Update frequencies based on sample value\n            mutable index = 0;\n            for (iQubit in nQubits-1..-1..0)\n            {\n                if (results[iQubit] == One) {set index = index + 2^iQubit;}\n            }\n\n            set frequencies w/= index &lt;- frequencies[index] + 1.0;\n        }\n\n        // Rescale to obtain frequencies observed\n        for (iFreq in 0..2^nQubits-1)\n        {\n            set frequencies w/= iFreq &lt;- frequencies[iFreq] / ToDouble(nShots);\n        }\n\n        return frequencies;\n    }\n\n    /// INSERT TRANSLATED CIRCUIT HERE\n@EntryPoint()\noperation MyQsharpOperation() : Result[] {\n    mutable c = new Result[5];\n    using (qreg = Qubit[5]) {\n        H(qreg[2]);\n        CNOT(qreg[0], qreg[1]);\n        CNOT(qreg[1], qreg[2]);\n        Y(qreg[0]);\n        Rx(2.0, qreg[1]);\n        Rz(777.0, qreg[4]);\n\n        return ForEach(MResetZ, qreg);\n    }\n}\n\n}\n\n\n\n\n\ncirc3_qiskit = translate_circuit(circuit3, \"qiskit\")\nprint(f\"{circ3_qiskit}\\n\")\n\ncirc3_openqasm = translate_circuit(circuit3, \"openqasm\")\nprint(f\"{circ3_openqasm}\\n\")\n\n                ┌───┐         \nq_0: ─────■─────┤ Y ├─────────\n        ┌─┴─┐   └───┘┌───────┐\nq_1: ───┤ X ├─────■──┤ Rx(2) ├\n        ├───┤   ┌─┴─┐└───────┘\nq_2: ───┤ H ├───┤ X ├─────────\n        └───┘   └───┘         \nq_3: ─────────────────────────\n     ┌─────────┐              \nq_4: ┤ Rz(777) ├──────────────\n     └─────────┘              \nc_0: ═════════════════════════\n                              \nc_1: ═════════════════════════\n                              \nc_2: ═════════════════════════\n                              \nc_3: ═════════════════════════\n                              \nc_4: ═════════════════════════\n                              \n\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q[5];\ncreg c[5];\nh q[2];\ncx q[0],q[1];\ncx q[1],q[2];\ny q[0];\nrx(2) q[1];\nrz(777) q[4];\n\n\n\n\n\ncirc3_qulacs = translate_circuit(circuit3, \"qulacs\")\nprint(f\"{circ3_qulacs}\\n\")\n\n*** Quantum Circuit Info ***\n# of qubit: 5\n# of step : 3\n# of gate : 6\n# of 1 qubit gate: 4\n# of 2 qubit gate: 2\nClifford  : no\nGaussian  : no\n\n\n\n\n\n\ncirc3_braket = translate_circuit(circuit3, \"braket\")\nprint(f\"{circ3_braket}\")\n\nT  : |    0     |1|   2    |\n                            \nq0 : -C----------Y----------\n      |                     \nq1 : -X----------C-Rx(2.00)-\n                 |          \nq2 : -H----------X----------\n                            \nq4 : -Rz(777.00)------------\n\nT  : |    0     |1|   2    |\n\n\n\ncirc3_cirq = translate_circuit(circuit3, \"cirq\")\nprint(f\"{circ3_cirq}\")\n\n0: ───I───@─────────────Y────────────────\n          │\n1: ───I───X─────────────@───Rx(0.637π)───\n                        │\n2: ───I───H─────────────X────────────────\n\n3: ───I──────────────────────────────────\n\n4: ───I───Rz(-0.673π)────────────────────\n\n\nNote: We provide limited support for translation from a backend-specific format to the abstract format, for convenience. Some of these formats are OpenQASM or projectq.\n\nSaving, loading and sharing quantum circuits\nYou may need to save, load or share quantum circuits or operators with collaborators, which may be used to working on other platforms.\nA first suggestion is to use the OpenQASM format, as it is a rather common human-readable format, supported by most framework. Tangelo proposes convertion to OPENQASM 2.0, and limited reverse convertion from a subset of OpenQASM to Tangelo format.\nOtherwise, python packages such as pickle or json may come in handy to export compatible non-string objects, but can be a bit tricky if version numbers of dependencies do not match."
  },
  {
    "objectID": "examples/workflow_basics/1.the_basics.html#backends",
    "href": "examples/workflow_basics/1.the_basics.html#backends",
    "title": "Linq: the basics",
    "section": "4. Backends ",
    "text": "4. Backends \nThe get_backend function provides a common interface to all supported compute backends, allowing users to focus on the high-level details of their simulation (number of shots, noise model…) without writing low-level code for the target backend. It returns an object inheriting from the abstract Backend class, which can refer to a simulator or an actual QPU. There are built-in backends for various simulators (qiskit, qulacs, cirq…) and it’s possible to define your own backend.\nThe backend object handles all translation and quantum circuit simulation steps, directly returning the results to the user. Some post-processing methods, such as the computation of the expectation value of a qubit operator, are available as well.\nNot all backends provide the same features: some of them do not give access to a state-vector representation of the quantum state, or do not support noisy simulation for instance. Just like the translator module, the simulator module provides a data-structure containing the currently supported features and characteristics of some backends.\n\nfrom tangelo.linq import get_backend, backend_info\n\nfor backend, info in backend_info.items():\n    print(f'{backend} : {info}')\n\nqdk : {'statevector_available': False, 'statevector_order': None, 'noisy_simulation': False}\nqiskit : {'statevector_available': True, 'statevector_order': 'msq_first', 'noisy_simulation': True}\nqulacs : {'statevector_available': True, 'statevector_order': 'msq_first', 'noisy_simulation': True}\ncirq : {'statevector_available': True, 'statevector_order': 'lsq_first', 'noisy_simulation': True}\n\n\n\nNoiseless simulation\nIn the example below, we show how get_backend allows for switching backends easily, to perform quantum circuit simulation. We first show how to perform noiseless simulation with access to the exact amplitudes through the state-vector representation of the quantum state, and then show how a noiseless shot-based simulation can be performed.\nThe simulate method returns a 2-tuple:\n\nthe first entry is a sparse histogram of frequencies associated to the different observed states, in least-significant qubit first order (e.g ‘01’ means qubit 0 (resp 1) measured in \\(|0&gt;\\) (resp \\(|1&gt;\\)) state). That is, it is to be read “left-to-right” in order to map each qubit to the basis state it was observed in.\nthe second entry contains the state-vector representation of the quantum state, if available on the target backend and if the user requires it using the return_statevector optional parameter. Watch out for the order of the amplitudes in the state vector: the backend_info data-structure described above helps with understanding how they map to the different basis states.\n\nThe simulate method can also take the optional parameter initial_statevector, which allows to start the system in a given state and “resume” a simulation. It can in particular be useful to avoid resimulating something again and again, when the result is already known and could just be loaded instead. This is one of the perks of statevector simulators !\n\n# Create a circuit object in abstract format\nc = Circuit([Gate(\"RX\", 0, parameter=2.), Gate(\"RY\", 1, parameter=-1.)])\n\n# Qiskit noiseless simulator (no shot count or noise model specified)\nsim_qiskit = get_backend(target=\"qiskit\")\nprint(sim_qiskit.simulate(c))\n\n# cirq noiseless simulator (no shot count or noise model specified)\nsim_cirq = get_backend(target=\"cirq\")\nprint(sim_cirq.simulate(c))\n\n# Qulacs noiseless simulator (no shot count or noise model specified)\n# Ask to return the state vector as well (exposes the complex amplitudes)\nsim_qulacs = get_backend(target=\"qulacs\")\nprint(f\"\\n{sim_qulacs.simulate(c, return_statevector=True)}\")\n\n({'00': 0.2248275934887112, '10': 0.5453235594453588, '01': 0.06709898823771769, '11': 0.16274985882821247}, None)\n({'00': 0.2248275934887112, '01': 0.06709898823771769, '10': 0.5453235594453588, '11': 0.16274985882821247}, None)\n\n({'00': 0.2248275934887112, '10': 0.5453235594453588, '01': 0.06709898823771769, '11': 0.16274985882821247}, array([ 0.47415988+0.j        ,  0.        -0.73846026j,\n       -0.25903472+0.j        ,  0.        +0.40342268j]))\n\n\nNote: If you do not specify any target when calling get_backend, the implementation defaults to either a qulacs simulator if the package found in your environment, or a cirq simulator otherwise.\nNote: The native equivalents of this abstract circuit in Qulacs and Qiskit would not return the same results. This is due to the fact that \\(Rx_{qiskit}(\\theta) = Rx_{qulacs}(-\\theta)\\) (e.g sign convention), which is also true for the \\(Ry\\) and \\(Rz\\) gates. This package however ensures consistent behavior across backends, by enforcing a specifying convention in the translator. For more information about conventions used, please refer to the documentation or check out the source code of the translator module.\nIn the above cell, we called get_backend without specifying a number of shots or a noise model, but it is possible to do so. You can tweak the behavior of the Backend object by modifying -some- of its attributes after it has been instantied. In particular:\n\nfreq_threshold is the threshold used to discard negligible frequencies from the histogram returned by the simulate method, in order to avoid returning \\(2^{n\\_qubits}\\) numbers and focus on the main observables.\nn_shots and noise_model can be changed after the class has been instantiated\n\nIn the cell below, we can see how instantiating a shot-based backend and increasing shot count yields results that are getting closer to the exact theoretical distribution.\n\n# Exact probabilities\nsim_qulacs = get_backend(target=\"cirq\")\nexact_freqs, _ = sim_qulacs.simulate(c)\nprint(exact_freqs)\n\n# Approximation with different number of shots (higher=more accurate)\nsim_qulacs_shots = get_backend(target=\"cirq\", n_shots=100)\nfreqs, _ = sim_qulacs_shots.simulate(c)\nprint(freqs)\n\nsim_qulacs_shots.n_shots=10**4\nfreqs, _ = sim_qulacs_shots.simulate(c)\nprint(freqs)\n\nsim_qulacs_shots.n_shots=10**6\nfreqs, _ = sim_qulacs_shots.simulate(c)\nprint(freqs)\n\n{'00': 0.2248275934887112, '01': 0.06709898823771769, '10': 0.5453235594453588, '11': 0.16274985882821247}\n{'10': 0.58, '00': 0.2, '01': 0.05, '11': 0.17}\n{'00': 0.2275, '11': 0.1665, '10': 0.5419, '01': 0.0641}\n{'10': 0.545223, '00': 0.224795, '11': 0.163024, '01': 0.066958}\n\n\n\n\nMixed states\nThe abstract circuit format provides a MEASURE instruction, supported by most compute backends, with the intent of simulating mixed states / mid-circuit measurements in the computational basis (e.g along the Z axis). As mixed states cannot be represented by a statevector, the statevector simulator backends default to simulating the quantum circuit with shots, in order to return a histogram of frequencies. Users thus must ensure the n_shots attribute of their Backend object has been set.\nSimulating a mixed state can be considerably slower than simulating a pure state (some backends are particularly not good at this). Including final measurements in your state-preparation circuit is not recommended, if you intend to use linq to simulate it.\n\n# This circuit prepares a Bell pair (superposition of states |00&gt; and |11&gt;), then measures and flips qubit 0.\n# Depending on the result of the measurement, the statevector describing the quantum state would be different.\ncircuit_mixed = Circuit([Gate(\"H\", 0), Gate(\"CNOT\", target=1, control=0), Gate(\"MEASURE\", 0), Gate(\"X\", 0)])\nsim = get_backend(target=\"cirq\", n_shots=10**5)\n\nfreqs, _ = sim.simulate(circuit_mixed)\nprint(freqs)\n\n{'01': 0.50089, '10': 0.49911}\n\n\nWe provide compute backends that are more appropriate to simulate mixed states, relying on density matrices for example.\n\n\nExpectation values\nThe get_expectation_valuemethod can be used to compute the expectation value of a qubit / Pauli operator with regards to a state-preparation circuit, and get_expectation_value_from_frequencies_oneterm can directly take a sparse histogram of frequencies obtained by executing or simulating a quantum circuit on a backend (which could be resulting from a QPU experiment).\nNote: For now, users are to manually loop over terms and corresponding histograms if they intend to compute the expectation value of a linear combination of operators.\n\n# Openfermion operators can be used\nfrom openfermion.ops import QubitOperator\nop = 1.0 * QubitOperator('Z0')\n\n# Option1: Directly through a simulator backend, providing the state-preparation circuit\nsim = get_backend(target=\"cirq\")\nexpval1 = sim.get_expectation_value(op, c)\nprint(expval1)\n\n# Option2: Assume quantum circuit simulation was performed separately (by this package or different services)\nfreqs, _ = sim.simulate(c)  # circuit c must be consistent with operator, regarding measurement along non-z axes\nterm, coef = tuple(op.terms.items())[0]  # This yields ((0, 'Z'),), 1.0\nexpval2 = coef * sim.get_expectation_value_from_frequencies_oneterm(term, freqs)\nprint(expval2)\n\n-0.4161468365471424\n-0.4161468365471424"
  },
  {
    "objectID": "examples/workflow_basics/1.the_basics.html#beyond-that",
    "href": "examples/workflow_basics/1.the_basics.html#beyond-that",
    "title": "Linq: the basics",
    "section": "Beyond that ",
    "text": "Beyond that \nThis notebook provided a general introduction to the linq submodule, which hopefully helped you getting started with quantum circuits in Tangelo. There are many other notebooks available that illustrate quantum algorithms using these data structures, or more advanced features of linq.\nWhat will you do with Tangelo ?"
  },
  {
    "objectID": "examples/workflow_basics/symbolic_simulator.html",
    "href": "examples/workflow_basics/symbolic_simulator.html",
    "title": "Performing symbolic simulation in Tangelo",
    "section": "",
    "text": "Tangelo has the capability of simulating a quantum circuit with symbolic simulation. The symbolic backend, based on SymPy, could be a great educational tool and play an important role in quantum computing research workflows. We illustrate this statement on three use cases.\n!pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet\nThe SymPy package is a python library for symbolic mathematics, able to perform algebraic operations on mathematical expressions. We show in this notebook some use cases where using symbolic simulation might be useful for quantum computing research purposes. But first, let us introduce how quantum computing experiments are modelled mathematically.\nLinear algebra is an essential tool for predicting quantum experiment outcomes. In quantum computing, the computer state is described by quantum dits (qudits), i.e. the unit of quantum information described by a superposition of \\(d\\) states. Customarily, quantum computing algorithms are constructed with quantum bits (qubits) in mind, that is to say the \\(d=2\\) case. A many-qubit state can be represented by either a vector of size \\(2^n\\) elements for a pure state, or a square matrix of size \\(2^n \\times 2^n\\) for a mixed state, where \\(n\\) is the number of qubits. Quantum operations (gates) are represented by unitary matrices of consistent size. Time evolution of a state is modeled mathematically by matrix multiplication with a given set of unitaries, each representing quantum gates. One can empirically set a single qubit into a superposition of states described by\n\\[\\alpha |0\\rangle + \\beta |1\\rangle\\]\nwhere \\(\\alpha, \\beta \\in \\mathbb{C}\\) and \\(\\alpha^{\\dagger}\\alpha + \\beta^{\\dagger}\\beta = 1\\). Analyzing the effect of \\(\\alpha\\) and \\(\\beta\\) of this qubit state on an entangled many-qubit system can be a valuable asset for research, as illustrated by the examples featured in this notebook. Quantum mechanics state that the probabilites of getting each basis state after measurement are proportional to the amplitudes (\\(\\alpha^{\\dagger} \\alpha\\) (resp. \\(\\beta^{\\dagger} \\beta\\)) for the \\(|0\\rangle\\) (resp. \\(|1\\rangle\\)) state). The products of the coefficient and its conjugate are what we get as probabilities when many measurements are simulated on the qubit.\nThe single-qubit example \\(\\alpha |0\\rangle + \\beta |1\\rangle\\) is tractable on pen and paper. It however becomes quickly cumbersome as the number of qubits increases and the system exhibits entanglement. Commonly, one who wishes to study the effect of the \\(\\alpha\\) and \\(\\beta\\) parameters has to repeat the simulation (on classical hardware, i.e. processors (CPUs) or graphical processing units (GPUs), etc) with different state prepations. Often, this state preparation process involves quantum gates that take parameters, such as an angle \\(\\theta\\), whose value therefore parameterizes \\(\\alpha\\) and \\(\\beta\\). By performing symbolic simulation, we can obtain an expression of the quantum state (histogram of probabilities or the state vector) that is function of such parameters. The expression can be evaluated and studied without the need to repeat the quantum circuit emulation, with tools such as algebra and calculus."
  },
  {
    "objectID": "examples/workflow_basics/symbolic_simulator.html#use-cases",
    "href": "examples/workflow_basics/symbolic_simulator.html#use-cases",
    "title": "Performing symbolic simulation in Tangelo",
    "section": "Use cases",
    "text": "Use cases\nIn this section, some use cases are summarized with goal-oriented discussions. The first one shows how one can analyze the output state after applying a parametrized unitary. The second one is showing the effect of a parameter on the qubit entanglement and the resulting measured eigenvalue. This example exhibits a “single-entangler” circuit, widely used in chemistry simulation ansatze to represent an electronic excitation. The third and last one displays an example where all the results can be revealed with a single calculation. This is shown with an amplitude amplification circuit, aiming at amplifying the measurement probability of a given state.\nIn the next cell, we gathered the execution of the imports, the variable definitions and the creation of the symbolic backend object. As a side note, one must be aware of the limited performance of this simulator, compared to the other ones present in Tangelo. It handles symbolic expressions instead of performing highly efficient calculations on floatting-point values. In practice, scaling to eight-qubit systems and beyond may incur long simulation times.\n\nfrom sympy import pi, Symbol\nfrom sympy.plotting.plot import plot\n\nfrom tangelo.linq import Gate, Circuit, get_backend\n\n# Define variables for the rotation gate angles used in the next cells\ntheta = Symbol(\"theta\", real=True)\nphi = Symbol(\"phi\", real=True)\n\n# Instantiate a symbolic backend\nsymbolic_backend = get_backend(\"sympy\")\n\n\nRecompilation of a unitary\nOne of the fundamental tasks performed by quantum computer scientists is the design of quantum circuits. This design is subject to constraints coming from a target device, an algorithm, or for efficiency purposes. We show in this section two equivalent circuits representing a universal single-qubit state on the Bloch sphere, i.e. \\(|\\psi\\rangle = \\cos{(\\theta/2)}|0\\rangle + e^{i\\phi'} \\sin{(\\theta/2)}|1\\rangle\\), where \\(\\theta\\) and \\(\\phi'\\) are real numbers.\nThe first circuit is using \\(R_X\\) and \\(R_Z\\) rotation gates to prepare the state \\(|\\psi\\rangle\\) empirically.\n\nrx_rz_circuit = Circuit([Gate(\"RX\", 0, parameter=theta), Gate(\"RZ\", 0, parameter=phi)])\n_, sv = symbolic_backend.simulate(rx_rz_circuit, return_statevector=True)\nsv\n\n\\(\\displaystyle \\left[\\begin{matrix}e^{- \\frac{i \\phi}{2}} \\cos{\\left(\\frac{\\theta}{2} \\right)}\\\\- i e^{\\frac{i \\phi}{2}} \\sin{\\left(\\frac{\\theta}{2} \\right)}\\end{matrix}\\right]\\)\n\n\nBy applying Euler’s formula \\(e^{-i\\pi/2} = -i\\) and introducing \\(\\phi' = \\phi - \\pi/2\\) one can show that this state vector expressed in the computational basis is equivalent to the expected \\(|\\psi\\rangle\\) state, up to a global phase.\nDesigning efficient circuits for quantum devices requires scientists to understand how to best express them in restricted native gate sets. This symbolic simulator facilitates the process of establishing quantum circuit equivalences that can be used in the compilation process. For example, we can circumvent the use of the \\(R_X\\) gate by leveraging the identity \\(R_X = H R_Z H\\) to perform the equivalent operation.\n\nh_rz_circuit = Circuit([Gate(\"H\", 0), Gate(\"RZ\", 0, parameter=theta), Gate(\"H\", 0), Gate(\"RZ\", 0, parameter=phi)])\n_, sv = symbolic_backend.simulate(h_rz_circuit, return_statevector=True)\nsv\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{e^{- \\frac{i \\phi}{2}} e^{\\frac{i \\theta}{2}}}{2} + \\frac{e^{- \\frac{i \\phi}{2}} e^{- \\frac{i \\theta}{2}}}{2}\\\\- \\frac{e^{\\frac{i \\phi}{2}} e^{\\frac{i \\theta}{2}}}{2} + \\frac{e^{\\frac{i \\phi}{2}} e^{- \\frac{i \\theta}{2}}}{2}\\end{matrix}\\right]\\)\n\n\nWith trigonometric manipulations, one can show that this state vector expressed in the computational basis is also equivalent to the \\(|\\psi\\rangle\\) state.\nThis example is minimalist, but could scale-up to many-qubit unitaries. For example, the construction of a general unitary acting of two qubits requires at least three CNOT gates. However, one could be in a situation where there is no need to get the full circuit “flexbility”, i.e. access to the full Hilbert space of \\(n\\) qubits. In this situation, circuit truncation and optimization could be experimented with using the symbolic simulation feature.\n\n\nEffect of a rotation gate on the energy of a molecule\nAnother example worth mentionning is studying the effect of a rotation gate on qubit entanglement. This is shown in this section via the computation of the dihydrogen (\\(\\text{H}_2\\)) ground-state energy.\nThe circuit is inspired from fermionic excitation operators as stated in the quantum chemistry theory. For example, a single-fermionic excitation operator \\(a_2^{\\dagger} a_0\\) acting on the state \\(|1100\\rangle\\) would result in \\(a_2^{\\dagger} a_0|1100\\rangle = -|0110\\rangle\\) (read as big endian, i.e. the first qubit is stored at the left side of the bitstring). After exponentiation and trotterization of the coupled cluster operator, the resulting circuit exhibits a particular pattern, featuring two CNOT “ladders”, with a \\(R_Z\\) gate in-between (we like to call this an “entangler”). Chemically-inspired ansatze such as the unitary coupled cluster (UCC) have the property of conserving the particle and parity number, which are important symmetries to conserve when solving the Schrödinger equation for a molecular problem.\nAn entangler spanning four qubits is analog to a double fermionic excitation operator, in the Jordan-Wigner mapping. The central \\(R_Z\\) rotation gate has the role of parametrizing the excitation via changing the entanglement magnitude between the qubits. This entanglement has an effect on the measured eigenvalues, and necessarily on the computed molecular energy, as we demonstrate in the next few cells.\nTangelo provides a built-in ansatz for this single-entangler instance; the next cell builds the resulting quantum circuit.\n\nfrom tangelo.toolboxes.ansatz_generator import RUCC\n\n# One-parameter circuit, and it is set to theta.\nansatz = RUCC(1)\nansatz.set_var_params([theta])\nansatz.build_circuit()\n\nsingle_entangler_circuit = ansatz.circuit\nsingle_entangler_circuit.draw()\n\n\n\n\nWe now perform the symbolic simulation.\n\nhist, statevector = symbolic_backend.simulate(single_entangler_circuit, return_statevector=True)\nhist\n\n{'1010': 1.0*cos(theta/2)**2,\n '0101': 1.0*sin(theta/2)**2,\n '1101': 4.93038065763132e-32*sin(theta/2)**2}\n\n\nAs we can see from the results, the probabilities are function of the angle. For any \\(\\theta \\in [0, 2\\pi]\\), only two bitstrings might be measured, preserving the total number of electrons and parity in the circuit. In the next cell, we map the \\(\\text{H}_2\\) Hamiltonian to a sum of tensor products of Pauli operators. This operator is then applied onto the single-entangler circuit to get the expectation value, i.e the molecular energy.\n\nfrom tangelo.molecule_library import mol_H2_sto3g\nfrom tangelo.toolboxes.operators import QubitOperator\nfrom tangelo.toolboxes.qubit_mappings.mapping_transform import fermion_to_qubit_mapping\n\nH = fermion_to_qubit_mapping(mol_H2_sto3g.fermionic_hamiltonian, \"JW\", \n                             mol_H2_sto3g.n_active_sos, mol_H2_sto3g.n_active_electrons, \n                             up_then_down = True)\nenergy = symbolic_backend.get_expectation_value(H, single_entangler_circuit)\nenergy\n\n\\(\\displaystyle - 0.181288808211496 \\sin{\\left(\\theta \\right)} - 0.78796735887703 \\cos{\\left(\\theta \\right)} - 0.328717028208312\\)\n\n\nThe molecular energy is then a function of \\(\\theta\\), plotted below.\n\nplot(energy, (theta, 0., 2*pi), xlabel=theta, ylabel=\"Energy (Hartree)\")\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x7f11e6f65e20&gt;\n\n\nThe energy function is described by a simple peiodic function. As a side note, when the energy exhibits this periodic form, the variational parameter can be optimized anatically using few sampling points with the Rotosolve algorithm.\nThe minimum energy of this expression is computed in the next cell, and corresponds to the Full-Configuration Interaction (FCI) solution (i.e. the best known ground-state solution).\n\nfrom sympy.calculus.util import minimum\nfrom sympy.solvers import solve\nfrom tangelo.algorithms.classical import FCISolver\n\nminimum_energy = minimum(energy, theta)\nminimum_theta = solve(energy - minimum_energy, theta)[0]\n\nfci = FCISolver(mol_H2_sto3g)\ne_fci = fci.simulate()\n\nprint(f\"Difference between FCI and minimum energy = {abs(e_fci - minimum_energy)} Ha at theta = {minimum_theta:.4f}\")\n\nprint(f\"\\nThe histogram at theta = {minimum_theta:.4f}\")\nfor bitstring, prob in hist.items():\n  numerical_prob = prob.subs(theta, minimum_theta)\n  if numerical_prob &gt; 1e-7:\n    print(f\"{bitstring}: {numerical_prob:.4f}\")\n\nDifference between FCI and minimum energy = 2.22044604925031E-16 Ha at theta = 0.2261\n\nThe histogram at theta = 0.2261\n1010: 0.9873\n0101: 0.0127\n\n\n\n\nSingle shot landscape\nThis example illustrates the versatility of computing the results as functions of the circuit parameters, and showcases an amplitude amplification circuit.\nAmplitude amplification is a technique that generalizes the idea behind the Grover’s search algorithm. It is expected to be an important building block for fault-torelant quantum algorithms. Quantum computing is inherently probabilistic, and this technique can improve the statistical occurence of a meaningful state, i.e. increasing its measurement probability. This algorithm has been explained on many platforms: we recommend the Qiskit documentation page on the Grover’s Algorithm and Amplitude Amplification for more information.\nIn the next cell, we first define an empirical state preparation dependent of a parameter \\(\\theta\\). The oracle is defined to select the \\(|11\\rangle\\) state. Finally, the diffuser circuit is constructed using the known state preparation.\n\n# Circuit taken from: https://qiskit.org/documentation/tutorials/algorithms/06_grover.html\n\n# Empirical state prep: a|01&gt; + b|10&gt; + c|11&gt;\nstate_prep = Circuit([Gate(\"RY\", 0, parameter=theta), Gate(\"CH\", 1, control=0), Gate(\"X\", 1)])\n\n# Oracle for the |11&gt; state.\noracle_circ = Circuit([Gate(\"CZ\", 1, control=0)])\n\n# Amplitude amplification circuit\ndiffuser_circ = state_prep.inverse() + Circuit([Gate(\"Z\", 0), Gate(\"Z\", 1), Gate(\"CZ\", 1, control=0)]) + state_prep\n\namplitude_amp_circuit = state_prep + oracle_circ + diffuser_circ\namplitude_amp_circuit.draw()\n\n\n\n\nLet’s get the probability of observing the \\(|11\\rangle\\) state with the state preparation circuit.\n\nresults_state_prep, _ = symbolic_backend.simulate(state_prep, return_statevector=False)\nprint(\"Probability of getting the |11&gt; state after the state preparation:\\n\")\nresults_state_prep[\"11\"]\n\nProbability of getting the |11&gt; state after the state preparation:\n\n\n\n\\(\\displaystyle 0.5 \\sin^{2}{\\left(\\frac{\\theta}{2} \\right)}\\)\n\n\nThis probability is proportional to \\(\\sin^2(\\theta/2)\\). It reaches its maximum value for \\(\\theta = \\pi/2\\), yielding a probability of \\(\\sin^2(\\pi/2)/2 = 0.5\\).\nNow, let’s repeat these steps for the amplitude amplification component.\n\nresults_aa, _ = symbolic_backend.simulate(amplitude_amp_circuit, return_statevector=False)\nprint(\"Probability of getting the |11&gt; state after the amplitude amplification:\\n\")\nresults_aa[\"11\"]\n\nProbability of getting the |11&gt; state after the amplitude amplification:\n\n\n\n\\(\\displaystyle 0.5 \\left(\\sin^{4}{\\left(\\frac{\\theta}{2} \\right)} + 9.0 \\cos^{4}{\\left(\\frac{\\theta}{2} \\right)} - 0.75 \\cos{\\left(2 \\theta \\right)} + 0.75\\right) \\sin^{2}{\\left(\\frac{\\theta}{2} \\right)}\\)\n\n\nThis probability is still a function of a single variable \\(\\theta\\), but it is difficult to visualize it without a graphing tool. Let’s plot this expression between \\(0\\) and \\(2\\pi\\).\n\ngraph = plot(results_state_prep[\"11\"], (theta, 0., 2*pi), xlabel=theta, ylabel=r\"Probability of observing the $|11\\rangle$ state\", label=\"After state preparation\", show=False, legend=True)\ngraph.extend(plot(results_aa[\"11\"], (theta, 0., 2*pi), label=\"With amplitude amplification\", show=False))\ngraph.show()\n\n\n\n\nAfter performing only one simulation, we can draw several conclusions with the amplitude amplification circuit. The probability of getting \\(|11\\rangle\\) from the given state preparation has two maxima, one located between \\(0\\) and \\(\\pi\\) and the other between \\(\\pi\\) and \\(2\\pi\\). In those regions, the \\(|11\\rangle\\) state is amplified by a significant probability. If \\(\\theta \\in \\{0, \\pi, 2\\pi\\}\\), the amplitude amplification circuit is thus not necessary if one is solely interested in the \\(|11\\rangle\\) state."
  },
  {
    "objectID": "examples/workflow_basics/symbolic_simulator.html#closing-words",
    "href": "examples/workflow_basics/symbolic_simulator.html#closing-words",
    "title": "Performing symbolic simulation in Tangelo",
    "section": "Closing words",
    "text": "Closing words\nUsing three different use-cases, we illustrated how symbolic simulation can be a powerful tool to propel research in quantum computing. The first one revolves around the compilation of unitaries with different gate sets. In the bigger picture, this could help research on generating quantum circuits from quantum oracles. In another example, we discussed the effect of a parametrized rotation gate on the entanglement of a circuit. We shown that the computed energy was described by a periodic function of \\(\\theta\\), the parameter controlling the entanglement level between the qubits. The last example introduced the power of single-shot symbolic simulation with the amplitude amplification algorithm. We presented the amplification of \\(|11\\rangle\\) on a \\(a|01\\rangle + b|10\\rangle + c|11\\rangle\\) state, where \\(a,b,c\\) are function of \\(\\theta\\).\nThe main take away of the symbolic simulation concept is the efficiency of simulating many state preparations via a single call to a backend. This is useful in situations where one wish to study entangled qubits, for the design of new circuit primitives, understanding a quantum oracle, or studying the impact of gate parameters on expectation values."
  },
  {
    "objectID": "examples/fault_tolerant/qsp_state_prep.html",
    "href": "examples/fault_tolerant/qsp_state_prep.html",
    "title": "State preparation using quantum signal processing",
    "section": "",
    "text": "We are going to apply a delta function to the Hamiltonian (\\(H\\)), such that all states with eigenvalues outside a specific energy band (\\(\\lambda \\pm \\Delta/2\\)) are supressed. This is performed by applying the operation\n\\(f(H,\\Delta,k)=\\sum_{n=0}^{k}\\frac{T_n(-1+2\\frac{H^2-\\Delta^2}{1-\\Delta^2})}{T_n(-1+2\\frac{-\\Delta^2}{1-\\Delta^2})}\\)\nusing quantum signal processing, where \\(T_n\\) refers to the Chebyshev polynomial of the first kind, defined by \\(T_n(cos(\\theta)) = cos(n\\theta)\\).\n# Installation of tangelo if not already installed.\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet\nAs an example, we will use the polynomial with approximation order \\(k=20\\) for \\(\\Delta = 0.1\\) which is depicted below\nfrom scipy.special import eval_chebyt\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nk = 20\ndelta = 0.1\n\ndef filter_func(x, delta, k):\n    val = 0\n    for i in range(k):\n        arg = -1 + 2*((x**2-delta**2)/(1-delta**2))\n        topk = eval_chebyt(k, arg)\n        arg = -1 + 2*(-delta**2/(1-delta**2))\n        botk = eval_chebyt(k, arg)\n        val += topk/botk\n    return val\n\n# Plot the polynomial\nxs = np.linspace(-1, 1, 100)\nys = np.zeros(len(xs))\n\nfor i, x in enumerate(xs):\n    ys[i] = filter_func(x, delta, k)\n\nplt.plot(xs, ys)\nThis polynomial needs to be converted to phases to use Quantum Signal Processing. For convenience, here are the phases for \\(k=20\\) and \\(\\Delta = 0.1\\). At the end of the notebook, we show two ways to calculate the phases for a given polynomial.\n# phases below are calculated using QSPPACK for n=20, delta = 0.1\nphases = [ 0.76974538,  0.00646461, -0.00773143,  0.00908568, -0.01051591,  0.01200849,\n          -0.01354772,  0.01511600, -0.01669402,  0.01826109, -0.01979540,  0.02127448,\n          -0.02267559,  0.02397626, -0.02515479,  0.02619086, -0.02706603,  0.02776435,\n          -0.02827282,  0.02858185, -0.02868552,  0.02858185, -0.02827282,  0.02776435,\n          -0.02706603,  0.02619086, -0.02515479,  0.02397626, -0.02267559,  0.02127448,\n          -0.01979540,  0.01826109, -0.01669402,  0.01511600, -0.01354772,  0.01200849,\n          -0.01051591,  0.00908568, -0.00773143,  0.00646461,  0.76974538]"
  },
  {
    "objectID": "examples/fault_tolerant/qsp_state_prep.html#hydrogen-molecule-example",
    "href": "examples/fault_tolerant/qsp_state_prep.html#hydrogen-molecule-example",
    "title": "State preparation using quantum signal processing",
    "section": "Hydrogen molecule example",
    "text": "Hydrogen molecule example\nWe are going to prepare two different states using the phases above, as well as the Quantum Signal Processing circuit get_qsp_circuit_no_anc as defined in arXiv:2002.11649.\nWe are going to apply it to \\(H_2\\) in a STO-3G basis with the “scbk” qubit mapping.\n\nfrom openfermion import get_sparse_operator\nimport numpy as np\n\nfrom tangelo.molecule_library import mol_H2_sto3g\nfrom tangelo.toolboxes.qubit_mappings.mapping_transform import fermion_to_qubit_mapping\nfrom tangelo.linq.helpers.circuits.statevector import StateVector\n\nfe_op = mol_H2_sto3g.fermionic_hamiltonian\nqu_op = fermion_to_qubit_mapping(fe_op, \"scbk\", n_spinorbitals=4, n_electrons=2)\n\nham = get_sparse_operator(qu_op).toarray()\neigs, vecs = np.linalg.eigh(ham)\nalpha = eigs[3]-eigs[0]\n\ninit_state = np.random.random(4)\ninit_state /= np.linalg.norm(init_state)\n\nsv = StateVector(init_state)\ninit_circ = sv.initializing_circuit()\n\n\nFirst excited state\nWe need to shift the Hamiltonian such that the desired eigenvalue (\\(\\lambda\\)) is centered at zero and the spectral range is in [-1, 1]. This is done by defining\n\\(\\tilde{H} = \\frac{H-\\lambda}{\\alpha + \\left|\\lambda\\right|}\\)\nwhere \\(\\alpha\\) is the approximation to the spectral range, defined in the previous cell.\n\nfrom tangelo.linq import Circuit, Gate, get_backend\nfrom tangelo.toolboxes.circuits.qsp import get_qsp_circuit_no_anc\nfrom tangelo.toolboxes.circuits.lcu import get_uprep_uselect, get_lcu_qubit_op_info\n\nlamb = eigs[1]\n# Shift Hamiltonian so that spectrum is in [-1, 1] and desired lambda is at 0\nqu_op_tilde = (qu_op - lamb)/(alpha+abs(lamb))\n\n# Generate LCU circuit that applies the Hamiltonian\nuprep, uselect, qu_op_qs, m_qs, alpha = get_uprep_uselect(qu_op_tilde)\ncua = uprep + uselect + uprep.inverse()\n\n# Ancilla qubits\nn_ancilla = len(m_qs) + 1\n\n# Total number of qubits needed to apply algorithm\nn_qubits = len(qu_op_qs) + n_ancilla\n\n# Feed in LCU circuit to generate QSP circuit with phases for eigenvalue filtering\neig_filt_circ = get_qsp_circuit_no_anc(cua, m_qs, phases)\n\n# Add the mesurement gates to the ancilla qubits for the application of the Linear Combination\n# of Unitaries plus the extra qubit for the QSP\n# Measure gates for LCU ancilla qubits\nfull_circuit = init_circ + eig_filt_circ + Circuit([Gate(\"MEASURE\", m) for m in m_qs])\n# Measure gate for the QSP qubit where the phases are applied\nfull_circuit += Circuit([Gate(\"MEASURE\", m_qs[-1]+1)])\n\n\nsim = get_backend()\n\nf, sv = sim.simulate(full_circuit, desired_meas_result=\"0\"*n_ancilla, return_statevector=True)\n# Reorder statevector to \"msq_first\" if statevector in backend is \"lsq_first\"\nif sim.backend_info()[\"statevector_order\"] == \"lsq_first\":\n    sv = np.reshape(sv, [2]*n_qubits).T.flatten()\n# Pick out part of wavefunction that corresponds to \"0000\" on ancilla qubits\nsv = np.reshape(sv, (2**4, 4))[0, :]\n# Reorder statevector to correspond to openfermion ordering\nsv = np.reshape(sv, (2,2)).T.flatten()\n\nprint(f'initial overlap = {abs(np.dot(vecs[:,1], init_state))}')\nprint(f'final overlap = {abs(np.dot(vecs[:,1], sv))}')\n\ninitial overlap = 0.18367656363390905\nfinal overlap = 0.9887577317376988\n\n\n\n\nSecond excited state\nWe can then reapply the same approach to the second excited state.\n\nlamb = eigs[2]\n# Shift Hamiltonian so that spectrum is in [-1, 1] and desired lambda is at 0\nqu_op_tilde = (qu_op - lamb)/(alpha+abs(lamb))\n\n# Generate LCU circuit that applies the Hamiltonian\nuprep, uselect, qu_op_qs, m_qs, alpha = get_uprep_uselect(qu_op_tilde)\ncua = uprep + uselect + uprep.inverse()\n\n# Ancilla qubits\nn_ancilla = len(m_qs) + 1\n\n# Total number of qubits needed to apply algorithm\nn_qubits = len(qu_op_qs) + n_ancilla\n\n# Feed in LCU circuit to generate QSP circuit with phases for eigenvalue filtering\neig_filt_circ = get_qsp_circuit_no_anc(cua, m_qs, phases)\n\nfull_circuit = init_circ + eig_filt_circ + Circuit([Gate(\"MEASURE\", m) for m in m_qs])\nfull_circuit += Circuit([Gate(\"MEASURE\", m_qs[-1]+1)])\n\n\nsim = get_backend()\n\nf, sv = sim.simulate(full_circuit, desired_meas_result=\"0\"*n_ancilla, return_statevector=True)\n# Reorder statevector to \"msq_first\" if statevector in backend is \"lsq_first\"\nif sim.backend_info()[\"statevector_order\"] == \"lsq_first\":\n    sv = np.reshape(sv, [2]*n_qubits).T.flatten()\n# Pick out part of wavefunction that corresponds to \"0000\" on ancilla qubits\nsv = np.reshape(sv, (2**4, 4))[0, :]\n# Reorder statevector to correspond to openfermion ordering\nsv = np.reshape(sv, (2,2)).T.flatten()\n\n\nprint(f'initial overlap = {abs(np.dot(vecs[:,2], init_state))}')\nprint(f'final overlap = {abs(np.dot(vecs[:,2], sv))}')\n\ninitial overlap = 0.18413991077227115\nfinal overlap = 0.9969619094421538"
  },
  {
    "objectID": "examples/fault_tolerant/qsp_state_prep.html#code-to-generate-phases",
    "href": "examples/fault_tolerant/qsp_state_prep.html#code-to-generate-phases",
    "title": "State preparation using quantum signal processing",
    "section": "Code to generate phases",
    "text": "Code to generate phases\nThis section shows 2 options for converting a polynomial into phases, with either QSPPACK or pyqsp.\nThe cells are formatted in markdown as additional dependencies are required to run the following phase calculations, but the code below can be run once they are installed.\n\nUsing QSPPACK\nfrom sympy.abc import x\nfrom sympy import Rational\nfrom sympy.functions.special.polynomials import chebyshevt\n\nk = 20\n# Necessary to work in exact representation for higher order polynomials\ndelta = Rational(delta)\n\ndef filter_func(x, delta, k):\n    val = 0\n    for i in range(k):\n        arg = -1 + 2*((x**2-delta**2)/(1-delta**2))\n        topk = chebyshevt(k, arg)\n        arg = -1 + 2*(-delta**2/(1-delta**2))\n        botk = chebyshevt(k, arg)\n        val += topk/botk\n    return val\nWe need to convert the filter_func polynomial to coefficients of expansion in Chebyshev polynomials to use with QSPPACK\n# Use chebyshev interpolation ak=2/(n+1)*sum_{j=0}^n p(x_j)T_k(x_j), x_j = cos(\\frac{2*j+1}{2*n+2}\\pi)\npoly = filter_func(x, delta, k).as_poly()\n\nn = 2*k\nxjs = np.zeros(n+1)\naks = np.zeros(n+1)\nfor j in range(n+1):\n    xjs[j] = np.cos((2*j+1)/(2*n+2)*np.pi)\n\nfor ki in range(0, n+1, 2):\n    aks[ki] = 0\n    for j in range(n+1):\n        aks[ki] += 2/(n+1)*poly.eval(xjs[j])*eval_chebyt(ki, xjs[j])\n\naks /= k*np.sqrt(2)\naks[0] /=2\naks = aks[0: n+1: 2]\nWe can then obtain the phases using oct2py (with octave installed) and the folder location of QSPPACK cloned from https://github.com/qsppack/QSPPACK.\nfrom oct2py import octave\n\neps = 0.01\nfolder = 'path to QSPPACK'\noctave.addpath(folder)\nopts = octave.struct(\"criteria\", eps)\nphases, _ = octave.QSP_solver(aks, 0, opts, nout=2)\n\n\nUsing pyqsp\nFor \\(k=20\\), pyqsp with the laurent method works properly. However, it often fails for higher order polynomials. In that case, you can install tensorflow and use method=tf. It however seemed much slower than QSPPACK.\nimport pyqsp\nfrom pyqsp import angle_sequence\nfrom pyqsp.angle_sequence import AngleFindingError\nfrom sympy.polys.polytools import primitive\nfrom pyqsp.completion import CompletionError\n\n# Compute phases for real part Cos(Ht) of Exp(iHt)\npg = pyqsp.poly.PolyCosineTX()\nprefac, poly = primitive(filter_func(x, delta, k))\npoly = poly.as_poly()\npolydict = poly.as_dict()\n\ncoefs = np.zeros(2*k + 1, dtype=float)\nfor term, coeff in polydict.items():\n    coefs[term[0]] = prefac*coeff/k/np.sqrt(2)\n\nn_attempts = 100\nmethod = 'laurent'\neps=0.01\n\nfor i in range(n_attempts):\n    try:\n        phases = angle_sequence.QuantumSignalProcessingPhases(\n                coefs, eps=eps, suc=1-eps/10, method=method, tolerance=0.01)\n    except (AngleFindingError, CompletionError):\n        if i == n_attempts-1:\n            raise RuntimeError(\"Real phases calculation failed, increase n_attempts or eps\")\n        else:\n            print(f\"Attempt {i+2} for the real coefficients\")\n    else:\n        break"
  },
  {
    "objectID": "examples/problem_decomposition/dmet.html",
    "href": "examples/problem_decomposition/dmet.html",
    "title": "Density Matrix Embedding Theory (DMET)",
    "section": "",
    "text": "Open In Colab\nThis notebook introduces a problem-decomposition technique called DMET (Density-Matrix Embedding Technique), which enables us to break down a molecular systems into a collection of subproblems with lower computational resource requirements.\nSuch approaches enable us to study how combining classical and quantum algorithms may play a role in the resolution of problems beyond toy models, and even maybe provide a configurable and scalable path forward in the future, towards much more ambitious molecular systems.\nThis notebook assumes that you already have installed Tangelo in your Python environment, or have updated your Python path so that the imports can be resolved. If not, executing the cell below installs the minimal requirements for this notebook.\n# Installation of tangelo if not already installed.\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet"
  },
  {
    "objectID": "examples/problem_decomposition/dmet.html#table-of-contents",
    "href": "examples/problem_decomposition/dmet.html#table-of-contents",
    "title": "Density Matrix Embedding Theory (DMET)",
    "section": "Table of contents:",
    "text": "Table of contents:\n\n1. Introduction\n2. Theory of DMET\n3. First example: DMET-CCSD on Butane\n4. Second example: DMET-VQE on an hydrogen ring\n5. DMET features\n6. Closing words"
  },
  {
    "objectID": "examples/problem_decomposition/dmet.html#introduction",
    "href": "examples/problem_decomposition/dmet.html#introduction",
    "title": "Density Matrix Embedding Theory (DMET)",
    "section": "1. Introduction ",
    "text": "1. Introduction \nOne of the main objectives of quantum chemistry calculations in the area of materials science is to solve the electronic structure problem, \\(H\\Psi=E\\Psi\\), as accurately as possible, in order to accelerate the materials design process. In the first example, the butane molecule is shown as an example.\n\nThe computational cost for performing accurate calculations of the electronic structure of molecules, however, is usually very expensive. For example, the cost of performing the full CI calculation scales exponentially on a classical computer as the size of the system increases. Therefore, when we target large-sized molecules, those relevant for industry problems, it becomes essential to employ an appropriate strategy for reducing the computational cost. The difficulty is to employ a strategy that consolidate accuracy while reducing computational costs when performing electronic structure calculations. Next, we will developp one of such strategies called Density-Matrix Embedding Theory (DMET)."
  },
  {
    "objectID": "examples/problem_decomposition/dmet.html#theory-of-dmet",
    "href": "examples/problem_decomposition/dmet.html#theory-of-dmet",
    "title": "Density Matrix Embedding Theory (DMET)",
    "section": "2. Theory of DMET ",
    "text": "2. Theory of DMET \nThe idea is to decompose a molecular system into its constituent fragments and its environment. Each fragment are treated independently and recombined at the end to recover the full molecular energy. This has the advantages of cutting down the maximal computational complexity depending on the biggest fragment and being naturally implemented on parrallel computer. On the other side, the fragmenting comes at the cost of reducing accuraccy of the computation.\nFirst, the environment is calculated using a less-accurate method than will be used to calculate the electronic structure of a fragment. Then, the electronic structure problem for a given fragment is solved to a high degree of accuracy, which includes the quantum mechanical effects of the environment. The quantum mechanical description is updated (i.e., solved iteratively as shown below) by incorporating the just-performed highly accurate calculation. In the following schematic illustration, the molecule shown above is decomposed into fragments. Each molecular fragment CH\\(_\\mathrm{3}\\) and CH\\(_\\text{2}\\) are the fragments chosen for the electronic structure calculation, with the rest of the molecular system being the surrounding environment.\n\nOne successful decomposition approach is the DMET method. The DMET method decomposes a molecule into fragments, and each fragment is treated as an open quantum system that is entangled with each of the other fragments, all taken together to be that fragment’s surrounding environment (or “bath”). In this framework, the electronic structure of a given fragment is obtained by solving the following Hamiltonian, by using a highly accurate quantum chemistry method, such as the full CI method or a coupled-cluster method.\n\\[ H_{I}=\\sum^{\\text{frag}+\\text{bath}}_{rs}  \\left[ h_{rs} + \\sum_{mn} \\left[ (rs|mn) - (rn|ms) \\right] D^{\\text{(mf)env}}_{mn} \\right] a_{r}^{\\dagger}a_{s} + \\sum_{pqrs}^{\\text{frag}+\\text{bath}} (pq|rs) a_{p}^{\\dagger}a_{r}^{\\dagger}a_{s}a_{q} - \\mu\\sum_{r}^{\\text{frag}} a_{r}^{\\dagger}a_{r} \\]\nThe expression \\(\\sum_{mn} \\left[ (rs|mn) - (rn|ms) \\right] D^{\\text{(mf)env}}_{mn}\\) describes the quantum mechanical effects of the environment on the fragment, where \\(D^{\\text{(mf)env}}_{mn}\\) is the mean-field electronic density obtained by solving the Hartree–Fock equation. The quantum mechanical effects from the environment are incorporated through the one-particle term of the Hamiltonian. The extra term \\(\\mu\\sum_{r}^{\\text{frag}} a_{r}^{\\dagger}a_{r}\\) ensures, through the adjustment of \\(\\mu\\), that the number of electrons in all of the fragments, taken together, becomes equal to the total number of electrons in the entire system."
  },
  {
    "objectID": "examples/problem_decomposition/dmet.html#first-example-dmet-ccsd-on-butane",
    "href": "examples/problem_decomposition/dmet.html#first-example-dmet-ccsd-on-butane",
    "title": "Density Matrix Embedding Theory (DMET)",
    "section": "3. First example: DMET-CCSD on Butane ",
    "text": "3. First example: DMET-CCSD on Butane \nBefore we proceed, let’s import all the relevant data-structures and classes from tangelo:\n\n# Import for a pretty jupyter notebook.\nimport json\n\n# Molecule definition.\nfrom tangelo import SecondQuantizedMolecule\n\n# The minimal import for DMET.\nfrom tangelo.problem_decomposition import DMETProblemDecomposition\n# Ability to change localization method.\nfrom tangelo.problem_decomposition.dmet import Localization\n# Use for VQE ressources estimation vs DMET.\nfrom tangelo.algorithms import VQESolver\n# Use for comparison.\nfrom tangelo.algorithms import FCISolver\n\nThe first example will show how to partition the system into fragments. A different method for solving electronic structures can be chosen for each fragment, but here we will stick with CCSD. The first thing to do is building the butane molecule object.\n\nbutane = \"\"\"\nC   2.142   1.395  -8.932\nH   1.604   0.760  -8.260              \nH   1.745   2.388  -8.880\nH   2.043   1.024  -9.930\nC   3.631   1.416  -8.537\nH   4.169   2.051  -9.210\nH   3.731   1.788  -7.539             \nC   4.203  -0.012  -8.612\nH   3.665  -0.647  -7.940\nH   4.104  -0.384  -9.610\nC   5.691   0.009  -8.218  \nH   6.088  -0.983  -8.270\nH   5.791   0.381  -7.220\nH   6.230   0.644  -8.890\n\"\"\"\n\n# Building the molecule object.\nmol_butane = SecondQuantizedMolecule(butane, q=0, spin=0, basis=\"minao\")\n\nThe options for the DMET decomposition method are stored in a python dictionary. * molecule: The SecondQuantizedMolecule object. * fragment_atoms: List for the number of atoms in each fragment. Each atoms are chosen with their order in the coordinates definition (variable butane). Also, the sum of all numbers must be equal to total number of atoms in the molecule. * fragment_solvers: A string or a list of string representing the solver for each fragment. The number of items in the list must be equal to the number of fragment. There is one exception: when a single string is defined, the solver is the same for all fragments. * verbose: Activate verbose output.\nThe next step dmet.build() ensures that the fragments and environment orbitals are defined according to the electron localization scheme.\n\noptions_butane_dmet = {\"molecule\": mol_butane,\n                       # Fragment definition = CH3, CH2, CH2, CH3\n                       \"fragment_atoms\": [4, 3, 3, 4],\n                       \"fragment_solvers\": \"ccsd\",\n                       \"verbose\": True\n                       }\n\ndmet_butane = DMETProblemDecomposition(options_butane_dmet)\ndmet_butane.build()\n\nFinally, we can call the dmet_butane.simulate() method to get the DMET-CCSD energy.\n\nenergy_butane_dmet = dmet_butane.simulate()\nprint(f\"DMET energy (hartree): \\t {energy_butane_dmet}\")\n\n    Iteration =  1\n    ----------------\n \n        Fragment Number : #  1\n        ------------------------\n        Fragment Energy = -72.05405827603914\n        Number of Electrons in Fragment = 9.012005183591981\n        Fragment Number : #  2\n        ------------------------\n        Fragment Energy = -72.40954115391904\n        Number of Electrons in Fragment = 7.989043831475258\n        Fragment Number : #  3\n        ------------------------\n        Fragment Energy = -72.41729771370646\n        Number of Electrons in Fragment = 7.989177971768037\n        Fragment Number : #  4\n        ------------------------\n        Fragment Energy = -72.06317456624696\n        Number of Electrons in Fragment = 9.01200720931663\n    Iteration =  2\n    ----------------\n \n        Fragment Number : #  1\n        ------------------------\n        Fragment Energy = -72.05448289161356\n        Number of Electrons in Fragment = 9.012106057456307\n        Fragment Number : #  2\n        ------------------------\n        Fragment Energy = -72.4103731262653\n        Number of Electrons in Fragment = 7.989213886203206\n        Fragment Number : #  3\n        ------------------------\n        Fragment Energy = -72.41812944864117\n        Number of Electrons in Fragment = 7.989347951531629\n        Fragment Number : #  4\n        ------------------------\n        Fragment Energy = -72.06359892187905\n        Number of Electrons in Fragment = 9.012107987424784\n    Iteration =  3\n    ----------------\n \n        Fragment Number : #  1\n        ------------------------\n        Fragment Energy = -72.05230694081374\n        Number of Electrons in Fragment = 9.011589139486894\n        Fragment Number : #  2\n        ------------------------\n        Fragment Energy = -72.40610957433793\n        Number of Electrons in Fragment = 7.988342441549417\n        Fragment Number : #  3\n        ------------------------\n        Fragment Energy = -72.41386711306457\n        Number of Electrons in Fragment = 7.988476890962632\n        Fragment Number : #  4\n        ------------------------\n        Fragment Energy = -72.06142430284487\n        Number of Electrons in Fragment = 9.011591560091082\n    Iteration =  4\n    ----------------\n \n        Fragment Number : #  1\n        ------------------------\n        Fragment Energy = -72.05230691565814\n        Number of Electrons in Fragment = 9.011589133511112\n        Fragment Number : #  2\n        ------------------------\n        Fragment Energy = -72.40610952503438\n        Number of Electrons in Fragment = 7.988342431471346\n        Fragment Number : #  3\n        ------------------------\n        Fragment Energy = -72.41386706377506\n        Number of Electrons in Fragment = 7.988476880888985\n        Fragment Number : #  4\n        ------------------------\n        Fragment Energy = -72.06142427770467\n        Number of Electrons in Fragment = 9.011591554120972\n    *** DMET Cycle Done *** \n    DMET Energy ( a.u. ) =   -157.1137415264\n    Chemical Potential   =     -0.0004124578\nDMET energy (hartree):   -157.11374152644183\n\n\nAs seen below, the correlation energy \\(E_{corr} = E_{DMET}-E_{HF}\\) retrieved from this calculation is significant.\n\nenergy_butane_hf = dmet_butane.mean_field.e_tot\nenergy_corr_butane = abs(energy_butane_dmet - energy_butane_hf)\n\nprint(f\"Correlation energy (hartree): \\t {energy_corr_butane}\")\nprint(f\"Correlation energy (kcal/mol): \\t {627.5*energy_corr_butane}\")\n\nCorrelation energy (hartree):    0.2645637234647893\nCorrelation energy (kcal/mol):   166.01373647415528"
  },
  {
    "objectID": "examples/problem_decomposition/dmet.html#second-example-dmet-vqe-on-an-hydrogen-ring",
    "href": "examples/problem_decomposition/dmet.html#second-example-dmet-vqe-on-an-hydrogen-ring",
    "title": "Density Matrix Embedding Theory (DMET)",
    "section": "4. Second example: DMET-VQE on an hydrogen ring ",
    "text": "4. Second example: DMET-VQE on an hydrogen ring \n\n4.1 Why not only using VQE?\nWe saw in the last section that the computation of DMET fragments is able to get back a significant amount of correlation energy. A valid question that can be asked is: “Why can’t we just directly tackle the initial problem without DMET?”. As stated earlier, DMET breaks the system into its constituent fragments; reducing the initial problem to a collection of subproblems requiring less computational resources. This can be crucial to making the problem tractable with classical simulators or nascent quantum computers.\nWe have selected a ring of 10 hydrogen atoms as a simple example of a molecular system. The distance between adjacent hydrogen atoms has been set to 1\\(~\\)Å.\n\nH10=\"\"\"\nH          1.6180339887          0.0000000000          0.0000000000\nH          1.3090169944          0.9510565163          0.0000000000\nH          0.5000000000          1.5388417686          0.0000000000\nH         -0.5000000000          1.5388417686          0.0000000000\nH         -1.3090169944          0.9510565163          0.0000000000\nH         -1.6180339887          0.0000000000          0.0000000000\nH         -1.3090169944         -0.9510565163          0.0000000000\nH         -0.5000000000         -1.5388417686          0.0000000000\nH          0.5000000000         -1.5388417686          0.0000000000\nH          1.3090169944         -0.9510565163          0.0000000000\n\"\"\"\n\nmol_h10 = SecondQuantizedMolecule(H10, q=0, spin=0, basis=\"minao\")\n\nIn the example below, we show resource requirements using standard parameters. Please note that other encodings could reduce the required resources, but resources would still be too much for current hardware.\n\noptions_h10_vqe = {\"molecule\": mol_h10, \"qubit_mapping\": \"jw\", \"verbose\": False}\nvqe_h10 = VQESolver(options_h10_vqe)\nvqe_h10.build()\n\nHere are some resources estimation that would be needed for a direct VQE calculation on the initial problem, without DMET: for quantum computers in the NISQ era, tackling this head-on is a daunting task.\n\n# This can take up to 10 minutes.\n# resources_h10_vqe = vqe_h10.get_resources()\nresources_h10_vqe = {\n  \"qubit_hamiltonian_terms\": 4039,\n  \"circuit_width\": 20,\n  \"circuit_depth\": 34696,\n  \"circuit_2qubit_gates\": 30784,\n  \"circuit_var_gates\": 1900,\n  \"vqe_variational_parameters\": 350\n}\nprint(json.dumps(resources_h10_vqe, indent=2))\n\n{\n  \"qubit_hamiltonian_terms\": 4039,\n  \"circuit_width\": 20,\n  \"circuit_depth\": 34696,\n  \"circuit_2qubit_gates\": 30784,\n  \"circuit_var_gates\": 1900,\n  \"vqe_variational_parameters\": 350\n}\n\n\n\n\n4.2 DMET-VQE\nHere, we demonstrate how to perform DMET-VQE calculations using Tangelo package. The aim is to obtain improved results (vs HF energy) when compairing to the Full CI method (without using problem decomposition) and also using a quantum algorithm (VQE).\n\noptions_h10_dmet = {\"molecule\": mol_h10,\n                    \"fragment_atoms\": [1]*10,\n                    \"fragment_solvers\": \"vqe\",\n                    \"verbose\": False\n                    }\n\ndmet_h10 = DMETProblemDecomposition(options_h10_dmet)\ndmet_h10.build()\n\nThe dmet.build() method creates fragments (10) from the H10 molecule. When we decompose the ring of atoms into fragments including only one hydrogen atom each, the DMET method creates a fragment orbital (left: the single orbital distribution is shown in both pink and blue, with the colours depicting the phases) and the bath orbital (right: the single orbital distribution of the remaining nine hydrogen atoms is shown in both pink and blue, with the colours depicting the phases).\n\nResource estimation is done by calling dmet_h10.get_resources(). Here, a list of ten dictionaries is returned and stored in resources_h10_dmet. Each dictionary refers to a fragment. As every fragment is the same in this system (a single hydrogen atom), we only print one.\n\nresources_h10_dmet = dmet_h10.get_resources()\nprint(json.dumps(resources_h10_dmet[0], indent=2))\n\n{\n  \"qubit_hamiltonian_terms\": 27,\n  \"circuit_width\": 4,\n  \"circuit_depth\": 100,\n  \"circuit_2qubit_gates\": 64,\n  \"circuit_var_gates\": 12,\n  \"vqe_variational_parameters\": 2\n}\n\n\nCompared to a direct VQE algorithm, those resources are greatly reduced: from 20 qubits down to only 4 qubits in our case. Below, dmet_h10.simulate() computes the DMET-VQE energy.\nThe options currently selected specify that VQE must be run for each fragment, at each iteration of DMET: as such, it may take 2-3 minutes for this cell to finish. The verbose option is turned off to hide the lengthy prints: feel free to turn it back on to track the progress of this cell, if you’d like.\n\ndmet_h10.verbose = False\nenergy_h10_dmet = dmet_h10.simulate()\n\nprint(f\"DMET energy (hartree): \\t {energy_h10_dmet}\")\n\nDMET energy (hartree):   -5.367523592601959\n\n\nA comparison with an FCI calculation is then made.\n\nfci_h10 = FCISolver(mol_h10)\nenergy_h10_fci = fci_h10.simulate()\n\nprint(f\"FCI energy (hartree): \\t {energy_h10_fci}\")\n\nFCI energy (hartree):    -5.380926000730877\n\n\nLastly, we note that the DMET energy is closer to the FCI energy than the HF energy. DMET-VQE results are an improvement but are still not at the FCI level. This discrepancy is attributable to missing three, four … many body interactions. When dismantling the system into fragments, we get a single hydrogen atom per fragment. Therefore, those fragments cannot propagate higher level (three and more) excitations. DMET user should have in mind this dilemma between fragment sizes and accuracy of the total electronic energy.\n\nenergy_h10_hf = dmet_h10.mean_field.e_tot\ndelta_h10_fci_hf = abs(energy_h10_fci - energy_h10_hf)\ndelta_h10_fci_dmet = abs(energy_h10_fci - energy_h10_dmet)\n\nprint(f\"Difference FCI vs HF energies (hartree): \\t\\t {delta_h10_fci_hf}\")\nprint(f\"Difference FCI vs DMET-VQE energies (hartree): \\t\\t {delta_h10_fci_dmet}\")\nprint(f\"Difference FCI vs HF energies (kcal/mol): \\t\\t {627.5*delta_h10_fci_hf}\")\nprint(f\"Difference FCI vs DMET-VQE energies (kcal/mol): \\t {627.5*delta_h10_fci_dmet}\")\n\nDifference FCI vs HF energies (hartree):         0.11680533556175376\nDifference FCI vs DMET-VQE energies (hartree):       0.013402408128918353\nDifference FCI vs HF energies (kcal/mol):        73.29534806500048\nDifference FCI vs DMET-VQE energies (kcal/mol):      8.410011100896266"
  },
  {
    "objectID": "examples/problem_decomposition/dmet.html#dmet-features",
    "href": "examples/problem_decomposition/dmet.html#dmet-features",
    "title": "Density Matrix Embedding Theory (DMET)",
    "section": "5. DMET features",
    "text": "5. DMET features\nIn this section, some DMET features are shown. A four hydrogen atoms system is defined for this purpose.\n\nH4 = \"\"\"\nH 0.7071 0. 0.\nH 0. 0.7071 0.\nH -1.0071 0. 0.\nH 0. -1.0071 0.\n\"\"\"\n\nmol_h4 = SecondQuantizedMolecule(H4, q=0, spin=0, basis=\"3-21g\")\n\n\n5.1 Localization method\nElectron localization is used to define the bath and the environment orbitals. There are two options available:\n\nLocalization.meta_lowdin (default): Described in Q. Sun et al., JCTC 10, 3784-3790 (2014).\nLocalization.iao: Described in G. Knizia, JCTC 9, 4834-4843 (2013). This algorithm maps the orbitals to an minao set. So, at least a double zeta basis set must be used with this localization method.\n\n\noptions_h4_dmet = {\"molecule\": mol_h4,\n                   \"fragment_atoms\": [1]*4,\n                   \"electron_localization\": Localization.iao,\n                   \"verbose\": False}\n\ndmet_h4 = DMETProblemDecomposition(options_h4_dmet)\nvars(dmet_h4)\n\n{'molecule': &lt;pyscf.gto.mole.Mole at 0x12a5dfdf0&gt;,\n 'electron_localization': &lt;Localization.iao: 1&gt;,\n 'fragment_atoms': [1, 1, 1, 1],\n 'fragment_solvers': ['ccsd', 'ccsd', 'ccsd', 'ccsd'],\n 'optimizer': &lt;bound method DMETProblemDecomposition._default_optimizer of &lt;tangelo.problem_decomposition.dmet.dmet_problem_decomposition.DMETProblemDecomposition object at 0x12a5dff10&gt;&gt;,\n 'initial_chemical_potential': 0.0,\n 'solvers_options': [{}, {}, {}, {}],\n 'verbose': False,\n 'uhf': False,\n 'mean_field': RHF object of &lt;class 'pyscf.scf.hf.RHF'&gt;,\n 'chemical_potential': None,\n 'dmet_energy': None,\n 'orbitals': None,\n 'orb_list': None,\n 'orb_list2': None,\n 'onerdm_low': None,\n 'solver_fragment_dict': {},\n 'n_iter': 0}\n\n\n\n\n5.2 Fragment solvers\nA list of solvers can be passed to the DMETProblemDecomposition class. If a single solver is detected, it will be applied to all fragments. Here is an example where the first fragment is solved with VQE, the second one with CCSD, the third one with FCI and the last one with VQE.\n\noptions_h4_dmet = {\"molecule\": mol_h4,\n                   \"fragment_atoms\": [1]*4,\n                   \"fragment_solvers\": [\"vqe\", \"ccsd\", \"fci\", \"vqe\"],\n                   \"verbose\": False}\n\ndmet_h4 = DMETProblemDecomposition(options_h4_dmet)\nvars(dmet_h4)\n\n{'molecule': &lt;pyscf.gto.mole.Mole at 0x12a5df160&gt;,\n 'electron_localization': &lt;Localization.meta_lowdin: 0&gt;,\n 'fragment_atoms': [1, 1, 1, 1],\n 'fragment_solvers': ['vqe', 'ccsd', 'fci', 'vqe'],\n 'optimizer': &lt;bound method DMETProblemDecomposition._default_optimizer of &lt;tangelo.problem_decomposition.dmet.dmet_problem_decomposition.DMETProblemDecomposition object at 0x12a5df310&gt;&gt;,\n 'initial_chemical_potential': 0.0,\n 'solvers_options': [{'qubit_mapping': 'jw',\n   'initial_var_params': 'ones',\n   'verbose': False},\n  {},\n  {},\n  {'qubit_mapping': 'jw', 'initial_var_params': 'ones', 'verbose': False}],\n 'verbose': False,\n 'uhf': False,\n 'mean_field': RHF object of &lt;class 'pyscf.scf.hf.RHF'&gt;,\n 'chemical_potential': None,\n 'dmet_energy': None,\n 'orbitals': None,\n 'orb_list': None,\n 'orb_list2': None,\n 'onerdm_low': None,\n 'solver_fragment_dict': {},\n 'n_iter': 0}\n\n\n\n\n5.3 Initial chemical potential\nThe DMET optimizes a parameter \\(\\mu\\), the chemical potential. It ensures that the sum of all fragment electrons is consistent with the total number of electrons. As it is numerically optimized, the initial value can be important. Here is an example where the initial_chemical_potential is set to 0.1.\n\noptions_h4_dmet = {\"molecule\": mol_h4,\n                   \"fragment_atoms\": [1]*4,\n                   \"initial_chemical_potential\" : 0.1,\n                   \"verbose\": False}\n\ndmet_h4 = DMETProblemDecomposition(options_h4_dmet)\nvars(dmet_h4)\n\n{'molecule': &lt;pyscf.gto.mole.Mole at 0x12a5df400&gt;,\n 'electron_localization': &lt;Localization.meta_lowdin: 0&gt;,\n 'fragment_atoms': [1, 1, 1, 1],\n 'fragment_solvers': ['ccsd', 'ccsd', 'ccsd', 'ccsd'],\n 'optimizer': &lt;bound method DMETProblemDecomposition._default_optimizer of &lt;tangelo.problem_decomposition.dmet.dmet_problem_decomposition.DMETProblemDecomposition object at 0x12a5df7c0&gt;&gt;,\n 'initial_chemical_potential': 0.1,\n 'solvers_options': [{}, {}, {}, {}],\n 'verbose': False,\n 'uhf': False,\n 'mean_field': RHF object of &lt;class 'pyscf.scf.hf.RHF'&gt;,\n 'chemical_potential': None,\n 'dmet_energy': None,\n 'orbitals': None,\n 'orb_list': None,\n 'orb_list2': None,\n 'onerdm_low': None,\n 'solver_fragment_dict': {},\n 'n_iter': 0}\n\n\n\n\n5.4 Solvers options\nA list of options can be passed to the solvers. Each element of the list must be consistent with the appropriate value in fragment_solvers. If a single dictionary of options is detected, it is applied to all fragment solvers. Here is an example where one wants to set the qubit mapping to the Bravyi-Kitaev method when performing VQE.\n\nvqe_options = {\"qubit_mapping\": \"bk\"}\n\noptions_h4_dmet = {\"molecule\": mol_h4,\n                   \"fragment_atoms\": [1]*4,\n                   \"fragment_solvers\": \"vqe\",\n                   \"solvers_options\": vqe_options, \n                   \"verbose\": False}\n\ndmet_h4 = DMETProblemDecomposition(options_h4_dmet)\nvars(dmet_h4)\n\n{'molecule': &lt;pyscf.gto.mole.Mole at 0x12a5dfa30&gt;,\n 'electron_localization': &lt;Localization.meta_lowdin: 0&gt;,\n 'fragment_atoms': [1, 1, 1, 1],\n 'fragment_solvers': ['vqe', 'vqe', 'vqe', 'vqe'],\n 'optimizer': &lt;bound method DMETProblemDecomposition._default_optimizer of &lt;tangelo.problem_decomposition.dmet.dmet_problem_decomposition.DMETProblemDecomposition object at 0x12a5df040&gt;&gt;,\n 'initial_chemical_potential': 0.0,\n 'solvers_options': [{'qubit_mapping': 'bk'},\n  {'qubit_mapping': 'bk'},\n  {'qubit_mapping': 'bk'},\n  {'qubit_mapping': 'bk'}],\n 'verbose': False,\n 'uhf': False,\n 'mean_field': RHF object of &lt;class 'pyscf.scf.hf.RHF'&gt;,\n 'chemical_potential': None,\n 'dmet_energy': None,\n 'orbitals': None,\n 'orb_list': None,\n 'orb_list2': None,\n 'onerdm_low': None,\n 'solver_fragment_dict': {},\n 'n_iter': 0}"
  },
  {
    "objectID": "examples/problem_decomposition/dmet.html#closing-words",
    "href": "examples/problem_decomposition/dmet.html#closing-words",
    "title": "Density Matrix Embedding Theory (DMET)",
    "section": "6. Closing words",
    "text": "6. Closing words\nThis concludes our overview of DMETProblemDecomposition. There are many flavors of DMET and only one has been discussed here. Here we refer some papers relevant for the reader who wants more details:\n\nTheory\n\nS. Wouters, C.A. Jiménez-Hoyos, Q. Sun, and G.K.L. Chan, J. Chem. Theory Comput. 12, 2706 (2016).\nG. Knizia and G.K.L. Chan, J. Chem. Theory Comput. 9, 1428 (2013).\nG. Knizia and G.K.L. Chan, Phys. Rev. Lett. 109, 186404 (2012).\n\nGood Chemistry Company papers on the subject\n\nY. Kawashima, M.P. Coons, Y. Nam, E. Lloyd, S. Matsuura, A.J. Garza, S. Johri, L. Huntington, V. Senicourt, A.O. Maksymov, J.H. V. Nguyen, J. Kim, N. Alidoust, A. Zaribafiyan, and T. Yamazaki, ArXiv:2102.07045 (2021).\nT. Yamazaki, S. Matsuura, A. Narimani, A. Saidmuradov, and A. Zaribafiyan, ArXiv:1806.01305 (2018)."
  },
  {
    "objectID": "examples/problem_decomposition/dmet_uhf.html",
    "href": "examples/problem_decomposition/dmet_uhf.html",
    "title": "Applying Unrestricted Density-Matrix Embedding Theory to battery chemistry",
    "section": "",
    "text": "Density-Matrix Embedding Theory (DMET) is part of a toolset we call problem decomposition methods, which breaks down a molecular problem into a collection of smaller subproblems requiring a lower amount of computational resources (classical or quantum). In another notebook, we introduced the DMET algorithm, its relevance, and implemented features in Tangelo.\nSome conclusions can be drawn from this educational resource: - There is a tradeoff between the DMET fragmentation (number of atoms per fragment) and the DMET energy accuracy; - Each fragment can be treated independently; - The 1- and 2-body Reduced Density Matrices (RDMs) are the information needed for each fragment to recontruct the full system wavefunction.\n\nWhen not explicitly mentioned, DMET’s underlying mean-field calculation for each fragment generally refers to a restricted Hartree-Fock calculation, meaning the spin orbitals are treated as pairs. As stated in Szabo & Ostlund, the lowest mean-field energy of a molecule with unpaired electrons is retrieved from an unrestricted calculation. According to the from the Unrestricted Hartree–Fock wiki page:\n\n“(…) the unrestricted Hartree–Fock method is used frequently, and in preference to the restricted open-shell Hartree–Fock (ROHF) method, because UHF is simpler to code, easier to develop post-Hartree–Fock methods with, and returns unique functions unlike ROHF where different Fock operators can give the same final wave function.”\n\nMore information on those concepts can be found in the quantum chemistry modelling notebook.\n\nExpanding DMET calculations beyond the restricted formalism opens up the application of this problem decomposition scheme to free radicals (at least one unpaired valence electron). Those molecules, although rarely present in a stable form at standard temperature and pressure, can be found as intermediate species in chemical reactions. As a consequence, they are important for modelling kinetics in complex chemical systems. One example of those complex systems is battery chemistry, where understanding energy transfer between chemicals is essential to further develop this technology. On this point, quantum simulation for battery chemistry has attracted some attention with public announcements and scientific publications. The Mercedes-Benz (with PsiQuantum), Ford and Volkswagen (with Xanadu) initiatives are part of this push. While the first and third studies bring insights on the resources required to tackle quantum simulation for battery chemistry with fault-tolerant algorithms, the second study could be categorized as a NISQ-friendly approach. However, the estimated circuit depths are still way beyond existing device capabilities, as it yields circuits of \\(10^5 - 10^6\\) moments.\n\nWhile waiting for a hardware breakthrough towards fault-tolerant quantum computers, unrestricted DMET calculation (UHF-DMET) may help modelling more industrially-relevant molecules on Noisy Intermediate Scale Quantum (NISQ) devices. We have previously addressed this statement with restricted DMET calculations in a Communcation Physics publication, reproduced in the “overview of an end-to-end experiment” notebook. In this notebook, we focus on a use case relevant for battery chemistry development using the UHF-DMET algorithm. The quantum resource estimation and experiment are intentionally left out of this notebook as they are already covered in the references above.\nBut first, let’s install Tangelo in our environment.\n\ntry:\n  import tangelo\nexcept ImportError:\n  !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet"
  },
  {
    "objectID": "examples/problem_decomposition/dmet_uhf.html#introduction",
    "href": "examples/problem_decomposition/dmet_uhf.html#introduction",
    "title": "Applying Unrestricted Density-Matrix Embedding Theory to battery chemistry",
    "section": "",
    "text": "Density-Matrix Embedding Theory (DMET) is part of a toolset we call problem decomposition methods, which breaks down a molecular problem into a collection of smaller subproblems requiring a lower amount of computational resources (classical or quantum). In another notebook, we introduced the DMET algorithm, its relevance, and implemented features in Tangelo.\nSome conclusions can be drawn from this educational resource: - There is a tradeoff between the DMET fragmentation (number of atoms per fragment) and the DMET energy accuracy; - Each fragment can be treated independently; - The 1- and 2-body Reduced Density Matrices (RDMs) are the information needed for each fragment to recontruct the full system wavefunction.\n\nWhen not explicitly mentioned, DMET’s underlying mean-field calculation for each fragment generally refers to a restricted Hartree-Fock calculation, meaning the spin orbitals are treated as pairs. As stated in Szabo & Ostlund, the lowest mean-field energy of a molecule with unpaired electrons is retrieved from an unrestricted calculation. According to the from the Unrestricted Hartree–Fock wiki page:\n\n“(…) the unrestricted Hartree–Fock method is used frequently, and in preference to the restricted open-shell Hartree–Fock (ROHF) method, because UHF is simpler to code, easier to develop post-Hartree–Fock methods with, and returns unique functions unlike ROHF where different Fock operators can give the same final wave function.”\n\nMore information on those concepts can be found in the quantum chemistry modelling notebook.\n\nExpanding DMET calculations beyond the restricted formalism opens up the application of this problem decomposition scheme to free radicals (at least one unpaired valence electron). Those molecules, although rarely present in a stable form at standard temperature and pressure, can be found as intermediate species in chemical reactions. As a consequence, they are important for modelling kinetics in complex chemical systems. One example of those complex systems is battery chemistry, where understanding energy transfer between chemicals is essential to further develop this technology. On this point, quantum simulation for battery chemistry has attracted some attention with public announcements and scientific publications. The Mercedes-Benz (with PsiQuantum), Ford and Volkswagen (with Xanadu) initiatives are part of this push. While the first and third studies bring insights on the resources required to tackle quantum simulation for battery chemistry with fault-tolerant algorithms, the second study could be categorized as a NISQ-friendly approach. However, the estimated circuit depths are still way beyond existing device capabilities, as it yields circuits of \\(10^5 - 10^6\\) moments.\n\nWhile waiting for a hardware breakthrough towards fault-tolerant quantum computers, unrestricted DMET calculation (UHF-DMET) may help modelling more industrially-relevant molecules on Noisy Intermediate Scale Quantum (NISQ) devices. We have previously addressed this statement with restricted DMET calculations in a Communcation Physics publication, reproduced in the “overview of an end-to-end experiment” notebook. In this notebook, we focus on a use case relevant for battery chemistry development using the UHF-DMET algorithm. The quantum resource estimation and experiment are intentionally left out of this notebook as they are already covered in the references above.\nBut first, let’s install Tangelo in our environment.\n\ntry:\n  import tangelo\nexcept ImportError:\n  !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet"
  },
  {
    "objectID": "examples/problem_decomposition/dmet_uhf.html#tackling-the-textlio_2-molecule-with-dmet-and-classical-solvers",
    "href": "examples/problem_decomposition/dmet_uhf.html#tackling-the-textlio_2-molecule-with-dmet-and-classical-solvers",
    "title": "Applying Unrestricted Density-Matrix Embedding Theory to battery chemistry",
    "section": "Tackling the \\(\\text{LiO}_2\\) Molecule with DMET and Classical Solvers",
    "text": "Tackling the \\(\\text{LiO}_2\\) Molecule with DMET and Classical Solvers\nWe tackle the ground-state preparation of the lithium superoxide (\\(\\text{LiO}_2\\)) molecule, using UHF-DMET. \\(\\text{LiO}_2\\) is a chemical compound formed in an electrolytic cell from the reaction of a lithium ion with oxygen at the cathode:\n\\[\\text{Li}^+ + \\text{e}^- + \\text{O}_2 -&gt; \\text{LiO}_2\\]\nThe stabilization of this compound could lead to a new type of batteries with improved energy density, as stated in this phys.org news article. To study this compound, a wet chemistry analog of this process would be the \\(\\text{LiO}_2\\) synthesis from lithium electride dissolved in anhydrous ammonia.\nVia quantum chemistry theory, we know that the \\(\\text{LiO}_2\\) molecule is described by 42 molecular orbitals (in the STO-3G basis) and 19 electrons. This problem statement involves computational challenges due to the exponential scaling of the matrix and vector sizes for classical algorithms, like the Full Configuration Interaction (FCI) method. This aspect grows into a bigger issue as we move on to more complete basis sets, and this is one of the reasons why quantum chemistry is so complicated. This is a textbook example where a problem decomposition like UHF-DMET could shine.\nThe remaining part of this notebook shows how UHF-DMET can be used in Tangelo. In the next cell, we build a \\(\\text{LiO}_2\\) molecule object with the cc-pvdz basis set, using a UHF mean-field calculation (by setting the uhf argument to True).\n\nfrom tangelo import SecondQuantizedMolecule\n\nLiO2 = [\n    (\"Li\", (0., 0., 1.380605)),\n    (\"O\", (0., 0.676045, -0.258863)),\n    (\"O\", (0., -0.676045, -0.258863))\n]\nmol_lio2 = SecondQuantizedMolecule(LiO2, q=0, spin=1, basis=\"cc-pvdz\", frozen_orbitals=None, uhf=True)\n\nBy looking at the the n_active_ab_electrons and active_mos properties, we can confirm that an unrestricted self-consistent field has been generated. The alpha and beta spin orbitals are treated separately, therefore the orbitals properties are grouped in pairs, where the first (resp. last) element of the tuple refers to the alpha (resp. beta) spin orbitals.\n\nn_alpha, n_beta = mol_lio2.n_active_ab_electrons\nmos_alpha, mos_beta = mol_lio2.active_mos\n\nprint(f\"{n_alpha} alpha electrons in {len(mos_alpha)} molecular orbitals.\")\nprint(f\"{n_beta} beta electrons in {len(mos_beta)} molecular orbitals.\")\n\n10 alpha electrons in 42 molecular orbitals.\n9 beta electrons in 42 molecular orbitals.\n\n\nAt the time of writing, only CCSDSolver, where CCSD refers to coupled-cluster singles and doubles, supports an unrestricted mean field in Tangelo. Since calculating the ground state of \\(\\text{LiO}_2\\) in the cc-pVDZ basis set with FCI is challenging (and even might be not possible) for most supercomputers, we use CCSD for the reference calculations.\n\nfrom tangelo.algorithms.classical import CCSDSolver\n\nccsd = CCSDSolver(mol_lio2)\ne_ccsd = ccsd.simulate()\nprint(f\"Mean-field energy: {mol_lio2.mf_energy} Ha\")\nprint(f\"Unrestricted CCSD energy: {e_ccsd} Ha\")\n\nMean-field energy: -157.10964086805075 Ha\nUnrestricted CCSD energy: -157.4899499964378 Ha\n\n\nNext, we define the DMET options and perform the simulation. - The molecular orbitals were localized via natural atomic orbitals (NAO); - DMET fragments are defined to contain 1 atom each; - The CCSD solver is used for every fragment.\n\nfrom tangelo.problem_decomposition.dmet import Localization\nfrom tangelo.problem_decomposition import DMETProblemDecomposition\n\nopt_dmet = {\"molecule\": mol_lio2,\n            \"fragment_atoms\": [1, 1, 1],\n            \"fragment_solvers\": \"ccsd\",\n            \"electron_localization\": Localization.nao,\n            \"virtual_orbital_threshold\": 1e-13,\n            \"verbose\": False\n            }\n\ndmet_solver = DMETProblemDecomposition(opt_dmet)\ndmet_solver.build()\ne_dmet_ccsd = dmet_solver.simulate()\nprint(f\"Unrestricted DMET-CCSD energy: {e_dmet_ccsd} Ha\")\nprint(f\"Difference vs the unrestricted CCSD: {abs(e_ccsd - e_dmet_ccsd):.4f} Ha\")\n\nUnrestricted DMET-CCSD energy: -157.47151520319153 Ha\nDifference vs the unrestricted CCSD: 0.0184 Ha\n\n\nUHF-DMET here retrieves most of the correlation energy (0.36 Ha). This method requires considerably less resources than approaching the full system head on. We have turned a 42 MOS + 19 electrons electronic structure calculation into 3 smaller problems of 28 MOS + 15 (or 17) electrons. Assuming an occupation mapping such as the Jordan-Wigner transformation, it would mean a reduction from 84 qubits to 56.\nThis decomposition scheme comes at the cost of introducing an error of about 0.018 Ha when comparing to the full-molecule CCSD calculation. This is caused by a virtual orbital space truncation step done during the DMET fragment construction. This feature can be turned off by setting the virtual_orbital_threshold to 0 (default is \\(1\\times10^{-13}\\)), at the expense of a significant increase in the computational cost of the DMET calculation. On another note, when this DMET error is more or less constant across a set of calculations (this could be a reasonable statement for the same class of molecule with similar fragmentation), this is revealed to be a powerful tool for reducting computational cost.\nThe last calculation has been made with a given geometry for the nuclei. If one is interested in the formation of \\(\\text{LiO}_2\\), as described earlier in this notebook, the approach of a \\(\\text{Li}\\) atom towards an \\(\\text{O}_2\\) molecule should be modelled. As a consequence, geometry changes would be a necessary component of the study.\nThe data below displays the energies of different \\(\\text{LiO}_2\\) geometries by varying the \\(\\text{Li}\\)-\\(\\text{O}_2\\) distance. Here unrestricted CCSD refers to the calculation of CCSD with an unrestricted mean-field starting point.\n\nfrom io import StringIO\nimport pandas as pd\n\ndata = \"\"\"\nr, Unrestricted CCSD, UHF, ROHF, UHF-DMET+CCSD\n0.8, -156.77290395144,  -156.407069154552, -156.395663251967, -156.760717950373\n1.0, -157.181626088186, -156.813883767609, -156.802127699106, -157.163705479905\n1.2, -157.377673286621, -157.00703363169,  -156.99505890766,  -157.360034403805\n1.4, -157.459368788708, -157.086059337141, -157.07401601092,  -157.44244444947\n1.6, -157.484607625707, -157.108840759645, -157.096849245497, -157.466961019203\n1.8, -157.483616469896, -157.105696261544, -157.093842156837, -157.466603459799\n2.0, -157.471129533643, -157.091589272408, -157.079928235107, -157.457900669265\n2.2, -157.454061938212, -157.073591742696, -157.062157197992, -157.443997798073\n2.4, -157.435670655538, -157.054932359744, -157.043743505371, -157.428861609471\n2.6, -157.417467388055, -157.036982535102, -157.026047930188, -157.414458252749\n2.8, -157.400122479842, -157.0202427614,   -157.009560505402, -157.405471025456\n\"\"\"\n\ndf = pd.read_table(StringIO(data), sep=\",\", skipinitialspace=True)\ndf.plot(x=\"r\", y=[\"Unrestricted CCSD\", \"UHF\", \"ROHF\", \"UHF-DMET+CCSD\"], xlabel=\"Li-O2 distance / Angstrom\", ylabel=\"Energy / Ha\")\n\n&lt;AxesSubplot: xlabel='Li-O2 distance / Angstrom', ylabel='Energy / Ha'&gt;\n\n\n\n\n\nWe are getting most of the correlation energy with the UHF-DMET on the full span of the configurational space. We can also see from this plot the lower energy given by an unrestricted mean-field calculation (vs restricted). We show in the next section how one can leverage this problem decomposition method to efficiently map the \\(\\text{LiO}_2\\) molecule on a (or many) quantum computer(s)."
  },
  {
    "objectID": "examples/problem_decomposition/dmet_uhf.html#what-about-the-quantum-algorithms",
    "href": "examples/problem_decomposition/dmet_uhf.html#what-about-the-quantum-algorithms",
    "title": "Applying Unrestricted Density-Matrix Embedding Theory to battery chemistry",
    "section": "What about the Quantum Algorithms?",
    "text": "What about the Quantum Algorithms?\nUp until this section, the discussion revolved around solving the Schrödinger equation for the \\(\\text{LiO}_2\\) molecule in the cc-pVDZ basis set using UHF-DMET (and CCSD). As mentionned in the introduction, UHF-DMET is one of many tools that scientists have to reduce computational cost of a quantum chemistry calculation.\n\nResource estimation\nWe shown in the previous section that a reduction of 84 qubits to 56 was possible when working in the cc-pVDZ basis set. However, working with this many qubits would require the accurate computation of expectation values (within 1 mHa) on deep quantum circuits.\nThis is one of the reason quantum chemistry calculation on NISQ devices are often done using a minimal basis set, like sto-3g or minao. As most of the experiments serve as proofs of concept, scaling up problem size will occur accordingly to quantum hardware development. We show in the next cell a resource estimation for a DMET fragment mapping on quantum hardware, using the sto-3g basis set and the variational quantum eigensolver (VQE).\n\nfrom pprint import pprint\nfrom tangelo.algorithms.variational import BuiltInAnsatze, VQESolver\n\nmol_lio2 = SecondQuantizedMolecule(LiO2, q=0, spin=1, basis=\"sto-3g\", frozen_orbitals=None, uhf=True)\n\nopt_vqe = {\"molecule\": mol_lio2,\n           \"qubit_mapping\": \"JW\", \n           \"up_then_down\": True, \n           \"ansatz\": BuiltInAnsatze.QCC,\n}\nvqe_solver = VQESolver(opt_vqe)\nvqe_solver.build()\nprint(\"Full VQE quantum resources:\")\npprint(vqe_solver.get_resources())\n\nopt_dmet = {\"molecule\": mol_lio2,\n            \"fragment_atoms\": [1, 1, 1],\n            \"fragment_solvers\": [\"vqe\", \"ccsd\", \"ccsd\"],\n            \"solvers_options\": [{\"qubit_mapping\": \"JW\", \"up_then_down\": True, \"ansatz\": BuiltInAnsatze.QCC}, None, None],\n            \"electron_localization\": Localization.nao,\n            \"virtual_orbital_threshold\": 1e-13,\n            \"verbose\": False\n            }\n\ndmet_solver = DMETProblemDecomposition(opt_dmet)\ndmet_solver.build()\nprint(\"\\nDMET-VQE quantum resources:\")\npprint(dmet_solver.get_resources()[0])\n\nFull VQE quantum resources:\n{'circuit_2qubit_gates': 3804,\n 'circuit_depth': 2965,\n 'circuit_var_gates': 694,\n 'circuit_width': 30,\n 'qubit_hamiltonian_terms': 20548,\n 'vqe_variational_parameters': 694}\n\nDMET-VQE quantum resources:\n{'circuit_2qubit_gates': 978,\n 'circuit_depth': 848,\n 'circuit_var_gates': 203,\n 'circuit_width': 20,\n 'qubit_hamiltonian_terms': 6397,\n 'vqe_variational_parameters': 203}\n\n\nThe resource for a single DMET fragment, corresponding to the \\(\\text{Li}\\) atom, are in the order of 20 qubits and 6367 Hamiltonian terms (with a Jordan-Wigner qubit mapping). Versus the full VQE problem, this is a 33% and a 69% improvement in terms of the number of required qubits and Hamiltonian terms, respectively. This also yields a shallower circuit, with fewer variational parameters: a complete discussion on this topic depends on the ansatz choice.\n\n\nTrade-off between energy accuracy and virtual orbital truncation in DMET fragments\nWe briefly touched the virtual_orbital_threshold parameter earlier when we discussed the DMET energy error. This discussion is even more relevant when constructing quantum circuits, as we work with minimal basis sets to restrain the number of qubits. Changing the virtual_orbital_threshold while dealing with smaller basis sets can have a significant impact on the DMET energy, as shown in the table below. This is due to the truncation of a few virtual orbitals having proportionally greater impact on small virtual orbital spaces than on larger ones.\n\n\n\n\n\n\n\n\nTruncation threshold\nProblem size (number of qubits)\nDMET error vs full CCSD (Ha)\n\n\n\n\n\\(0\\)\n\\(20\\)\n\\(0.011\\)\n\n\n\\(10^{-2}\\)\n\\(18\\)\n\\(0.034\\)"
  },
  {
    "objectID": "examples/problem_decomposition/dmet_uhf.html#closing-words",
    "href": "examples/problem_decomposition/dmet_uhf.html#closing-words",
    "title": "Applying Unrestricted Density-Matrix Embedding Theory to battery chemistry",
    "section": "Closing Words",
    "text": "Closing Words\nWe have demonstrated the use of UHF-DMET via the modelling of the \\(\\text{LiO}_2\\) formation. DMET reduces the computational resource requirements at the cost of adding a new potential source of error induced by the fragmentation. However, if the DMET error is constant for two different calculations, the agreement with experiment can be good as energy differences are all that can be measured in laboratories.\nThis resource reduction is welcome when simulating chemical problems on NISQ devices. One should be aware of unanswered questions when using DMET (regardless of the flavour, with UHF or not): - How to build accurate shallow ansatze for DMET fragments, to further reduce circuit depth compared to the full molecular problem? - Is the measurement problem avoidable? We need to design an efficient way to extract the 2-body Reduced Density Matrices (RDMs) from each fragment solver. - How resilient is DMET to statistical and physical noise, leading in particular to noisy 2-RDM data?\nTangelo may help you answer some of these questions. Its DMET framework facilitates the exploration of many ansatze, measurement reduction and noisy performance of quantum algorithms. The rest is up to you !"
  },
  {
    "objectID": "examples/problem_decomposition/mifno.html",
    "href": "examples/problem_decomposition/mifno.html",
    "title": "Exploring the Method of Increments with QEMIST Cloud and Tangelo",
    "section": "",
    "text": "Open In Colab\nIn this notebook, we illustrate how users can leverage QEMIST Cloud and Tangelo to explore the impact of quantum computing on problems tackled with the MI-FNO problem decomposition technique.\nYou do not need to have the qemist-client python package installed to run this notebook: only tangelo is required. For more information about QEMIST Cloud (installation, features, issues, qemist_client API…), please refer to the QEMIST Cloud documentation or contact their development team.\nThe first section provides a high-level description of the MI-FNO approach. The second one briefly shows how QEMIST Cloud can apply this approach to a usecase, and provide reference results computed with high-accuracy classical solvers. We then focus on the API provided in Tangelo allowing users to combine the MI-FNO performed by QEMIST Cloud and any quantum workflow written with Tangelo.\nThis notebook assumes that you already have installed Tangelo in your Python environment, or have updated your Python path so that the imports can be resolved. If not, executing the cell below installs the minimal requirements for this notebook.\n# Installation of tangelo if not already installed.\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet\n\n# Download the data folder at https://github.com/goodchemistryco/Tangelo-Examples/tree/main/examples/problem_decomposition/data\nimport os\nif not os.path.isdir(\"data\"):\n    !sudo apt install subversion\n    !svn checkout https://github.com/goodchemistryco/Tangelo-Examples/branches/main/examples/problem_decomposition/data"
  },
  {
    "objectID": "examples/problem_decomposition/mifno.html#use-case",
    "href": "examples/problem_decomposition/mifno.html#use-case",
    "title": "Exploring the Method of Increments with QEMIST Cloud and Tangelo",
    "section": "Use case",
    "text": "Use case\nOur use case here is the hydrogen fluoride (HF) system defined below, using the sto-3g basis, chosen for simplicity. However, the MI-FNO method can be used to tackle much larger systems.\n\nHF_coordinates = \"\"\"\n    F    0.0000   0.0000   0.0000\n    H    0.0000   0.0000   0.9168\n\"\"\"\nbasis = \"sto-3g\"\ncharge = 0 \nspin = 0"
  },
  {
    "objectID": "examples/problem_decomposition/mifno.html#what-is-mi-fno",
    "href": "examples/problem_decomposition/mifno.html#what-is-mi-fno",
    "title": "Exploring the Method of Increments with QEMIST Cloud and Tangelo",
    "section": "What is MI-FNO ?",
    "text": "What is MI-FNO ?\nThe method of increment (MI) expresses the electron correlation energy of a molecular system as a truncated many-body expansion in terms of orbitals, atoms, molecules, or fragments. The electron correlation of the system is expanded in terms of occupied orbitals, and MI is employed to systematically reduce the occupied orbital space. At the same time, the virtual orbital space is reduced based on the frozen natural orbitals (FNO), which are obtained using a one-particle density matrix from second-order, many-body perturbation theory. In this way, a method referred to as the MI-FNO approach is available for the systematic reduction of both the occupied space and the virtual space in quantum chemistry simulations.\nMI was first introduced in quantum chemistry by Nesbet (Phys. Rev. 1967, 155, 51, Phys. Rev. 1967, 155, 56 and Phys. Rev. 1968, 175, 2), is based upon the n-body Bethe–Goldstone expansion (Proc. R. Soc. A, 1957, 238, 551) of the correlation energy of a molecule. The correlation energy (\\(E_c\\)), defined as the difference between the exact (\\(E_{\\text{exact}}\\)) and the Hartree–Fock (mean-field) energy (\\(E_{\\text{HF}}\\)), can be expanded as\n\\[\n\\begin{align*}\nE_c &= E_{\\text{exact}} - E_{\\text{HF}} \\\\\n&= \\sum_i \\epsilon_i + \\sum_{i&gt;j} \\epsilon_{ij} + \\sum_{i&gt;j&gt;k} \\epsilon_{ijk} + \\sum_{i&gt;j&gt;k&gt;l} \\epsilon_{ijkl} + \\dots\n\\end{align*}\n\\]\nwhere \\(\\epsilon_i\\), \\(\\epsilon_{ij}\\), \\(\\epsilon_{ijk}\\), and \\(\\epsilon_{ijkl}\\) are, respectively, the one-, two-, three-, and four-body increments (expansions) defined as\n\\[\n\\begin{align*}\n\\epsilon_i &= E_c(i) \\\\\n\\epsilon_{ij} &= E_c(ij) - \\epsilon_i - \\epsilon_j \\\\\n\\epsilon_{ijk} &= E_c(ijk) - \\epsilon_{ij} - \\epsilon_{ik} - \\epsilon_{jk} - \\epsilon_{i} - \\epsilon_{j} - \\epsilon_{k} \\\\\n\\epsilon_{ijkl} &= E_c(ijkl) - \\epsilon_{ijk} - \\epsilon_{ijl} - \\epsilon_{jkl} - \\dots \\\\\n&\\vdots\n\\end{align*}\n\\]\nThe following figure, taken from J. Chem. Phys. 2021, 155, 034110, illustrates this problem decomposition scheme in terms of 1-body and many-body interactions. On each subproblem, an FNO truncation is applied to reduce their virtual space. The subproblems resulting from the MI-FNO reduction can then be solved by any algorithm, including quantum algorithms such as the phase estimation algorithm and the variational quantum eigensolver (VQE), to predict the correlation energies of a molecular system.\n\n\n\nThis problem decomposition pipeline is available in QEMIST Cloud. In this notebook, we illustrate how to export MI-FNO fragment data computed in QEMIST Cloud, and import it in Tangelo for further treatment, such as using quantum solvers."
  },
  {
    "objectID": "examples/problem_decomposition/mifno.html#performing-mi-fno-calculations-with-qemist-cloud",
    "href": "examples/problem_decomposition/mifno.html#performing-mi-fno-calculations-with-qemist-cloud",
    "title": "Exploring the Method of Increments with QEMIST Cloud and Tangelo",
    "section": "Performing MI-FNO calculations with QEMIST Cloud",
    "text": "Performing MI-FNO calculations with QEMIST Cloud\nQEMIST Cloud is an engine that enables faster, more accurate, and scalable ways to perform computational chemistry simulations. This platform leverages easily and readily accessible computers on the cloud to perform chemistry simulations that were previously intractable even on expensive, high-performance computing environments.\nIn order to leverage this platform to perform the MI-FNO calculations, subscribing to the services and installing the qemist_client python package is necessary. This notebook does not require either of these things: we provide the code snippet used to generate the problem decomposition results, and use those as pre-computed values for the rest of the notebook.\nFor more information about QEMIST Cloud (installation, features, issues, qemist_client API…), please refer to the QEMIST Cloud documentation or contact their development team.\nIn the script below, each fragment’s virtual space is truncated to keep only the virtual orbitals with the highest occupation number. MI-FNO is paired with the Heath-Bath Configuration Interaction (HBCI) classical solver.\nimport os\nos.environ['QEMIST_PROJECT_ID'] = \"your_project_id_string\"\nos.environ['QEMIST_AUTH_TOKEN'] = \"your_qemist_authentication_token\"\n\nfrom qemist_client.molecule import Molecule\nfrom qemist_client.problem_decomposition import IncrementalDecomposition\nfrom qemist_client.problem_reduction import FNO\nfrom qemist_client.electronic_structure_solvers import HBCI\nfrom qemist_client.util import get_results\n\nHF_coordinates = \"\"\"\n    F    0.0000   0.0000   0.0000\n    H    0.0000   0.0000   0.9168\n\"\"\"\nbasis = \"sto-3g\"\ncharge = 0\nspin = 0\n\n# Creating the QEMIST molecule object.\nHF_mol = Molecule(HF_coordinates, basis=basis, \n                  charge=charge, spin=spin)\n\n# Defining the solvers, Heath-Bath Configuration Interaction (HBCI),\n# Frozen Natural Orbitals (FNO), and the problem decomposition approach,\n# Method of Increments (MI).\nhbci_solver = HBCI()\nfno = FNO(hbci_solver, export_fragment_data=True)\nmi_solver = IncrementalDecomposition(solver=fno, truncation_order=3)\n\n# Submitting the problem to the cloud.\nHF_handle = mi_solver.simulate(molecule=HF_mol)\nprint(f\"\\nHF handle: {HF_handle}\")\n\n# Retrieving the results.\nHF_result = get_results(HF_handle)\nprint(HF_result)\nThe HF_result python dictionary can be saved in a json file (for further treatment in Tangelo or for archiving purposes) with the following code.\nimport json\nwith open(\"your_file_path\", \"w\") as f:\n    json.dump(HF_result, f)\n\nfor n__trunc, frags in HF_result[\"subproblem_data\"].items():\n    for frag_id, frag in frags.items():\n        prob_handle = frag[\"problem_handle\"]\n\n        if problem_handle:\n            frag_res = get_results(prob_handle)\n\n            with open(f\"your_folder_path\"/{prob_handle}.json\", \"w\") as f:\n                json.dump(frag_res, f)"
  },
  {
    "objectID": "examples/problem_decomposition/mifno.html#combining-quantum-algorithms-with-mi-fno-using-tangelo",
    "href": "examples/problem_decomposition/mifno.html#combining-quantum-algorithms-with-mi-fno-using-tangelo",
    "title": "Exploring the Method of Increments with QEMIST Cloud and Tangelo",
    "section": "Combining quantum algorithms with MI-FNO using Tangelo",
    "text": "Combining quantum algorithms with MI-FNO using Tangelo\nIn the future, pairing problem decomposition techniques such as MI-FNO with quantum solvers running in the cloud could be streamlined in QEMIST Cloud, which could directly call the solvers available in Tangelo.\nBut we think quantum hardware and quantum algorithm development has a bit of a way to go before this can be seen as a practical approach. However, we can manually explore how to combine MI-FNO with quantum solvers right now, in order to explore use cases intractable otherwise: maybe our discoveries can contribute in advancing the field, and bring that future a bit sooner.\nThis section illustrates how Tangelo can retrieve the results from a MI-FNO job run in QEMIST Cloud, and enable our quantum explorations.\n\n1. Importing results from QEMIST Cloud\nIn Tangelo, the MIFNOHelper class facilitates importing the results generated by QEMIST Cloud, in our case contained in the HF_result object.\n\nfrom tangelo.problem_decomposition import MIFNOHelper\n\nMIFNOHelper can either directly take a “results” object in json format produced by QEMIST Cloud (using results_object=...), or the path to a file containing that object (using json_file=...). In our example, let’s just assume HF_results has been saved in ../data/HF_MIFNO_trunc2.json and let’s see what information has been retrieved.\n\nfno_fragments = MIFNOHelper(mi_json_file=\"./data/HF_STO3G_MIFNO_HBCI.json\", fno_json_folder=\"./data\")\nprint(fno_fragments)\n\n(All the energy values are in hartree)\nTotal MI-FNO energy = -98.59655271223816\nCorrelation energy = -0.025795120623911316\nMean-field energy = -98.57075759161424\n              problem_handle   epsilon  energy_correlation  correction  \\\n(1,)       65652562505002413 -0.001326           -0.001326         0.0   \n(2,)       10837505518890413 -0.019846           -0.019846         0.0   \n(3,)       31462118862908845 -0.000862           -0.000862         0.0   \n(4,)       49501973643554221 -0.000756           -0.000756         0.0   \n(1, 2)     65302015864237516 -0.003024           -0.024195         0.0   \n(1, 3)     53405772498103756  0.000085           -0.002102         0.0   \n(1, 4)     13411621153304012  0.000142           -0.001939         0.0   \n(2, 3)     22700772126125516 -0.000845           -0.021553         0.0   \n(2, 4)     27549614109650380  0.000124           -0.020477         0.0   \n(3, 4)     23150438022147532  0.000078           -0.001540         0.0   \n(1, 2, 3)  30910159730798073  0.000466           -0.025351         0.0   \n(1, 2, 4)  13137250052500985 -0.000016           -0.024701         0.0   \n(2, 3, 4)  17864205159132665 -0.000017           -0.022123         0.0   \n\n           energy_total  \n(1,)         -98.572083  \n(2,)         -98.590604  \n(3,)         -98.571619  \n(4,)         -98.571513  \n(1, 2)       -98.594953  \n(1, 3)       -98.572860  \n(1, 4)       -98.572697  \n(2, 3)       -98.592310  \n(2, 4)       -98.591235  \n(3, 4)       -98.572297  \n(1, 2, 3)    -98.596109  \n(1, 2, 4)    -98.595458  \n(2, 3, 4)    -98.592881  \n\n\nIt parsed information contained in the “result blob” from QEMIST Cloud. We see that there is information about the whole system, including the mean-field energy and the total energy, as well as how each of the fragment -denoted by a tuple of integers- contributed to the correlation energy.\nAlthough not displayed here, the object also contains information about the frozen orbitals used for each of these fragments (“frozen lists”).\n\n\n2. Importing molecular coefficients files\nIn order to build a FermionOperator or QubitOperator object compatible with our quantum algorithms, we can retrieve the MO coeffs exported by QEMIST Cloud. The “result blob” contains a URL where these are located, for each fragment: the retrieve_mo_coeff method downloads them in the target directory provided by the user, and then loads the MO coeffs into the MIFNOHelper object.\n\nThe default target folder is the folder where the user script is executed.\nIf the user does not provide a path to a valid existing directory, the call returns an error.\nIf the files already exists in the target directory, they are not re-downloaded. The method keeps the user informed of progress as it is downloading files, otherwise it prints nothing.\n\n\nfno_fragments.retrieve_mo_coeff(\"./data\")\n\n\n\n3. Reconstructing a fragment Hamiltonian\nWe can use the MO coeffs to modify the molecular integrals, in order to take into account the FNO localization, using our “frozen lists”.\nThe compute_fermionoperator method handles the frozen orbitals for each fragment, and produces a FermionOperator. We are free to use the qubit mapping of our choice to produce a QubitOperator object, as input for a quantum algorithm.\n\nfrom tangelo import SecondQuantizedMolecule\nfrom tangelo.toolboxes.operators import count_qubits\nfrom tangelo.toolboxes.qubit_mappings.mapping_transform import fermion_to_qubit_mapping\n\n# Needed to compute the molecular integrals.\nmol = SecondQuantizedMolecule(HF_coordinates, q=charge, spin=spin, basis=basis)\n\n# Selection of a fragment and fetching the number of electrons and spinorbitals.\nselected_fragment = \"(1,)\"\nn_electrons, n_spinorbitals = fno_fragments.n_electrons_spinorbs(selected_fragment)\n\n# Computing the related FermionOperator.\nferm_op = fno_fragments.compute_fermionoperator(mol, selected_fragment)\n\n# Transformation of the FermionOperator to a QubitOperator.\nqu_op = fermion_to_qubit_mapping(ferm_op, mapping=\"JW\", up_then_down=False)\n\nprint(f\"Fragment {selected_fragment} mapped to {count_qubits(qu_op)} qubits.\")\n\nFragment (1,) mapped to 4 qubits.\n\n\n\n\n4. Do your thing !\nNow that we are able to construct FermionOperator and QubitOperator objects representing the subproblems defined by our fragments, we are free to throw them at any algorithm available in Tangelo. You could even decide to use your own custom workflow instead. Each fragment that is relevant to you could be solved with a different quantum solver, if you wish to do so.\nBelow, we treat a given fragment with Quantum Imaginary Time Evolution (QITE) to obtain its energy. We made sure to enter values for n_electrons and n_spinorbitals that are consistent with our MI-FNO parameters.\nThis code cell can take several minutes to execute. After its execution, the value of qite.final_energy should be about -98.57208.\n\nfrom tangelo.algorithms.projective import QITESolver\nfrom tangelo.toolboxes.operators import qubitop_to_qubitham\n\nqubit_ham = qubitop_to_qubitham(qu_op, mapping=\"JW\", up_then_down=False)\n\nqite = QITESolver({\"qubit_hamiltonian\": qubit_ham, \"n_electrons\": n_electrons, \"n_spinorbitals\": n_spinorbitals})\nqite.build()\nqite.simulate()\n\nIteration 1 of QITE with starting energy -98.57075759161438\nIteration 2 of QITE with starting energy -98.57113742411626\nIteration 3 of QITE with starting energy -98.57140787803424\nIteration 4 of QITE with starting energy -98.57160051304115\nIteration 5 of QITE with starting energy -98.5717377800637\nIteration 6 of QITE with starting energy -98.5718356478243\nIteration 7 of QITE with starting energy -98.57190547369781\nIteration 8 of QITE with starting energy -98.57195533540128\nIteration 9 of QITE with starting energy -98.57199097845572\nIteration 10 of QITE with starting energy -98.57201649005955\nIteration 11 of QITE with starting energy -98.57203477827191\nIteration 12 of QITE with starting energy -98.57204791270738\nIteration 13 of QITE with starting energy -98.57205736674561\nIteration 14 of QITE with starting energy -98.57206418972217\nIteration 15 of QITE with starting energy -98.57206912934107\nIteration 16 of QITE with starting energy -98.57207271870293\nIteration 17 of QITE with starting energy -98.57207533818271\nIteration 18 of QITE with starting energy -98.57207725942834\nIteration 19 of QITE with starting energy -98.57207867665228\nIteration 20 of QITE with starting energy -98.57207972888882\nIteration 21 of QITE with starting energy -98.5720805158298\nIteration 22 of QITE with starting energy -98.5720811090937\nIteration 23 of QITE with starting energy -98.57208156024942\nIteration 24 of QITE with starting energy -98.5720819065301\nIteration 25 of QITE with starting energy -98.57208217490502\nIteration 26 of QITE with starting energy -98.57208238498288\nIteration 27 of QITE with starting energy -98.57208255108415\nIteration 28 of QITE with starting energy -98.57208268372021\nIteration 29 of QITE with starting energy -98.57208279065223\nFinal energy of QITE is -98.57208287764851\n\n\n-98.57208287764851\n\n\n\n\n5. Recomputing the total energy of the system\nIn order to assess the impact of quantum workflows applied to one or several fragments on the total energy of the system, the helper class provides a mi_summation method. This class recomputes the total energy of the system, using the reference values obtained classically by QEMIST Cloud, or instead using the values obtained by your quantum workflows for the fragments you specify. This summation was described by the formulas in the first section of this notebook.\nIf no argument is passed to mi_summation, then only reference values are used in the summation, which should then be in agreement (up to machine precision) with fno_fragments.e_tot, originally read from the QEMIST Cloud result blob.\nOtherwise, passing a dictionary using fragment labels as keys and the energy as the corresponding values does the trick. For these fragments, MP2 correction is automatically added, and a new total energy is computed.\nThe difference between this new total energy and the reference total energy gives you a measure of the accuracy and the impact of combining quantum workflows with classical calculations performed with MI-FNO.\n\ne = fno_fragments.mi_summation({\"(1,)\": qite.final_energy})\nprint(f\"Reconstructed energy: {e}\\nMIFNO QEMIST Cloud energy: {fno_fragments.e_tot}\\nDifference: {abs(e-fno_fragments.e_tot)}\")\n\nReconstructed energy: -98.59655271223812\nMIFNO QEMIST Cloud energy: -98.59655271223816\nDifference: 4.263256414560601e-14"
  },
  {
    "objectID": "examples/problem_decomposition/mifno.html#closing-words",
    "href": "examples/problem_decomposition/mifno.html#closing-words",
    "title": "Exploring the Method of Increments with QEMIST Cloud and Tangelo",
    "section": "Closing words",
    "text": "Closing words\nThis feature allows us to bring together the state-of-the-art MI-FNO problem decomposition schemes available at scale in QEMIST cloud, and quantum workflows written with Tangelo. It facilitates exploring larger, more industrially-relevant use cases with a combination of classical and quantum workflows of your choice, on subproblems that are more ammenable to current devices.\nFor now, this exploration is manual, as we believe the current state of the field does not benefit from a fully automated and streamlined platform… yet! In the future, platforms such as QEMIST Cloud will be able to directly use Tangelo to run entire workflows on cloud infrastructure, using both quantum and classical devices.\nMaybe your discoveries can contribute to advancing the field, and bring that future a bit sooner.\nWhat will you do with Tangelo?"
  },
  {
    "objectID": "examples/problem_decomposition/oniom.html",
    "href": "examples/problem_decomposition/oniom.html",
    "title": "ONIOM Problem Decomposition - A use case for an acetic acid molecule in water",
    "section": "",
    "text": "Open In Colab"
  },
  {
    "objectID": "examples/problem_decomposition/oniom.html#table-of-contents",
    "href": "examples/problem_decomposition/oniom.html#table-of-contents",
    "title": "ONIOM Problem Decomposition - A use case for an acetic acid molecule in water",
    "section": "Table of contents:",
    "text": "Table of contents:\n\n1. Introduction\n2. Use case - an acetic acid molecule in water\n\n2.1 Why is solvent interaction a relevant scientific problem?\n2.2 Why use ONIOM?\n2.3 How is it done?\n2.4 Potential energy scan for an hydrogen bond\n\n3. Closing words"
  },
  {
    "objectID": "examples/problem_decomposition/oniom.html#introduction",
    "href": "examples/problem_decomposition/oniom.html#introduction",
    "title": "ONIOM Problem Decomposition - A use case for an acetic acid molecule in water",
    "section": "1. Introduction ",
    "text": "1. Introduction \nThis notebook provides an overview of our implementation of the ONIOM method (Chem. Rev. 2015, 115, 12, 5678–5796), a hybrid QM/MM technique. The ONIOM method enables the user to leverage the accuracy of computationally-expensive chemistry methods, only where expressly necessary, thus enabling us to investigate the applicability of quantum algorithms to more industrially-relevant problems.\nWhen studying large molecules, and their interactions with other systems, the use of computationally-expensive techniques is often not only intractable, but also unnecessary. For example, when considering the interaction between a water molecule and a functional group appended to a large graphite flake, it is not reasonable to attempt to treat this entire system at the level of something like Full Configuration Interaction (FCI) or Coupled Cluster methods (ex: CCSD(T)). In such situations, the ONIOM method enables us to target the fragments of the problem at hand with the most sophisticated techniques we can afford, while relegating the rest of the problem to more affordable computational methods. This method can become particularly advantageous when we are interested in energy differences, where the contribution to the total molecular energy from the relatively inert volumes becomes negligible.\nFormally, the energy evaluated by ONIOM (with a low- and high-accuracy methods) is expressed as:\n\\[E_{\\text{ONIOM}} = E_{\\text{All}}^{\\text{Low}} + \\sum_{i=1}^N (E_{\\text{Fragment}_i}^{\\text{High}} - E_{\\text{Fragment}_i}^{\\text{Low}})\\]\nWhere \\(E_{\\text{All}}\\), \\(E_{\\text{Fragment}_i}\\) are respectively the energy of the whole system and the energy of a fragment labelled \\(i\\). The general procedure for ONIOM is as follows. The user identifies a system of interest and a low-cost method is used to compute its total energy (\\(E_{\\text{All}}^{\\text{Low}}\\)). Subsequently, a subset of the molecule is defined as a model fragment and it is isolated by using an atom (or a functional group) to keep the valence shell fully populated. \\(E_{\\text{Fragment}_i}^{\\text{Low}}\\) is computed for the fragment using the same low-cost method as used initially for the whole system, and a high-cost method (\\(E_{\\text{Fragment}_i}^{\\text{High}}\\)). The difference in energy between the high-cost and low-cost methods (\\(E_{\\text{Fragment}_i}^{\\text{High}} - E_{\\text{Fragment}_i}^{\\text{Low}}\\)) is then added to our total energy. This way, we can interpret the ONIOM method as an iterative procedure where the error associated with our low-cost solver is removed.\nThe equation above is formulated to allow us to expand ONIOM beyond a single fragment. In principle, many such fragments can be defined to progressively improve the accuracy or efficiency of the calculations. This may apply to when we have more than one active site on our large molecule, or where an incremental strategy can be utilized to further mitigate errors associated with using our low-cost method in the vicinity of our active region.\nThis notebook assumes that you already have installed Tangelo in your Python environment, or have updated your Python path so that the imports can be resolved. If not, executing the cell below installs the minimal requirements for this notebook.\n\n# Installation of tangelo if not already installed.\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet"
  },
  {
    "objectID": "examples/problem_decomposition/oniom.html#use-case---an-acetic-acid-molecule-in-water",
    "href": "examples/problem_decomposition/oniom.html#use-case---an-acetic-acid-molecule-in-water",
    "title": "ONIOM Problem Decomposition - A use case for an acetic acid molecule in water",
    "section": "2. Use case - an acetic acid molecule in water",
    "text": "2. Use case - an acetic acid molecule in water\n\n2.1 Why are solvent interactions a relevant scientific problem?\nNew technologies are in need of scientific insights on the interaction of molecules with a solvent. As illustrated below, many applications would benefit from these insights. The first example is the catalyst development for chemical reactions in liquids. Considering solvent molecules can improve the simulation accuracy, thus improving the acquired knowledge. Another predominant problem for water accessibility is its desalination. If a compound is able to selectively retain salt molecules and no other chemical entity, one could perform purification and thus convert saline water into potable water. Lastly, it is known that the solvent plays an important role to facilitate the protein-drug binding process. The accurate description of the solvent environment for the protein-ligand complex would give us a better understanding of the binding process, which could help us identify better drug candidates (more details can be found in section 9.1.1 of Chem. Rev. 2015, 115, 12, 5678–5796).\n\n\n\nSolvation problems\n\n\nAll of these problems can be approached from a bottom-up perspective, with numerical simulation from different angles. New discoveries are thus accelerated by insights provided by multiscale modeling. In the notebook, we tackle a specific case of an acetic acid molecule interaction with water using ONIOM.\n\n\n2.2 Why use ONIOM? \nA single molecule can be positioned near a chemical group to identify the interaction force and optimal heteroatom-hydrogen distance. One can then decide to add more water molecules, for a more faithful modeling of the target use-case, thus disabling the hydrogen bond by stabilizing the relevant water molecule.\nEven though the system size is very far from the thermodynamic limit, computational resources remain a constraint: using problem decomposition mitigates this issue. With the help of ONIOM, we can target a specific interaction to compute with a high-accuracy method, while considering an environment with a lower-cost electronic structure solver. This addition of a chemical environment can establish an easier link between simulation and experimental results, while keeping compute time practical.\n\n\n2.3 How is it done? \nFor the remaining part of this section, we will see how to combine the Variational Quantum Eigensolver (VQE) with Hartree-Fock (HF) to compute the ground state energy of a water/carboxylic acid system. We will focus our attention on the hydrogen bond between the COOH group and a water molecule, as seen in the figure below. The numbers on the right correspond to the selected atoms via their indices in the coordinates file. Internally, the ONIOMProblemDecomposition solver adds a hydrogen atom between atoms 0 and 1 to preserve the valence bond completeness.\n\nWe want to specifically target the H2O-COOH interaction. We will use the Variational Quantum Eigensolver (VQE) with a Unitary Coupled-Cluster Single and Double excitation (UCCSD) ansatz. The basis set for this fragment is 6-31G(d,p). The rest of the system is simulated using Hartree-Fock (HF) with a minimal basis set (STO-3G).\nFirst, we import the relevant dependencies:\n\nfrom tangelo.problem_decomposition import ONIOMProblemDecomposition\nfrom tangelo.problem_decomposition.oniom import Fragment, Link\nfrom tangelo.algorithms import BuiltInAnsatze as Ansatze\n\nThe next thing to do is to define a geometry and some options for the desired solvers. As a side note, the quantum resources for this subsystem are still too demanding for Noisy Intermediate-Scale Quantum (NISQ) devices. We reduce the amount of resources by freezing molecular orbitals in the system: in our simple case, the fragment has been reduced to a HOMO-LUMO problem. This allows us to use UCC3 as the variational ansatz for VQE, as it is equivalent to UCCSD, but shallower (by removing redundant excitation terms) and can be applied to two-level systems. As progress is made in the development of more capable quantum devices, less agressive resource reduction could be chosen to increase the accuracy, at the cost of more challenging computation.\n\n# Coordinates file\nwith open(\"xyz/water_system.xyz\",'r') as f:\n    xyz = f.read()\n    # Removing first 2 lines (number of atoms and a comment line)\n    xyz = xyz.split(\"\\n\", 2)[2]\n\noptions_low = {\"basis\": \"sto-3g\"}\noptions_high = {\"basis\": \"6-31G**\", \n                \"qubit_mapping\": \"jw\", \n                \"ansatz\": Ansatze.UCC3, \n                \"up_then_down\": True,\n                \"frozen_orbitals\": [i for i in range(76) if i not in (16, 17)]}\n\nIn the next cell, we build the ONIOMProblemDecomposition object from a multi-line string taken from the coordinate file and Fragment objects. Moreover, in our case, a chemical bond is broken: a Link object is also defined by passing the atom ids defining the broken bond.\nNote: The following cell may take a couple minutes to execute, as instantiating the ONIOMProblemDecomposition object in this situation involves HF calculations in the 6-31G** basis set.\n\n# Whole system to be computed with a low-accuracy method (HF, sto-3g)\nsystem = Fragment(solver_low=\"hf\", options_low=options_low, charge=0)\n\n# Fragment to be computed with a high-accuracy method (VQE-UCC3, 6-31G**).\nlinks = [Link(0, 1, 0.709, 'H')]\nmodel = Fragment(solver_low=\"hf\", options_low=options_low,\n                 solver_high=\"vqe\", options_high=options_high,\n                 selected_atoms=[1, 2, 3, 4, 8, 9, 10],\n                 broken_links=links,\n                 charge=0)\n\n# Construction of the ONIOM solver.\noniom_solver = ONIOMProblemDecomposition({\"geometry\": xyz, \"fragments\": [system, model], \"verbose\": True})\n\nWe estimate the amount of quantum resources by calling the get_resources method (this does not require any simulation).\n\nresources = oniom_solver.get_resources()\n\n        Fragment Number : # 2 \n        ------------------------\n        {'qubit_hamiltonian_terms': 27, 'circuit_width': 4, 'circuit_depth': 14, 'circuit_2qubit_gates': 8, 'circuit_var_gates': 3, 'vqe_variational_parameters': 3}\n\n\n\nWe call the simulate method to compute the ONIOM energy:\n\ne_oniom = oniom_solver.simulate()\ne_hf = oniom_solver.fragments[0].mol_low.mf_energy\n\nprint(\"ONIOM Energy: \", e_oniom)\nprint(\"Hartree-Fock Energy: \", e_hf)\n\nONIOM Energy:  -1278.2143431181958\nHartree-Fock Energy:  -1274.4936842154443\n\n\nWe can see that the ONIOM energy is in fact lower than the Hartree-Fock energy. However, we cannot compute the lower-bound energy for the entire system (VQE-UCCSD), as the computational requirements would be too high.\n\n\n2.4 Potential energy scan for an hydrogen bond \nThe ONIOM energy computed in the previous section can be difficult to compare with known validated data. In this case, we can compare the hydrogen bond distance with experimental results. One way of getting this distance is to perform an energy scan on many configurations. We varied the water molecule - carboxylic acid distance from 1.0 to 3.5 angstrom. An energy calculation, with the same parameters as in the previous section, was performed for each of these distances. The minimal energy point should correspond to the experimental hydrogen bond distance for this system.\n\nimport matplotlib.pyplot as plt\n\ndistances = [3.550862922159438, 3.460762889964292, 3.370670305757595, 3.280585783157128, 3.1905100050249016, 3.1004437335081567, 3.0103878218778832, 2.9203432285513977, 2.8303110337833894, 2.740292459636501, 2.650288894007595, 2.5603019197028303, 2.4703333498422166, 2.3803852712588354, 2.29046009807724, 2.20056063836393, 2.1106901777200746, 2.020852585050676, 1.9310524476726847, 1.8412952456882081, 1.7515875795688893, 1.6619374708395822, 1.572354764687664, 1.4828516770284208, 1.3934435500122229, 1.3041499143311708, 1.214996013163829, 1.126015038057959, 1.0372514935327881, 0.9487664078760378, 0.8606456724847144]\nenergies = [-1278.051959731282, -1278.057229408819, -1278.0643608792661, -1278.073141506658, -1278.0833167826524, -1278.0945967737384, -1278.1066656511987, -1278.119193003125, -1278.1316621874737, -1278.1441348500723, -1278.1561527375766, -1278.1674486239667, -1278.1778145272128, -1278.1870878716404, -1278.1951499219097, -1278.201919599394, -1278.2073419570033, -1278.2113710433855, -1278.2139489568763, -1278.214985604411, -1278.2143431181898, -1278.21182121378, -1278.2071290776098, -1278.19982995337, -1278.1892617407693, -1278.1744445322772, -1278.153955355375, -1278.1257011700952, -1278.086488264795, -1278.0312418159333, -1277.95164876962]\n\nplt.figure(figsize=(8,4.5))\nplt.title(\"Potential energy scan for an hydrogen bond\")\nplt.xlabel(\"O-H distance / Angstrom\")\nplt.ylabel(\"Energy / Hartree\")\nplt.scatter(distances, energies)\n\n&lt;matplotlib.collections.PathCollection at 0x127be4f40&gt;\n\n\n\n\n\nThe energy minimum corresponds to about 1.7 \\(\\overset{\\circ}{A}\\) for the O-H distance. Hydrogen bond distances are known to be between 1.6 and 2.0 \\(\\overset{\\circ}{A}\\) in bulk water (Acta Cryst. 1976, A32, 24-31), so this is in fact a plausible result. The bonding energy seems to be well beyond the one expected for a hydrogen bond. An explanation for this is that the simulation does not use the optimal geometry at each bond length to get accurate bonding energies."
  },
  {
    "objectID": "examples/problem_decomposition/oniom.html#closing-words",
    "href": "examples/problem_decomposition/oniom.html#closing-words",
    "title": "ONIOM Problem Decomposition - A use case for an acetic acid molecule in water",
    "section": "3. Closing words",
    "text": "3. Closing words\nIn this notebook, a use-case simulation study has been introduced for a solvation problem. We learnt that the ONIOM problem decomposition method can be useful for studying more ambitious systems. This is done by targeting an important interaction in the system, thus allocating more computational (classical or quantum) resources to it. The environment (the remaining part), can be described with a lower-accuracy method. Therefore, a simple example has been presented as a potential starting point for a more complete research project.\nHere we have used the ONIOM problem decomposition method as a way to investigate the applicability of quantum algorithms to more industrially-relevant problems. The results are in agreement with known experimental data."
  },
  {
    "objectID": "examples/measurement_reduction/classical_shadows.html",
    "href": "examples/measurement_reduction/classical_shadows.html",
    "title": "Classical Shadows",
    "section": "",
    "text": "Open In Colab\nThe output of a quantum computer is a histogram of measurements, corresponding to the different outcomes observed, usually expressed as bitstrings. The cost and duration of a quantum experiment is roughly linear with the number of shots used to build such histograms, which also correlates with the accuracy of the results. This measurement overhead can be prohibitive for state tomography and computation of observables for quantum chemistry applications.\nThe emergent method classical shadows (Nat. Phys. 2020, 16, 1050–1057) has been developed to mitigate the measurement overhead by offloading quantum tasks to the pre- and post-processing steps. This prediction protocol exhibits logarithmic scaling with the number of terms to measure, in order to compute the expectation value of a term within a given accuracy.\nIn short, gates representing a unitary operation are appended to the state prepared by a quantum circuit. Upon measurement, the output bitstring (ex: 100101…) is stored in a conventional register. This is repeated \\(N\\) times, where \\(N\\) defines the shadow size and is equivalent to the number of shots run on the quantum hardware. The classical shadow is built from the bitstrings stored in the classical register, and can be used to calculate observables. Different flavours of classical shadow exist, as they each come with a specific protocol for choosing a set of unitaries. The figure below, from Nat. Phys. 16, 1050–1057 (2020), illustrates the randomized shadow protocol.\nThe randomized, derandomized and adaptive shadow protocols using the single-qubit Pauli basis as a set of unitaries are currently available in Tangelo. This introduction will shed light on how to leverage their use in your own investigation, and highlight the main differences between these approaches. At the end of this notebook, a comparison is made between energies predicted with those techniques and the one computed by using a Hamiltonian partitioning approach relying on qubitwise commutativity.\nThis notebook assumes that you already have installed Tangelo in your Python environment, or have updated your Python path so that the imports can be resolved. If not, executing the cell below installs the minimal requirements for this notebook.\n# Installation of tangelo if not already installed.\ntry:\n    import tangelo\nexcept ModuleNotFoundError:\n    !pip install git+https://github.com/goodchemistryco/Tangelo.git@develop --quiet"
  },
  {
    "objectID": "examples/measurement_reduction/classical_shadows.html#system-and-reference-values",
    "href": "examples/measurement_reduction/classical_shadows.html#system-and-reference-values",
    "title": "Classical Shadows",
    "section": "System and Reference Values",
    "text": "System and Reference Values\nTo demonstrate the classical shadow capabilities, we first define a molecular system composed of two hydrogen atoms in the 3-21G basis. After using the scBK qubit mapping, the Hamiltonian spans 6 qubits.\n\nfrom tangelo.molecule_library import mol_H2_321g\nfrom tangelo.toolboxes.qubit_mappings.mapping_transform import fermion_to_qubit_mapping\nfrom tangelo.toolboxes.operators import count_qubits\n\n# Encoding options.\nencoding = \"scBK\"\nup_then_down = True\n\n# Converting the fermionic Hamiltonian according to the encoding options.\nqubit_ham = fermion_to_qubit_mapping(mol_H2_321g.fermionic_hamiltonian, \n                                     encoding, \n                                     n_spinorbitals=mol_H2_321g.n_active_sos, \n                                     n_electrons=mol_H2_321g.n_active_electrons, \n                                     up_then_down=up_then_down)\n\nprint(f\"Number of qubits to describe the system: {count_qubits(qubit_ham)}\")\n\nNumber of qubits to describe the system: 6\n\n\nFor this example, the Qubit Coupled-Cluster (QCC) ansatz has been chosen (J. Chem. Theory Comput. 2018, 14(12), 6317–6326). While the circuit depth rapidly increases with the size of the basis (number of spin orbitals), the QCC ansatz admits a low-depth quantum circuit compared to the widely used Unitary Coupled-Cluster Single and Double (UCCSD) ansatz.\n\nfrom tangelo.toolboxes.ansatz_generator.qcc import QCC\n\nansatz = QCC(mol_H2_321g, mapping=encoding, up_then_down=up_then_down)\nansatz.build_circuit()\n\nprint(f\"Number of gates in the circuit: {ansatz.circuit.size}\")\n\nNumber of gates in the circuit: 79\n\n\nThe Variational Quantum Eigensolver (VQE) has been introduced in another notebook as a hybrid quantum–classical algorithm for simulating quantum systems. In the next cell, we focus on VQE within the context of optimizing the QCC variational parameters to minimize the 3-21G dihydrogen energy.\n\nfrom tangelo.algorithms.variational import VQESolver\n\nvqe = VQESolver({\"qubit_hamiltonian\": qubit_ham, \"ansatz\": ansatz.circuit})\nvqe.build()\nenergy_ref = vqe.simulate()\nprint(f\"Energy from statevector simulation: {energy_ref:.4f} hartree\")\n\nEnergy from statevector simulation: -1.1473 hartree\n\n\nNow, we can get the optimized circuit with the vqe.optimal_circuit attribute, and we also know that with the provided Hamiltonian, the ideal energy is -1.1475 hartree."
  },
  {
    "objectID": "examples/measurement_reduction/classical_shadows.html#classical-shadows",
    "href": "examples/measurement_reduction/classical_shadows.html#classical-shadows",
    "title": "Classical Shadows",
    "section": "Classical Shadows",
    "text": "Classical Shadows\nIn this section, we will revisit the computation of the 3-21G dihydrogen energy using the QCC ansatz and the classical shadow protocols. Three flavours of classical shadows are currently available in Tangelo. Each flavour has a distinct class: RandomizedClassicalShadow, DerandomizedClassicalShadow and AdaptiveClassicalShadow. Common methods build and simulate are defined to respectively construct a set of unitaries and simulate results with a given backend. As a side note, a user who wants to compare noisy simulation can do so by providing the appropriate noise_model to the Simulator object defined in the next cell.\n\nfrom tangelo.linq import get_backend, Circuit\n\n# Definition of the shots budget (shadow size) and backend.\nn_shots_budget = 1000\nbackend = get_backend(\"cirq\", noise_model=None)\n\n\nRandomized Single-Qubit Pauli Classical Shadows\nRandomized classical shadows are the orginal implementation of this algorithm. Random bases are constructed from the tensor product of random single-qubit Pauli gates (\\(X\\), \\(Y\\) or \\(Z\\)). The post-processing consists of inverting the samples with the quantum channel \\(\\mathcal{M}^{-1} = \\bigotimes_{i=1}^n \\mathcal{M}_i^{-1}\\). Observables can then be predicted from the median of means. More details can be found in Nat. Phys. 16, 1050–1057 (2020).\n\nfrom tangelo.toolboxes.measurements import RandomizedClassicalShadow\n\nrandom_cs = RandomizedClassicalShadow(vqe.optimal_circuit)\nrandom_cs.build(n_shots_budget)\nrandom_cs.simulate(backend)\n\nenergy_random = random_cs.get_observable(qubit_ham)\nprint(f\"Energy from randomized single-Pauli classical shadow: {energy_random:.4f} hartree\")\nprint(f\"Error vs statevector simulation: {abs(energy_ref-energy_random):.3f} hartree\")\n\nEnergy from randomized single-Pauli classical shadow: -1.0640 hartree\nError vs statevector simulation: 0.083 hartree\n\n\n\n\nDerandomized Single-Qubit Pauli Classical Shadows\nThe derandomized procedure aims to fix a drawback of the randomized procedure. As the number of qubits increases, the probability of matching random tensor products of single-Pauli bases with terms in a qubit Hamiltonian decreases greatly. Typically, bigger shadows are needed to compute an observable within a reasonable accuracy. The derandomized procedure takes as input a qubit operator to steer the basis choices, thus removing the randomness. This results in bases hitting the relevant operator systematically, improving the accuracy for a given shadow size versus a randomized classical shadow. More details on this algorithm can be found in Phys. Rev. Lett. 127, 030503.\n\nfrom tangelo.toolboxes.measurements import DerandomizedClassicalShadow\n\nderandom_cs = DerandomizedClassicalShadow(vqe.optimal_circuit)\nderandom_cs.build(n_shots_budget, qubit_ham)\nderandom_cs.simulate(backend)\n\nenergy_derandom = derandom_cs.get_observable(qubit_ham)\nprint(f\"Energy from derandomized single-Pauli classical shadow: {energy_derandom:.4f} hartree\")\nprint(f\"Error vs statevector simulation: {abs(energy_ref-energy_derandom):.3f} hartree\")\n\nEnergy from derandomized single-Pauli classical shadow: -1.1636 hartree\nError vs statevector simulation: 0.016 hartree\n\n\n\n\nAdaptive Single-Qubit Pauli Classical Shadows\nAnother procedure for choosing single-qubit Pauli bases is an adaptive one. It uses an iterative process to draw a Pauli gate for each qubit, one by one. The probability distributions are built so the next single-qubit Pauli gates drawn will depend on the measurement bases already assigned to previous qubits. This shifts the single-qubit Pauli basis choice towards terms hitting a given operator, while keeping a fair amount of randomness to extent the state characterization coverage. For more details on this algorithm, we refer to arXiv:2105.12207.\n\nfrom tangelo.toolboxes.measurements import AdaptiveClassicalShadow\n\nadaptive_cs = AdaptiveClassicalShadow(vqe.optimal_circuit)\nadaptive_cs.build(n_shots_budget, qubit_ham)\nadaptive_cs.simulate(backend)\n\nenergy_adaptive = adaptive_cs.get_observable(qubit_ham)\nprint(f\"Energy from adaptive single-Pauli classical shadow: {energy_adaptive:.4f} hartree\")\nprint(f\"Error vs statevector simulation: {abs(energy_ref-energy_adaptive):.3f} hartree\")\n\nEnergy from adaptive single-Pauli classical shadow: -1.0768 hartree\nError vs statevector simulation: 0.071 hartree"
  },
  {
    "objectID": "examples/measurement_reduction/classical_shadows.html#energy-with-hamiltonian-partitioning",
    "href": "examples/measurement_reduction/classical_shadows.html#energy-with-hamiltonian-partitioning",
    "title": "Classical Shadows",
    "section": "Energy with Hamiltonian Partitioning",
    "text": "Energy with Hamiltonian Partitioning\nFor a given measurement budget, we compare the accuracy of total energy computation obtained with the Hamiltonian partitioning approach relying on qubitwise commutativity, to the energy predicted by classical shadow protocols. The group_qwc method defines the minimal number of bases to measure by identifying commutating terms. Then, the number of shots can be evenly distributed or according to a heuristic that considers the term coefficients.\nThe reference value computed in the next cell only contains statistical errors and no quantum noise, even though it is always present in hardware. This shot-based simulation culminates with an energy containing an error \\(\\epsilon\\), inherent to the finite numbers of measurements. This error \\(\\epsilon\\) will be compared to the ones coming from classical shadow protocols.\n\nfrom tangelo.toolboxes.operators import QubitOperator\nfrom tangelo.toolboxes.measurements import group_qwc, exp_value_from_measurement_bases\nfrom tangelo.linq import Circuit\nfrom tangelo.linq.helpers import measurement_basis_gates\n\n# Performing Hamiltonian partitioning.\nqubitwise_measurements = group_qwc(qubit_ham)\n\n# Distributing the available number of shots evenly across identified bases.\nn_shots_per_basis = round(n_shots_budget / len(qubitwise_measurements))\n\n# Shot-based backend.\nbackend = get_backend(\"cirq\", n_shots=n_shots_per_basis, noise_model=None)\n\n# Computing the histograms for the grouped bases.\nqubitwise_results = dict()\nfor basis in qubitwise_measurements.keys():\n    basis_circuit = Circuit(measurement_basis_gates(basis))\n    qubitwise_results[basis], _ = backend.simulate(vqe.optimal_circuit + basis_circuit)\n\n# Computing the energy from the histograms.\nenergy_shots = exp_value_from_measurement_bases(qubitwise_measurements, qubitwise_results)\n\nprint(f\"Energy with qubitwise commutativity and equally distributed shots: {energy_shots:.4f} hartree\")\nprint(f\"Error vs statevector simulation: {abs(energy_ref-energy_shots):.3f} hartree\")\n\nEnergy with qubitwise commutativity and equally distributed shots: -1.1619 hartree\nError vs statevector simulation: 0.015 hartree"
  },
  {
    "objectID": "examples/measurement_reduction/classical_shadows.html#averages-of-10-runs",
    "href": "examples/measurement_reduction/classical_shadows.html#averages-of-10-runs",
    "title": "Classical Shadows",
    "section": "Averages of 10 runs",
    "text": "Averages of 10 runs\nDue to the nature of the classical shadow processes, there is a random component during prediction of observables. This is why your mileage may vary if you try to rerun all code cells in this notebook. To better portray the situation, we preran 10 simulations of 10 000 shots each for all the above methods, and compared the results to the ideal energy obtained with VQE run with an exact statevector simulator. The data is shown in the boxplot below and the ideal energy is represented by a dashed line.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndata = np.array([\n    [ 0.00508,  0.02309, -0.03742, -0.02013],\n    [ 0.01601, -0.16360, -0.02321, -0.02002],\n    [ 0.04252,  0.03412,  0.00546, -0.05518],\n    [ 0.01322,  0.10274,  0.00458,  0.02129],\n    [ 0.05665, -0.01826, -0.00687, -0.01218],\n    [ 0.05709, -0.08834, -0.01307,  0.00555],\n    [-0.00185,  0.07029,  0.00910, -0.02183],\n    [ 0.03663,  0.09825, -0.00555,  0.00459],\n    [-0.00593,  0.09175, -0.00332, -0.04029],\n    [ 0.00574, -0.03616,  0.00986, -0.02638]\n])\n\n_, ax = plt.subplots(figsize=(10,6))\nVP = ax.boxplot(data, positions=[2, 4, 6, 8], \n                widths=1, patch_artist=True,\n                showmeans=False, showfliers=False,\n                medianprops={\"color\": \"white\", \"linewidth\": 2},\n                boxprops={\"facecolor\": \"#003262\", \"edgecolor\": \"white\", \"linewidth\": 1},\n                whiskerprops={\"color\": \"#003262\", \"linewidth\": 2},\n                capprops={\"color\": \"#003262\", \"linewidth\": 2})\n\nax.set(ylim=(-.18, .15), xlim=(1, 9))\nax.hlines(y=0., xmin=0, xmax=10, linewidth=2, color=\"k\", linestyles=\"dashed\")\n\nax.set_xticklabels(labels=[\"Qubitwise commutativity\", \"Randomized\", \"Derandomized\", \"Adaptive\"],fontsize=12)\nax.set_ylabel(r\"(Noiseless Energy - Statevector Energy) / Hartree\", fontsize=12)\n\nText(0, 0.5, '(Noiseless Energy - Statevector Energy) / Hartree')\n\n\n\n\n\nFor this use case, the plot shows that the derandomized and adaptive single-qubit Pauli classical shadows seem to be more accurate than the other methods. However, it is not clear whether randomized classical shadows are more appealing than qubitwise commutativity. From those results, the scaling advantage is not apparent at first sight, at least for this system (H2 3-21G).\nClassical shadows may show benefits for larger problems, requiring many more qubit terms to be evaluated. Several studies have taken a look at the noise implication of predicting observables with shadows (arXiv:2011.09636 and arXiv:2011.11580). The authors demonstrate noise resilience inherent to classical shadows, especially when comparing to simpler sampling methods."
  },
  {
    "objectID": "examples/measurement_reduction/classical_shadows.html#closing-words",
    "href": "examples/measurement_reduction/classical_shadows.html#closing-words",
    "title": "Classical Shadows",
    "section": "Closing words",
    "text": "Closing words\nWe demonstrated the use of several classical shadow protocols in this notebook. As their theoretical scaling is logarithmic with the number of linear functions in a qubit operator, they show potential for helping mitigate the measurement problem. Using Tangelo, we showed how straightforward it is to incorporate classical shadows in your own research projects.\nMany avenues have yet to be explored. For example, active research areas include implementation of classical shadows on NISQ devices, and some works report an inherent noise resilience (arXiv:2011.11580). What will you do with classical shadows and Tangelo ?"
  },
  {
    "objectID": "examples/measurement_reduction/classical_shadows.html#references",
    "href": "examples/measurement_reduction/classical_shadows.html#references",
    "title": "Classical Shadows",
    "section": "References",
    "text": "References\n\nChen, S., Yu, W., Zeng, P. & Flammia, S. T. Robust shadow estimation. arXiv:2011.09636 [quant-ph] (2020).\nKoh, D. E. & Grewal, S. Classical Shadows with Noise. arXiv:2011.11580 [math-ph, physics:quant-ph] (2020).\nHuang, H.-Y., Kueng, R. & Preskill, J. Efficient estimation of Pauli observables by derandomization. arXiv:2103.07510 [quant-ph] (2021).\nHadfield, C. Adaptive Pauli Shadows for Energy Estimation. arXiv:2105.12207 [quant-ph] (2021).\nHuang, H. Y., Kueng, R. & Preskill, J. Predicting many properties of a quantum system from very few measurements. Nature Physics 16, 1050–1057 (2020)."
  }
]