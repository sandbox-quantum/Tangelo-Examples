<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>iqcc_using_clifford</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


</head>

<body class="nav-sidebar docked nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark border-bottom">
      <div class="navbar-container container-fluid">
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html">
 <span class="menu-text">Home</span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">Examples</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false">Chemistry</a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/chemistry/excited_states.html" class="sidebar-item-text sidebar-link">Excited States in Tangelo</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/chemistry/qchem_modelling_basics.html" class="sidebar-item-text sidebar-link">Quantum Chemistry: Modelling Basics</a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false">Hardware Experiments</a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/hardware_experiments/berylium_ibm_quantum.html" class="sidebar-item-text sidebar-link">Combining Tangelo, QEMIST Cloud and IBM Quantum for quantum experiments</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/hardware_experiments/overview_endtoend.html" class="sidebar-item-text sidebar-link">End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/hardware_experiments/qemist_cloud_hardware_experiments_braket.html" class="sidebar-item-text sidebar-link">Submitting quantum hardware experiments with Tangelo and QEMIST Cloud</a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">Measurement Reduction</a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/measurement_reduction/classical_shadows.html" class="sidebar-item-text sidebar-link">Classical Shadows</a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false">Problem Decomposition</a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/problem_decomposition/dmet.html" class="sidebar-item-text sidebar-link">Density Matrix Embedding Theory (DMET)</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/problem_decomposition/mifno.html" class="sidebar-item-text sidebar-link">Exploring the Method of Increments with QEMIST Cloud and Tangelo</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/problem_decomposition/oniom.html" class="sidebar-item-text sidebar-link">ONIOM Problem Decomposition - A use case for an acetic acid molecule in water</a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true">Variational Methods</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth2 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/variational_methods/adapt.html" class="sidebar-item-text sidebar-link">ADAPT-VQE</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/variational_methods/iqcc_using_clifford.html" class="sidebar-item-text sidebar-link active">Iterative Qubit Coupled Cluster using only Clifford circuits</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/variational_methods/vqe_custom_ansatz_hamiltonian.html" class="sidebar-item-text sidebar-link">Tangelo VQE: Custom Ansatz and qubit Hamiltonian Tutorial</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/variational_methods/vqe.html" class="sidebar-item-text sidebar-link">VQE with Tangelo</a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="false">Workflow Basics</a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="false">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/workflow_basics/3.noisy_simulation.html" class="sidebar-item-text sidebar-link">Linq: noisy simulation</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/workflow_basics/1.the_basics.html" class="sidebar-item-text sidebar-link">Linq: the basics</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../examples/workflow_basics/2.qpu_connection.html" class="sidebar-item-text sidebar-link">Using quantum cloud services API with Tangelo</a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="iterative-qubit-coupled-cluster-using-only-clifford-circuits" class="level1">
<h1>Iterative Qubit Coupled Cluster using only Clifford circuits</h1>
<p>This notebook shows how to implement iQCC using only Clifford circuits with Tangelo, and accompanies a note released at <a href="https://arxiv.org/abs/2211.10501">arXiv:2211.10501</a>. We provide here the abstract of the article in this notebook for convenience and highlight the main steps of our implementation. Please refer to the article for full details.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://colab.research.google.com/github/goodchemistryco/Tangelo/blob/develop/examples/iqcc_using_clifford.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Open In Colab</figcaption><p></p>
</figure>
</div>
<section id="abstract" class="level3">
<h3 class="anchored" data-anchor-id="abstract">Abstract</h3>
<p>We draw attention to a variant of the iterative qubit coupled cluster (iQCC) method that only uses Clifford circuits. The iQCC method relies on a small parameterized wave function ansatz, which takes form as a product of exponentiated Pauli word operators, to approximate the ground state electronic energy of a mean field reference state through iterative qubit Hamiltonian transformations. In this variant of the iQCC method, the wave function ansatz at each iteration is restricted to a single exponentiated Pauli word operator and parameter. The Rotosolve algorithm utilizes Hamiltonian expectation values computed with Clifford circuits to optimize the single-parameter Pauli word ansatz. Although the exponential growth of Hamiltonian terms is preserved with this variation of iQCC, we suggest several methods to mitigate this effect. This method is useful for near-term variational quantum algorithm applications as it generates good initial parameters by using Clifford circuits which can be efficiently simulated on a classical computers according to the Gottesmanâ€“Knill theorem. It may also be useful beyond the NISQ era to create short-depth Clifford pre-optimized circuits that improve the success probability for fault-tolerant algorithms such as phase estimation.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Installation of tangelo if not already installed.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> tangelo</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> ModuleNotFoundError:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>pip install git<span class="op">+</span>https:<span class="op">//</span>github.com<span class="op">/</span>goodchemistryco<span class="op">/</span>Tangelo.git<span class="op">@</span>develop <span class="op">--</span>quiet</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="define-clifford-simulator" class="level3">
<h3 class="anchored" data-anchor-id="define-clifford-simulator">Define Clifford simulator</h3>
<p>We define a Clifford simulator using cirq. This is a child class of <code>CirqSimulator</code> where we overwrite <code>simulate_circuit</code> and use <code>cirq.CliffordSimulator</code>.</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.linq <span class="im">import</span> Circuit</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.linq.target.target_cirq <span class="im">import</span> CirqSimulator</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.linq.target.backend <span class="im">import</span> Backend</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.linq.translator <span class="im">import</span> translate_circuit <span class="im">as</span> translate</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CirqCliffordSimulator(CirqSimulator):</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> simulate_circuit(<span class="va">self</span>, source_circuit: Circuit, return_statevector<span class="op">=</span><span class="va">False</span>, initial_statevector<span class="op">=</span><span class="va">None</span>, save_mid_circuit_meas<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Perform state preparation corresponding to the input circuit using cirq.CliffordSimulator</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">            source_circuit: a circuit in the Tangelo format to be translated</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">            return_statevector (bool): option to return the statevector.</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">            initial_statevector(list/array) : Not currently supported</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">            save_mid_circuit_meas (bool): Option to save mid circuit measurement values</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co">            dict: A dictionary mapping multi-qubit states to their corresponding frequency.</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co">            numpy.array: The statevector, if available for the target backend</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co">                and requested by the user (if not, set to None).</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        cirq_circuit <span class="op">=</span> translate(source_circuit, <span class="st">"cirq"</span>)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.circuit <span class="op">=</span> cirq_circuit</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        cirq_simulator <span class="op">=</span> <span class="va">self</span>.cirq.CliffordSimulator()</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.result <span class="op">=</span> cirq_simulator.simulate(cirq_circuit)</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._current_state <span class="op">=</span> <span class="va">self</span>.result.final_state.to_numpy()</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        frequencies <span class="op">=</span> <span class="va">self</span>._statevector_to_frequencies(<span class="va">self</span>._current_state)</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If requested, set initial state</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> initial_statevector <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Initial statevector is not currently supported in </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>__class__<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (frequencies, <span class="va">self</span>._current_state) <span class="cf">if</span> return_statevector <span class="cf">else</span> (frequencies, <span class="va">None</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="class-that-implements-iqcc-using-only-clifford-circuits" class="level3">
<h3 class="anchored" data-anchor-id="class-that-implements-iqcc-using-only-clifford-circuits">Class that implements iQCC using only Clifford circuits</h3>
<p>The <code>iQCConlyClifford</code> class is defined as a child class of <code>ADAPTSolver</code> and replaces the <code>simulate</code> and <code>rank_pool</code> functions. A non-clifford backend is used only to check that the full circuit obtains the same energy using the original qubit hamiltonian.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Type</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> copy <span class="im">import</span> deepcopy</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.algorithms <span class="im">import</span> ADAPTSolver</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.linq <span class="im">import</span> Circuit</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.operators <span class="im">import</span> QubitOperator</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.ansatz_generator.ansatz_utils <span class="im">import</span> get_exponentiated_qubit_operator_circuit</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.molecular_computation.molecule <span class="im">import</span> SecondQuantizedMolecule</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.qubit_mappings.mapping_transform <span class="im">import</span> fermion_to_qubit_mapping</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.ansatz_generator._qubit_cc <span class="im">import</span> get_dis_groups, get_gens_from_idxs</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.ansatz_generator._qubit_mf <span class="im">import</span> init_qmf_from_hf</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.ansatz_generator._qubit_cc <span class="im">import</span> qcc_op_dress</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> iQCConlyClifford(ADAPTSolver):</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""iQCC using only Clifford Class. This is an iterative algorithm that uses Clifford circuits</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co">    along with Rotosolve to rank single Pauli word operators and obtain its optimal energy and rotation.</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Attributes:</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co">        molecule (SecondQuantizedMolecule): The molecular system.</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co">        tol (float): Maximum gradient allowed for a particular operator  before</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="co">            convergence.</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co">        max_cycles (int): Maximum number of iterations for ADAPT.</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co">        pool (func): Function that returns a list of FermionOperator. Each</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="co">            element represents excitation/operator that has an effect of the</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="co">            total energy.</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="co">        pool_args (dict) : The arguments for the pool function. Will be unpacked in</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="co">            function call as pool(**pool_args)</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="co">        qubit_mapping (str): One of the supported qubit mapping identifiers.</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="co">        qubit_hamiltonian (QubitOperator-like): Self-explanatory.</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="co">        up_then_down (bool): Spin orbitals ordering.</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="co">        n_spinorbitals (int): Self-explanatory.</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="co">        n_electrons (int): Self-explanatory.</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="co">        optimizer (func): Optimization function for VQE minimization.</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="co">        backend_options (dict): Backend options for the underlying VQE object.</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="co">        verbose (bool): Flag for verbosity of VQE.</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="co">        deflation_circuits (list[Circuit]): Deflation circuits to add an</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a><span class="co">            orthogonalization penalty with.</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="co">        deflation_coeff (float): The coefficient of the deflation.</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="co">        ref_state (array or Circuit): The reference configuration to use. Replaces HF state</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a><span class="co">        clifford_simulator(Type[Backend]): The clifford simulator used for the operator selection</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="co">            and minimization.</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a><span class="co">     """</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, opt_dict: <span class="bu">dict</span>, clifford_simulator: Type[Backend]):</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(opt_dict<span class="op">=</span>opt_dict)</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.clifford_simulator <span class="op">=</span> clifford_simulator</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.qu_op_length <span class="op">=</span> []</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> rank_pool(<span class="va">self</span>, circuit: Circuit, backend: Type[Backend]):</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Rank pool of operators with a specific circuit.</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a><span class="co">            reference_circuit (tangelo.linq.Circuit): Reference circuit that only uses Clifford gates</span></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a><span class="co">            backend (tangelo.linq.backend): Clifford backend to compute expectation values as child class of Backend</span></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a><span class="co">            int: Index of the operators with the highest gradient. If it is not</span></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a><span class="co">                bigger than tolerance, returns -1.</span></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.vqe_solver.ansatz.operators) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>            dressed_qu_op <span class="op">=</span> qcc_op_dress(deepcopy(<span class="va">self</span>.qubit_hamiltonian), <span class="va">self</span>.vqe_solver.ansatz.operators[::<span class="op">-</span><span class="dv">1</span>],</span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>                                                  <span class="va">self</span>.vqe_solver.optimal_var_params[::<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.energies[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> backend.get_expectation_value(dressed_qu_op, <span class="va">self</span>.vqe_solver.ansatz.prepare_reference_state())</span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Dressed Hamiltonian, same initial state energy"</span>, <span class="va">self</span>.energies[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>            dressed_qu_op <span class="op">=</span> <span class="va">self</span>.qubit_hamiltonian</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.qu_op_length.append(<span class="bu">len</span>(dressed_qu_op.terms))</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pool_operators <span class="op">=</span> <span class="va">self</span>.pool(<span class="va">self</span>.molecule, <span class="va">self</span>.qubit_mapping, <span class="va">self</span>.up_then_down, dressed_qu_op)</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>        len_pool <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.pool_operators)</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a>        thetas <span class="op">=</span> np.zeros(len_pool)</span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>        eners <span class="op">=</span> np.zeros(len_pool)</span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, pool_op <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.pool_operators):</span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a>            <span class="co"># get_exponentiated_qubit_operator_circuit multiplies time by 2</span></span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a>            cpl <span class="op">=</span> get_exponentiated_qubit_operator_circuit(pool_op, time<span class="op">=</span>np.pi<span class="op">/</span><span class="dv">4</span>)</span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>            cmi <span class="op">=</span> get_exponentiated_qubit_operator_circuit(pool_op, time<span class="op">=-</span>np.pi<span class="op">/</span><span class="dv">4</span>)</span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a>            epl <span class="op">=</span> backend.get_expectation_value(dressed_qu_op, circuit<span class="op">+</span>cpl)</span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>            emi <span class="op">=</span> backend.get_expectation_value(dressed_qu_op, circuit<span class="op">+</span>cmi)</span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>            ener <span class="op">=</span> <span class="va">self</span>.energies[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>            theta_min <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> np.pi <span class="op">-</span> np.arctan2(<span class="fl">2.</span> <span class="op">*</span> ener <span class="op">-</span> epl <span class="op">-</span> emi, epl <span class="op">-</span> emi)</span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>            a <span class="op">=</span> <span class="fl">0.5</span><span class="op">*</span>np.sqrt((<span class="dv">2</span><span class="op">*</span>ener<span class="op">-</span>epl<span class="op">-</span>emi)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(epl<span class="op">-</span>emi)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a>            b <span class="op">=</span> np.arctan2(<span class="fl">2.</span> <span class="op">*</span> ener <span class="op">-</span> epl <span class="op">-</span> emi, epl <span class="op">-</span> emi)</span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">*</span>(epl<span class="op">+</span>emi)</span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a>            eners[i] <span class="op">=</span> a<span class="op">*</span>np.sin(theta_min<span class="op">+</span>b)<span class="op">+</span>c</span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a>            thetas[i] <span class="op">=</span> theta_min</span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a>        index <span class="op">=</span> np.argmin(eners)</span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.new_param <span class="op">=</span> thetas[index]</span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.verbose:</span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f'Chosen parameter is </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>new_param<span class="sc">}</span><span class="ss"> with energy </span><span class="sc">{</span>eners[index]<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> index <span class="cf">if</span> <span class="va">self</span>.energies[<span class="op">-</span><span class="dv">1</span>]<span class="op">-</span>eners[index] <span class="op">&gt;</span> <span class="va">self</span>.tol <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> simulate(<span class="va">self</span>):</span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Performs the iQCC cycles. No VQE minimization is performed but there is a check of the full circuit</span></span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a><span class="co">        with the initial Hamiltonian</span></span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>        params <span class="op">=</span> <span class="va">self</span>.vqe_solver.ansatz.var_params</span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.new_param <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.energies.append(<span class="va">self</span>.vqe_solver.energy_estimation([]))</span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Construction of the ansatz. self.max_cycles terms are added, unless</span></span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a>        <span class="co"># all operator gradients are less than self.tol.</span></span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">self</span>.iteration <span class="op">&lt;</span> <span class="va">self</span>.max_cycles:</span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.iteration <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.verbose:</span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Iteration </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>iteration<span class="sc">}</span><span class="ss"> of iQCC using only Clifford circuits."</span>)</span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a>            ref_circuit <span class="op">=</span> (<span class="va">self</span>.vqe_solver.ansatz.prepare_reference_state() <span class="cf">if</span> <span class="va">self</span>.ref_state <span class="kw">is</span> <span class="va">None</span> <span class="cf">else</span></span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a>                            <span class="va">self</span>.vqe_solver.reference_circuit <span class="op">+</span> <span class="va">self</span>.vqe_solver.ansatz.prepare_reference_state())</span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a>            pool_select <span class="op">=</span> <span class="va">self</span>.rank_pool(ref_circuit,</span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a>                                         backend<span class="op">=</span><span class="va">self</span>.clifford_simulator)</span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If pool selection returns an operator that changes the energy by</span></span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a>            <span class="co"># more than self.tol. Else, the loop is complete and the energy is</span></span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a>            <span class="co"># considered as converged.</span></span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> pool_select <span class="op">&gt;</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Adding a new operator to beginning of operator list</span></span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Previous parameters are kept as they were.</span></span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.vqe_solver.ansatz.operators <span class="op">=</span> [<span class="va">self</span>.pool_operators[pool_select]] <span class="op">+</span> <span class="va">self</span>.vqe_solver.ansatz.operators</span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a>                params <span class="op">=</span> [<span class="va">self</span>.new_param] <span class="cf">if</span> <span class="va">self</span>.vqe_solver.optimal_var_params <span class="kw">is</span> <span class="va">None</span> <span class="cf">else</span> [<span class="va">self</span>.new_param] <span class="op">+</span> <span class="bu">list</span>(<span class="va">self</span>.vqe_solver.optimal_var_params)</span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.vqe_solver.ansatz._n_terms_operators <span class="op">=</span> [<span class="dv">1</span>] <span class="op">+</span> <span class="va">self</span>.vqe_solver.ansatz._n_terms_operators</span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.vqe_solver.ansatz._var_params_prefactor <span class="op">=</span> [<span class="dv">1</span>] <span class="op">+</span> <span class="va">self</span>.vqe_solver.ansatz._var_params_prefactor</span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.vqe_solver.initial_var_params <span class="op">=</span> params</span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.vqe_solver.ansatz.build_circuit()</span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Non-clifford simulator used to verify that the energy is the same as determined using the Clifford simulator.</span></span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.vqe_solver.optimal_energy <span class="op">=</span> <span class="va">self</span>.vqe_solver.energy_estimation(params)</span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.verbose:</span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"Full circuit with original Hamiltonian energy = </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>vqe_solver<span class="sc">.</span>optimal_energy<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.vqe_solver.optimal_var_params <span class="op">=</span> params</span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a>                opt_energy <span class="op">=</span> <span class="va">self</span>.vqe_solver.optimal_energy</span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a>                params <span class="op">=</span> <span class="bu">list</span>(<span class="va">self</span>.vqe_solver.optimal_var_params)</span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.energies.append(opt_energy)</span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.converged <span class="op">=</span> <span class="va">True</span></span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.energies[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> full_qcc_pool(mol: SecondQuantizedMolecule, mapping: <span class="bu">str</span>, up_then_down: <span class="bu">bool</span>, qubit_hamiltonian: QubitOperator):</span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Generate all possible generators in the DIS for qubit_hamiltonian</span></span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a><span class="co">        mol (SecondQuantizedMolecule): The molecule to determine the DIS pool for.</span></span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a><span class="co">        mapping (str): One of the support qubit mappings</span></span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a><span class="co">        up_then_down (bool): Spin orbitals ordering. True is all alpha then beta orbitals. False is alternating.</span></span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a><span class="co">        qubit_hamiltonian (QubitOperator): The current dressed qubit hamiltonian.</span></span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-162"><a href="#cb3-162" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb3-163"><a href="#cb3-163" aria-hidden="true" tabindex="-1"></a><span class="co">        list: DIS pool operators</span></span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a>    qmf_var_params <span class="op">=</span> init_qmf_from_hf(mol.n_active_sos, mol.n_active_electrons, </span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a>                                      mapping, up_then_down, mol.spin)</span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a>    dis, dis_groups <span class="op">=</span> [], get_dis_groups(qubit_hamiltonian, qmf_var_params, <span class="fl">3.e-5</span>)</span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> dis_group <span class="kw">in</span> dis_groups:</span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a>        dis_group_idxs <span class="op">=</span> [<span class="bu">int</span>(idxs) <span class="cf">for</span> idxs <span class="kw">in</span> dis_group[<span class="dv">0</span>].split(<span class="st">" "</span>)]</span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a>        dis_group_gens <span class="op">=</span> get_gens_from_idxs(dis_group_idxs)</span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a>        dis.append(dis_group_gens)</span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a>    dis_flat <span class="op">=</span> [item <span class="cf">for</span> sublist <span class="kw">in</span> dis <span class="cf">for</span> item <span class="kw">in</span> sublist]</span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dis_flat</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="running-the-algorithm-for-h3" class="level3">
<h3 class="anchored" data-anchor-id="running-the-algorithm-for-h3">Running the algorithm for H<sub>3</sub></h3>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.molecular_computation.molecule <span class="im">import</span> SecondQuantizedMolecule</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.algorithms.classical <span class="im">import</span> FCISolver</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define molecular system</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>xyz_H3 <span class="op">=</span> [</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"H"</span>, (<span class="fl">0.</span>, <span class="fl">0.</span>, <span class="fl">0.</span>)),</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"H"</span>, (<span class="fl">0.</span>, <span class="fl">0.</span>, <span class="fl">0.7414</span>)),</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"H"</span>, (<span class="fl">0.</span>, <span class="fl">0.</span>, <span class="dv">2</span><span class="op">*</span><span class="fl">0.7414</span>))</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> SecondQuantizedMolecule(xyz_H3, q<span class="op">=</span><span class="dv">0</span>, spin<span class="op">=</span><span class="dv">1</span>, basis<span class="op">=</span><span class="st">"sto-3g"</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>max_cycles <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate reference FCI energy</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>cc <span class="op">=</span> FCISolver(mol)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>exact <span class="op">=</span> cc.simulate()</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>mapping <span class="op">=</span> <span class="st">"JKMN"</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>qu_op <span class="op">=</span> fermion_to_qubit_mapping(mol.fermionic_hamiltonian, mapping, mol.n_active_sos, mol.n_active_electrons, up_then_down<span class="op">=</span><span class="va">False</span>, spin<span class="op">=</span>mol.active_spin)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>pool_args <span class="op">=</span> {<span class="st">"mol"</span>: mol, <span class="st">"mapping"</span>: mapping, <span class="st">"up_then_down"</span>: <span class="va">False</span>, <span class="st">"qubit_hamiltonian"</span>: qu_op}</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>backend_options <span class="op">=</span> {}  <span class="co"># {"target": QulacsSimulator}</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>opt_dict <span class="op">=</span> {<span class="st">"molecule"</span>: mol, <span class="st">"tol"</span>: <span class="fl">1.e-9</span>, <span class="st">"max_cycles"</span>: max_cycles, <span class="st">"verbose"</span>: <span class="va">True</span>,</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>            <span class="st">"qubit_mapping"</span>: mapping, <span class="st">"n_spinorbitals"</span>: mol.n_active_sos, <span class="st">"n_electrons"</span>: mol.n_active_electrons, </span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>            <span class="st">"pool"</span>: full_qcc_pool, <span class="st">"pool_args"</span>: pool_args, <span class="st">"up_then_down"</span>: <span class="va">False</span>, <span class="st">"backend_options"</span>: backend_options}</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>iQCC_C_solver <span class="op">=</span> iQCConlyClifford(opt_dict, CirqCliffordSimulator())</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>iQCC_C_solver.build()</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>iQCC_C_solver.simulate()</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">The pool operators used are"</span>)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(iQCC_C_solver.ansatz.operators)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"with corresponding parameters"</span>)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(iQCC_C_solver.vqe_solver.optimal_var_params)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> The final energy is </span><span class="sc">{</span>iQCC_C_solver<span class="sc">.</span>energies[<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss"> with error </span><span class="sc">{</span>iQCC_C_solver<span class="sc">.</span>energies[<span class="op">-</span><span class="dv">1</span>]<span class="op">-</span>exact<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> The number of H terms at each iteration is"</span>)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(iQCC_C_solver.qu_op_length)</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a><span class="co">#adapt_circ = adapt_solver.vqe_solver.optimal_circuit</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
 Iteration 1 of iQCC using only Clifford circuits.
Chosen parameter is 0.19497620390733506 with energy -1.5146298806979668
Full circuit with original Hamiltonian energy = -1.514629880697965

 Iteration 2 of iQCC using only Clifford circuits.
Dressed Hamiltonian, same initial state energy -1.5146298806979663
Chosen parameter is -0.10349849269458078 with energy -1.5218965900518353
Full circuit with original Hamiltonian energy = -1.5218965900518329

 Iteration 3 of iQCC using only Clifford circuits.
Dressed Hamiltonian, same initial state energy -1.521896590051836
Chosen parameter is 0.08657354901273173 with energy -1.5244271035716803
Full circuit with original Hamiltonian energy = -1.5244271035716768

 Iteration 4 of iQCC using only Clifford circuits.
Dressed Hamiltonian, same initial state energy -1.5244271035716799
Chosen parameter is -0.08225117291478923 with energy -1.5267582996827964
Full circuit with original Hamiltonian energy = -1.526758299682792

The pool operators used are
[1.0 [Y1 X4], 1.0 [Y5], 1.0 [Y1 X4 X5], 1.0 [Y0 X2 X3 X4]]
with corresponding parameters
[-0.08225117291478923, 0.08657354901273173, -0.10349849269458078, 0.19497620390733506]

 The final energy is -1.526758299682792 with error 0.0001887054536875432

 The number of H terms at each iteration is
[62, 96, 125, 138]</code></pre>
</div>
</div>
</section>
<section id="plots-of-energy-convergence-and-growth-of-hamiltonian-terms" class="level3">
<h3 class="anchored" data-anchor-id="plots-of-energy-convergence-and-growth-of-hamiltonian-terms">Plots of energy convergence and growth of Hamiltonian terms</h3>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>fig.set_size_inches(<span class="dv">16</span>, <span class="dv">8</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>ax1.set_xticks(<span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">len</span>(iQCC_C_solver.energies))))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"Energy convergence"</span>, fontdict<span class="op">=</span>{<span class="st">"size"</span>: <span class="dv">20</span>})</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">"Iteration Number"</span>, fontdict<span class="op">=</span>{<span class="st">"size"</span>: <span class="dv">14</span>})</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">"Energy Error (Hartree)"</span>, fontdict<span class="op">=</span>{<span class="st">"size"</span>: <span class="dv">14</span>})</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>ax1.semilogy(<span class="bu">range</span>(<span class="bu">len</span>(iQCC_C_solver.energies)), np.<span class="bu">abs</span>(iQCC_C_solver.energies<span class="op">-</span>exact), <span class="st">"-x"</span> )</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"Hamiltonian Growth"</span>, fontdict<span class="op">=</span>{<span class="st">"size"</span>: <span class="dv">20</span>})</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">"# H terms"</span>, fontdict<span class="op">=</span>{<span class="st">"size"</span>: <span class="dv">14</span>})</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>ax2.set_xticks(<span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">len</span>(iQCC_C_solver.qu_op_length))))</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">"Iteration #"</span>, fontdict<span class="op">=</span>{<span class="st">"size"</span>: <span class="dv">14</span>})</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>ax2.semilogy(<span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">len</span>(iQCC_C_solver.qu_op_length))), iQCC_C_solver.qu_op_length)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="iqcc_using_clifford_files/figure-html/cell-6-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="optimizing-interior-generators" class="level3">
<h3 class="anchored" data-anchor-id="optimizing-interior-generators">Optimizing interior generators</h3>
<p>Below is the method highlighted in the manuscript to optimize interior generators</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.linq <span class="im">import</span> get_backend, Gate, Circuit</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>dressed_qu_op <span class="op">=</span> qcc_op_dress(deepcopy(iQCC_C_solver.qubit_hamiltonian),</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                             iQCC_C_solver.vqe_solver.ansatz.operators[::<span class="op">-</span><span class="dv">1</span>],</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                             iQCC_C_solver.vqe_solver.optimal_var_params[::<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>ref_circ <span class="op">=</span> iQCC_C_solver.vqe_solver.ansatz.prepare_reference_state()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> optimize_interior_generator(op_index, ref_circ):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    dressed_qu_op <span class="op">=</span> qcc_op_dress(deepcopy(iQCC_C_solver.qubit_hamiltonian),</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                                 <span class="bu">list</span>(<span class="bu">reversed</span>(iQCC_C_solver.vqe_solver.ansatz.operators[op_index<span class="op">+</span><span class="dv">1</span>:<span class="dv">4</span>])),</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                                 <span class="bu">list</span>(<span class="bu">reversed</span>(iQCC_C_solver.vqe_solver.optimal_var_params[op_index<span class="op">+</span><span class="dv">1</span>:<span class="dv">4</span>])))</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    dressed_ref_qu_op <span class="op">=</span> QubitOperator((), <span class="dv">1</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(op_index<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> iQCC_C_solver.vqe_solver.optimal_var_params[i]</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> iQCC_C_solver.vqe_solver.ansatz.operators[i]</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        dressed_ref_qu_op <span class="op">*=</span> (np.cos(p<span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>QubitOperator((), <span class="dv">1</span>) <span class="op">-</span> <span class="ot">1j</span><span class="op">*</span>np.sin(p<span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>q)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CirqCliffordSimulator is very slow but does work</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># sim = CirqCliffordSimulator()</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use default simulator instead, ideally qulacs is installed</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    sim <span class="op">=</span> get_backend()</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    expect0 <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    expectpl <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    expectmi <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    circpl <span class="op">=</span> get_exponentiated_qubit_operator_circuit(iQCC_C_solver.ansatz.operators[op_index], time<span class="op">=</span>np.pi<span class="op">/</span><span class="dv">4</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    circmi <span class="op">=</span> get_exponentiated_qubit_operator_circuit(iQCC_C_solver.ansatz.operators[op_index], time<span class="op">=-</span>np.pi<span class="op">/</span><span class="dv">4</span>)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    circ0 <span class="op">=</span> get_exponentiated_qubit_operator_circuit(iQCC_C_solver.ansatz.operators[op_index], time<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    zero_one_qu_op <span class="op">=</span> QubitOperator(<span class="st">"X6"</span>) <span class="op">+</span> QubitOperator(<span class="st">"Y6"</span>, <span class="ot">1j</span>)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> term1, coeff1 <span class="kw">in</span> dressed_ref_qu_op.terms.items():</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        ref_circ1 <span class="op">=</span> Circuit([Gate(<span class="st">"C"</span><span class="op">+</span>op, q, <span class="dv">6</span>) <span class="cf">for</span> q, op <span class="kw">in</span> term1], n_qubits<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> term2, coeff2 <span class="kw">in</span> dressed_ref_qu_op.terms.items():</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>            ref_circ2 <span class="op">=</span> Circuit([Gate(<span class="st">"C"</span><span class="op">+</span>op, q, <span class="dv">6</span>) <span class="cf">for</span> q, op <span class="kw">in</span> term2], n_qubits<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>            prep_12_circuit <span class="op">=</span> ref_circ <span class="op">+</span> Circuit([Gate(<span class="st">"H"</span>, <span class="dv">6</span>)]) <span class="op">+</span> ref_circ1 <span class="op">+</span> Circuit([Gate(<span class="st">"X"</span>, <span class="dv">6</span>)]) <span class="op">+</span> ref_circ2</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> hterm, hcoeff <span class="kw">in</span> dressed_qu_op.terms.items():</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>                qu_circ <span class="op">=</span> Circuit([Gate(<span class="st">"C"</span><span class="op">+</span>op, q, <span class="dv">6</span>) <span class="cf">for</span> q, op <span class="kw">in</span> hterm], n_qubits<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>                plus_circ <span class="op">=</span> prep_12_circuit <span class="op">+</span> circpl <span class="op">+</span> qu_circ <span class="op">+</span> Circuit([Gate(<span class="st">"X"</span>, <span class="dv">6</span>)])</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>                expectpl <span class="op">+=</span> sim.get_expectation_value(zero_one_qu_op, plus_circ) <span class="op">*</span> coeff1 <span class="op">*</span> np.conj(coeff2) <span class="op">*</span> hcoeff</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>                minus_circ <span class="op">=</span> prep_12_circuit <span class="op">+</span> circmi <span class="op">+</span> qu_circ <span class="op">+</span> Circuit([Gate(<span class="st">"X"</span>, <span class="dv">6</span>)])</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>                expectmi <span class="op">+=</span> sim.get_expectation_value(zero_one_qu_op, minus_circ) <span class="op">*</span> coeff1 <span class="op">*</span> np.conj(coeff2) <span class="op">*</span> hcoeff</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>                zero_circ <span class="op">=</span> prep_12_circuit <span class="op">+</span> circ0 <span class="op">+</span> qu_circ <span class="op">+</span> Circuit([Gate(<span class="st">"X"</span>, <span class="dv">6</span>)])</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>                expect0 <span class="op">+=</span> sim.get_expectation_value(zero_one_qu_op, zero_circ) <span class="op">*</span> coeff1 <span class="op">*</span> np.conj(coeff2) <span class="op">*</span> hcoeff</span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>    ener<span class="op">=</span> expect0.real</span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>    epl <span class="op">=</span> expectpl.real</span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>    emi <span class="op">=</span> expectmi.real</span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>    theta_min <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> np.pi <span class="op">-</span> np.arctan2(<span class="fl">2.</span> <span class="op">*</span> ener <span class="op">-</span> epl <span class="op">-</span> emi, epl <span class="op">-</span> emi)</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> <span class="fl">0.5</span><span class="op">*</span>np.sqrt((<span class="dv">2</span><span class="op">*</span>ener<span class="op">-</span>epl<span class="op">-</span>emi)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(epl<span class="op">-</span>emi)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> np.arctan2(<span class="fl">2.</span> <span class="op">*</span> ener <span class="op">-</span> epl <span class="op">-</span> emi, epl <span class="op">-</span> emi)</span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">*</span>(epl<span class="op">+</span>emi)</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>    new_energy <span class="op">=</span> a<span class="op">*</span>np.sin(theta_min<span class="op">+</span>b)<span class="op">+</span>c</span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> theta_min, new_energy</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Perform one rotosolve sweep</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>starting_energy <span class="op">=</span> iQCC_C_solver.vqe_solver.energy_estimation(iQCC_C_solver.vqe_solver.optimal_var_params)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"iQCC using only Clifford circuits results in energy </span><span class="sc">{</span>starting_energy<span class="sc">}</span><span class="ss"> with error </span><span class="sc">{</span>starting_energy<span class="op">-</span>exact<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Start at max_cycles-1 as operator 0 was the last optimized.</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> op_index <span class="kw">in</span> <span class="bu">range</span>(max_cycles<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    theta_min, new_energy <span class="op">=</span> optimize_interior_generator(op_index, ref_circ)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Optimizing operator </span><span class="sc">{</span>op_index<span class="sc">}</span><span class="ss"> results in new energy of </span><span class="sc">{</span>new_energy<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    iQCC_C_solver.vqe_solver.optimal_var_params[op_index] <span class="op">=</span> theta_min</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    calculated_new_energy <span class="op">=</span> iQCC_C_solver.vqe_solver.energy_estimation(iQCC_C_solver.vqe_solver.optimal_var_params)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"The calculated new energy is </span><span class="sc">{</span>calculated_new_energy<span class="sc">}</span><span class="ss"> with error </span><span class="sc">{</span>calculated_new_energy<span class="op">-</span>exact<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>iQCC using only Clifford circuits results in energy -1.526758299682792 with error 0.0001887054536875432

 Optimizing operator 3 results in new energy of -1.5268018129766077
The calculated new energy is -1.5268018129766032 with error 0.00014519215987629508

 Optimizing operator 2 results in new energy of -1.5268018780136394
The calculated new energy is -1.526801878013637 with error 0.0001451271228425366

 Optimizing operator 1 results in new energy of -1.5268303820972458
The calculated new energy is -1.5268303820972426 with error 0.0001166230392368739

 Optimizing operator 0 results in new energy of -1.5268319664163135
The calculated new energy is -1.5268319664163104 with error 0.00011503872016915828</code></pre>
</div>
</div>
</section>
<section id="closing-words" class="level2">
<h2 class="anchored" data-anchor-id="closing-words">Closing words</h2>
<p>This notebook shows that a variant of iQCC can be implemented while only using Clifford circuits as described in our <a href="https://arxiv.org/abs/2211.10501">manuscript</a>. This method can be used to initialize the QCC ansatz for VQE or to create short depth circuits that improve the success probability of fault-tolerant algorithms such as phase estimation.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>